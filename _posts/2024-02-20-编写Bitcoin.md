---
layout: post
toc: true
title: "ç¼–å†™Bitcoin"
categories: æŠ€æœ¯
tags: [åŒºå—é“¾]
author:
  - chenleyi
---


## Building Blockchain in Go. Part 1: Basic Prototype

16 Aug 2017

> Chinese translations: [by liuchengxu](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-1/basic-prototype.md), [by zhangli1](https://zhangli1.gitbooks.io/dummies-for-blockchain/content/).
> ä¸­æ–‡ç¿»è¯‘ï¼šåˆ˜æˆæ—­ã€å¼ è‰1ã€‚

### Introduction å¯¼è¨€

Blockchain is one of the most revolutionary technologies of the 21st century, which is still maturing and which potential is not fully realized yet. In its essence, blockchain is just a distributed database of records. But what makes it unique is that itâ€™s not a private database, but a public one, i.e. everyone who uses it has a full or partial copy of it. And a new record can be added only with a consent of other keepers of the database. Also, itâ€™s blockchain that made cryptocurrencies and smart contracts possible.
åŒºå—é“¾æ˜¯ 21 ä¸–çºªæœ€å…·é©å‘½æ€§çš„æŠ€æœ¯ä¹‹ä¸€ï¼Œç›®å‰ä»å¤„äºæˆç†ŸæœŸï¼Œå…¶æ½œåŠ›å°šæœªå®Œå…¨å‘æŒ¥å‡ºæ¥ã€‚ä»æœ¬è´¨ä¸Šè®²ï¼ŒåŒºå—é“¾åªæ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼è®°å½•æ•°æ®åº“ã€‚ä½†å®ƒçš„ç‹¬ç‰¹ä¹‹å¤„åœ¨äºï¼Œå®ƒä¸æ˜¯ä¸€ä¸ªç§äººæ•°æ®åº“ï¼Œè€Œæ˜¯ä¸€ä¸ªå…¬å…±æ•°æ®åº“ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯ä¸ªä½¿ç”¨å®ƒçš„äººéƒ½æœ‰ä¸€ä¸ªå®Œæ•´æˆ–éƒ¨åˆ†å‰¯æœ¬ã€‚åªæœ‰è·å¾—æ•°æ®åº“å…¶ä»–ä¿å­˜è€…çš„åŒæ„ï¼Œæ‰èƒ½æ·»åŠ æ–°çš„è®°å½•ã€‚æ­¤å¤–ï¼Œæ­£æ˜¯åŒºå—é“¾è®©åŠ å¯†è´§å¸å’Œæ™ºèƒ½åˆçº¦æˆä¸ºå¯èƒ½ã€‚

In this series of articles weâ€™ll build a simplified cryptocurrency thatâ€™s based on a simple blockchain implementation.
åœ¨æœ¬ç³»åˆ—æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ„å»ºä¸€ç§åŸºäºç®€å•åŒºå—é“¾å®ç°çš„ç®€åŒ–åŠ å¯†è´§å¸ã€‚

### Block åŒºå—

Letâ€™s start with the â€œblockâ€ part of â€œblockchainâ€. In blockchain itâ€™s blocks that store valuable information. For example, bitcoin blocks store transactions, the essence of any cryptocurrency. Besides this, a block contains some technical information, like its version, current timestamp and the hash of the previous block.
è®©æˆ‘ä»¬ä» "åŒºå—é“¾ "çš„ "å— "å¼€å§‹ã€‚åœ¨åŒºå—é“¾ä¸­ï¼ŒåŒºå—å­˜å‚¨æœ‰ä»·å€¼çš„ä¿¡æ¯ã€‚ä¾‹å¦‚ï¼Œæ¯”ç‰¹å¸åŒºå—å­˜å‚¨äº¤æ˜“ï¼Œè¿™æ˜¯ä»»ä½•åŠ å¯†è´§å¸çš„æœ¬è´¨ã€‚é™¤æ­¤ä¹‹å¤–ï¼ŒåŒºå—è¿˜åŒ…å«ä¸€äº›æŠ€æœ¯ä¿¡æ¯ï¼Œå¦‚ç‰ˆæœ¬ã€å½“å‰æ—¶é—´æˆ³å’Œä¸Šä¸€ä¸ªåŒºå—çš„å“ˆå¸Œå€¼ã€‚
In this article weâ€™re not going to implement the block as itâ€™s described in blockchain or Bitcoin specifications, instead weâ€™ll use a simplified version of it, which contains only significant information. Hereâ€™s what it looks like:
åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬ä¸ä¼šæŒ‰ç…§åŒºå—é“¾æˆ–æ¯”ç‰¹å¸è§„èŒƒä¸­çš„æè¿°æ¥å®ç°åŒºå—ï¼Œè€Œæ˜¯ä½¿ç”¨ç®€åŒ–ç‰ˆçš„åŒºå—ï¼Œå…¶ä¸­åªåŒ…å«é‡è¦ä¿¡æ¯ã€‚ä¸‹é¢å°±æ˜¯å®ƒçš„æ ·å­ï¼š

```go
type Block struct {
	Timestamp     int64
	Data          []byte
	PrevBlockHash []byte
	Hash          []byte
}
Timestamp` is the current timestamp (when the block is created), `Data` is the actual valuable information containing in the block, `PrevBlockHash` stores the hash of the previous block, and `Hash` is the hash of the block. In Bitcoint specification `Timestamp`, `PrevBlockHash`, and `Hash` are block headers, which form a separate data structure, and transactions (`Data` in our case) is a separate data structure. So weâ€™re mixing them here for simplicity.
`Timestamp` æ˜¯å½“å‰æ—¶é—´æˆ³ï¼ˆåŒºå—åˆ›å»ºæ—¶ï¼‰ï¼Œ æ˜¯åŒºå—ä¸­åŒ…å«çš„å®é™…æœ‰ä»·å€¼ä¿¡æ¯ï¼Œ å­˜å‚¨ä¸Šä¸€ä¸ªåŒºå—çš„å“ˆå¸Œå€¼ï¼Œ æ˜¯åŒºå—çš„å“ˆå¸Œå€¼ã€‚åœ¨ Bitcoint è§„èŒƒä¸­ï¼Œ ã€ å’Œ æ˜¯åŒºå—å¤´ï¼Œå®ƒä»¬æ„æˆä¸€ä¸ªç‹¬ç«‹çš„æ•°æ®ç»“æ„ï¼Œè€Œäº‹åŠ¡ï¼ˆåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ä¸º ï¼‰æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„æ•°æ®ç»“æ„ã€‚å› æ­¤ï¼Œä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å°†å®ƒä»¬æ··åˆåœ¨ä¸€èµ·ã€‚ `Data` `PrevBlockHash` `Hash` `Timestamp` `PrevBlockHash` `Hash` `Data
```

So how do we calculate the hashes? The way hashes are calculates is very important feature of blockchain, and itâ€™s this feature that makes blockchain secure. The thing is that calculating a hash is a computationally difficult operation, it takes some time even on fast computers (thatâ€™s why people buy powerful GPUs to mine Bitcoin). This is an intentional architectural design, which makes adding new blocks difficult, thus preventing their modification after theyâ€™re added. Weâ€™ll discuss and implement this mechanism in a future article.
é‚£ä¹ˆï¼Œæˆ‘ä»¬å¦‚ä½•è®¡ç®—å“ˆå¸Œå€¼å‘¢ï¼Ÿå“ˆå¸Œå€¼çš„è®¡ç®—æ–¹å¼æ˜¯åŒºå—é“¾éå¸¸é‡è¦çš„ç‰¹å¾ï¼Œæ­£æ˜¯è¿™ä¸€ç‰¹å¾ä½¿å¾—åŒºå—é“¾å˜å¾—å®‰å…¨ã€‚é—®é¢˜æ˜¯ï¼Œè®¡ç®—å“ˆå¸Œå€¼æ˜¯ä¸€é¡¹è®¡ç®—éš¾åº¦å¾ˆå¤§çš„æ“ä½œï¼Œå³ä½¿æ˜¯åœ¨é€Ÿåº¦å¾ˆå¿«çš„è®¡ç®—æœºä¸Šä¹Ÿéœ€è¦ä¸€äº›æ—¶é—´ï¼ˆè¿™å°±æ˜¯ä¸ºä»€ä¹ˆäººä»¬è¦è´­ä¹°å¼ºå¤§çš„ GPU æ¥æŒ–æ˜æ¯”ç‰¹å¸ï¼‰ã€‚è¿™æ˜¯ä¸€ç§æœ‰æ„çš„æ¶æ„è®¾è®¡ï¼Œå®ƒä½¿å¾—æ·»åŠ æ–°åŒºå—å˜å¾—å›°éš¾ï¼Œä»è€Œé˜²æ­¢åŒºå—æ·»åŠ åè¢«ä¿®æ”¹ã€‚æˆ‘ä»¬å°†åœ¨ä»¥åçš„æ–‡ç« ä¸­è®¨è®ºå¹¶å®ç°è¿™ä¸€æœºåˆ¶ã€‚

For now, weâ€™ll just take block fields, concatenate them, and calculate a SHA-256 hash on the concatenated combination. Letâ€™s do this in `SetHash` method:
ç°åœ¨ï¼Œæˆ‘ä»¬åªéœ€è·å–å—å­—æ®µï¼Œå°†å®ƒä»¬è¿æ¥èµ·æ¥ï¼Œç„¶åè®¡ç®—è¿æ¥ç»„åˆçš„ SHA-256 å“ˆå¸Œå€¼ã€‚è®©æˆ‘ä»¬åœ¨ `SetHash` æ–¹æ³•ä¸­å®Œæˆè¿™é¡¹å·¥ä½œï¼š

```go
func (b *Block) SetHash() {
	timestamp := []byte(strconv.FormatInt(b.Timestamp, 10))
	headers := bytes.Join([][]byte{b.PrevBlockHash, b.Data, timestamp}, []byte{})
	hash := sha256.Sum256(headers)

	b.Hash = hash[:]
}
```

Next, following a Golang convention, weâ€™ll implement a function thatâ€™ll simplify the creation of a block:
æ¥ä¸‹æ¥ï¼ŒæŒ‰ç…§ Golang çš„æƒ¯ä¾‹ï¼Œæˆ‘ä»¬å°†å®ç°ä¸€ä¸ªå‡½æ•°æ¥ç®€åŒ–ç¨‹åºå—çš„åˆ›å»ºï¼š

```go
func NewBlock(data string, prevBlockHash []byte) *Block {
	block := &Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}}
	block.SetHash()
	return block
}
```

And thatâ€™s it for the block!
è¿™ä¸ªè¡—åŒºå°±è¿™æ ·äº†ï¼

### Blockchain åŒºå—é“¾

Now letâ€™s implement a blockchain. In its essence blockchain is just a database with certain structure: itâ€™s an ordered, back-linked list. Which means that blocks are stored in the insertion order and that each block is linked to the previous one. This structure allows to quickly get the latest block in a chain and to (efficiently) get a block by its hash.
ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥å®ç°åŒºå—é“¾ã€‚ä»æœ¬è´¨ä¸Šè®²ï¼ŒåŒºå—é“¾åªæ˜¯ä¸€ä¸ªå…·æœ‰ç‰¹å®šç»“æ„çš„æ•°æ®åº“ï¼šå®ƒæ˜¯ä¸€ä¸ªæœ‰åºã€åå‘é“¾æ¥çš„åˆ—è¡¨ã€‚è¿™æ„å‘³ç€åŒºå—æŒ‰ç…§æ’å…¥é¡ºåºå­˜å‚¨ï¼Œæ¯ä¸ªåŒºå—éƒ½ä¸å‰ä¸€ä¸ªåŒºå—é“¾æ¥ã€‚è¿™ç§ç»“æ„å¯ä»¥å¿«é€Ÿè·å–é“¾ä¸­çš„æœ€æ–°åŒºå—ï¼Œå¹¶é€šè¿‡åŒºå—çš„å“ˆå¸Œå€¼ï¼ˆæœ‰æ•ˆï¼‰è·å–åŒºå—ã€‚

In Golang this structure can be implemented by using an array and a map: the array would keep ordered hashes (arrays are ordered in Go), and the map would keep `hash â†’ block` pairs (maps are unordered). But for our blockchain prototype weâ€™ll just use an array, because we donâ€™t need to get blocks by their hash for now.
åœ¨ Golang ä¸­ï¼Œè¿™ç§ç»“æ„å¯ä»¥é€šè¿‡ä½¿ç”¨æ•°ç»„å’Œæ˜ å°„æ¥å®ç°ï¼šæ•°ç»„å°†ä¿å­˜æœ‰åºçš„å“ˆå¸Œå€¼ï¼ˆåœ¨ Go ä¸­æ•°ç»„æ˜¯æœ‰åºçš„ï¼‰ï¼Œæ˜ å°„å°†ä¿å­˜ `hash â†’ block` å¯¹ï¼ˆæ˜ å°„æ˜¯æ— åºçš„ï¼‰ã€‚ä½†å¯¹äºæˆ‘ä»¬çš„åŒºå—é“¾åŸå‹ï¼Œæˆ‘ä»¬å°†åªä½¿ç”¨æ•°ç»„ï¼Œå› ä¸ºæˆ‘ä»¬æš‚æ—¶ä¸éœ€è¦é€šè¿‡å“ˆå¸Œå€¼æ¥è·å–åŒºå—ã€‚

```go
type Blockchain struct {
	blocks []*Block
}
```

This is our first blockchain! Iâ€™ve never thought it would be so easy ğŸ˜‰
è¿™æ˜¯æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªåŒºå—é“¾ï¼æˆ‘ä»æœªæƒ³è¿‡å®ƒä¼šå¦‚æ­¤ç®€å• ğŸ˜‰

Now letâ€™s make it possible to add blocks to it:
ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä¸ºå®ƒæ·»åŠ åŒºå—å§ï¼š

```go
func (bc *Blockchain) AddBlock(data string) {
	prevBlock := bc.blocks[len(bc.blocks)-1]
	newBlock := NewBlock(data, prevBlock.Hash)
	bc.blocks = append(bc.blocks, newBlock)
}
```

Thatâ€™s it! Or not?..
å°±æ˜¯è¿™æ ·ï¼è¿˜æ˜¯æ²¡æœ‰ï¼Ÿ

To add a new block we need an existing block, but thereâ€™re not blocks in our blockchain! So, in any blockchain, there must be at least one block, and such block, the first in the chain, is called **genesis block**. Letâ€™s implement a method that creates such a block:
è¦æ·»åŠ ä¸€ä¸ªæ–°åŒºå—ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªç°æœ‰çš„åŒºå—ï¼Œä½†æˆ‘ä»¬çš„åŒºå—é“¾ä¸­æ²¡æœ‰åŒºå—ï¼å› æ­¤ï¼Œåœ¨ä»»ä½•åŒºå—é“¾ä¸­ï¼Œéƒ½å¿…é¡»è‡³å°‘æœ‰ä¸€ä¸ªåŒºå—ï¼Œè¿™æ ·çš„åŒºå—ï¼Œä¹Ÿå°±æ˜¯é“¾ä¸­çš„ç¬¬ä¸€ä¸ªåŒºå—ï¼Œè¢«ç§°ä¸ºåˆ›ä¸–åŒºå—ã€‚è®©æˆ‘ä»¬æ¥å®ç°ä¸€ä¸ªåˆ›å»ºåˆ›ä¸–åŒºå—çš„æ–¹æ³•ï¼š

```go
func NewGenesisBlock() *Block {
	return NewBlock("Genesis Block", []byte{})
}
```

Now, we can implement a function that creates a blockchain with the genesis block:
ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨åˆ›ä¸–åŒºå—åˆ›å»ºä¸€ä¸ªåŒºå—é“¾ï¼š

```go
func NewBlockchain() *Blockchain {
	return &Blockchain{[]*Block{NewGenesisBlock()}}
}
```

Letâ€™s check that the blockchain works correctly:
è®©æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸‹åŒºå—é“¾æ˜¯å¦æ­£å¸¸è¿è¡Œï¼š

```go
func main() {
	bc := NewBlockchain()

	bc.AddBlock("Send 1 BTC to Ivan")
	bc.AddBlock("Send 2 more BTC to Ivan")

	for _, block := range bc.blocks {
		fmt.Printf("Prev. hash: %x\n", block.PrevBlockHash)
		fmt.Printf("Data: %s\n", block.Data)
		fmt.Printf("Hash: %x\n", block.Hash)
		fmt.Println()
	}
}
```

Output: è¾“å‡ºï¼š

```
Prev. hash:
Data: Genesis Block
Hash: aff955a50dc6cd2abfe81b8849eab15f99ed1dc333d38487024223b5fe0f1168

Prev. hash: aff955a50dc6cd2abfe81b8849eab15f99ed1dc333d38487024223b5fe0f1168
Data: Send 1 BTC to Ivan
Hash: d75ce22a840abb9b4e8fc3b60767c4ba3f46a0432d3ea15b71aef9fde6a314e1

Prev. hash: d75ce22a840abb9b4e8fc3b60767c4ba3f46a0432d3ea15b71aef9fde6a314e1
Data: Send 2 more BTC to Ivan
Hash: 561237522bb7fcfbccbc6fe0e98bbbde7427ffe01c6fb223f7562288ca2295d1
```

Thatâ€™s it! å°±æ˜¯è¿™æ ·ï¼

### Conclusion ç»“è®º

We built a very simple blockchain prototype: itâ€™s just an array of blocks, with each block having a connection to the previous one. The actual blockchain is much more complex though. In our blockchain adding new blocks is easy and fast, but in real blockchain adding new blocks requires some work: one has to perform some heavy computations before getting a permission to add block (this mechanism is called Proof-of-Work). Also, blockchain is a distributed database that has no single decision maker. Thus, a new block must be confirmed and approved by other participants of the network (this mechanism is called consensus). And thereâ€™re no transactions in our blockchain yet!
æˆ‘ä»¬æ„å»ºäº†ä¸€ä¸ªéå¸¸ç®€å•çš„åŒºå—é“¾åŸå‹ï¼šå®ƒåªæ˜¯ä¸€ä¸ªåŒºå—æ•°ç»„ï¼Œæ¯ä¸ªåŒºå—éƒ½ä¸å‰ä¸€ä¸ªåŒºå—æœ‰å…³è”ã€‚ä½†å®é™…çš„åŒºå—é“¾è¦å¤æ‚å¾—å¤šã€‚åœ¨æˆ‘ä»¬çš„åŒºå—é“¾ä¸­ï¼Œæ·»åŠ æ–°åŒºå—æ—¢ç®€å•åˆå¿«é€Ÿï¼Œä½†åœ¨çœŸæ­£çš„åŒºå—é“¾ä¸­ï¼Œæ·»åŠ æ–°åŒºå—éœ€è¦åšä¸€äº›å·¥ä½œï¼šåœ¨è·å¾—æ·»åŠ åŒºå—çš„è®¸å¯ä¹‹å‰ï¼Œå¿…é¡»æ‰§è¡Œä¸€äº›ç¹é‡çš„è®¡ç®—ï¼ˆè¿™ç§æœºåˆ¶ç§°ä¸ºå·¥ä½œè¯æ˜ï¼‰ã€‚æ­¤å¤–ï¼ŒåŒºå—é“¾æ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼æ•°æ®åº“ï¼Œæ²¡æœ‰å•ä¸€çš„å†³ç­–è€…ã€‚å› æ­¤ï¼Œæ–°åŒºå—å¿…é¡»å¾—åˆ°ç½‘ç»œå…¶ä»–å‚ä¸è€…çš„ç¡®è®¤å’Œæ‰¹å‡†ï¼ˆè¿™ç§æœºåˆ¶ç§°ä¸ºå…±è¯†ï¼‰ã€‚æˆ‘ä»¬çš„åŒºå—é“¾ä¸­è¿˜æ²¡æœ‰äº¤æ˜“ï¼

In future articles weâ€™ll cover each of these features.
åœ¨ä»Šåçš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†é€ä¸€ä»‹ç»è¿™äº›åŠŸèƒ½ã€‚

------

Links: é“¾æ¥

1. Full source codes: https://github.com/Jeiwan/blockchain_go/tree/part_1
   å®Œæ•´æºä»£ç ï¼š https://github.com/Jeiwan/blockchain_go/tree/part_1
2. Block hashing algorithm: https://en.bitcoin.it/wiki/Block_hashing_algorithm
   å—æ•£åˆ—ç®—æ³•ï¼š https://en.bitcoin.it/wiki/Block_hashing_algorithm

## Building Blockchain in Go. Part 2: Proof-of-Work

22 Aug 2017

> Chinese translations: [by liuchengxu](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-2/proof-of-work.md), [by zhangli1](https://zhangli1.gitbooks.io/dummies-for-blockchain/content/).
> ä¸­æ–‡ç¿»è¯‘ï¼šåˆ˜æˆæ—­ã€å¼ è‰1ã€‚

### Introduction å¯¼è¨€

In [the previous article](https://jeiwan.net/posts/building-blockchain-in-go-part-1/) we built a very simple data structure, which is the essence of blockchain database. And we made it possible to add blocks to it with the chain-like relation between them: each block is linked to the previous one. Alas, our blockchain implementation has one significant flaw: adding blocks to the chain is easy and cheap. One of the keystones of blockchain and Bitcoin is that adding new blocks is a hard work. Today weâ€™re going to fix this flaw.
åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬æ„å»ºäº†ä¸€ä¸ªéå¸¸ç®€å•çš„æ•°æ®ç»“æ„ï¼Œå®ƒæ˜¯åŒºå—é“¾æ•°æ®åº“çš„ç²¾é«“ã€‚æˆ‘ä»¬è¿˜ä½¿åŒºå—ä¹‹é—´çš„é“¾å¼å…³ç³»æˆä¸ºå¯èƒ½ï¼šæ¯ä¸ªåŒºå—éƒ½ä¸å‰ä¸€ä¸ªåŒºå—ç›¸å…³è”ã€‚å¯æƒœï¼Œæˆ‘ä»¬çš„åŒºå—é“¾å®ç°æœ‰ä¸€ä¸ªé‡å¤§ç¼ºé™·ï¼šå‘é“¾ä¸Šæ·»åŠ åŒºå—æ—¢ç®€å•åˆä¾¿å®œã€‚åŒºå—é“¾å’Œæ¯”ç‰¹å¸çš„åŸºçŸ³ä¹‹ä¸€å°±æ˜¯æ·»åŠ æ–°åŒºå—æ˜¯ä¸€é¡¹è‰°è‹¦çš„å·¥ä½œã€‚ä»Šå¤©ï¼Œæˆ‘ä»¬è¦å¼¥è¡¥è¿™ä¸ªç¼ºé™·ã€‚

### Proof-of-Work å·¥ä½œè¯æ˜

A key idea of blockchain is that one has to perform some hard work to put data in it. It is this hard work that makes blockchain secure and consistent. Also, a reward is paid for this hard work (this is how people get coins for mining).
åŒºå—é“¾çš„ä¸€ä¸ªå…³é”®ç†å¿µæ˜¯ï¼Œäººä»¬å¿…é¡»è¿›è¡Œä¸€äº›è‰°è‹¦çš„å·¥ä½œæ‰èƒ½å°†æ•°æ®å­˜å…¥åŒºå—é“¾ã€‚æ­£æ˜¯è¿™ç§è‰°è‹¦çš„å·¥ä½œä½¿å¾—åŒºå—é“¾å…·æœ‰å®‰å…¨æ€§å’Œä¸€è‡´æ€§ã€‚åŒæ—¶ï¼Œè¿™ç§è‰°è‹¦çš„å·¥ä½œä¹Ÿä¼šå¾—åˆ°å›æŠ¥ï¼ˆè¿™å°±æ˜¯äººä»¬æŒ–çŸ¿è·å¾—é‡‘å¸çš„æ–¹å¼ï¼‰ã€‚

This mechanism is very similar to the one from real life: one has to work hard to get a reward and to sustain their life. In blockchain, some participants (miners) of the network work to sustain the network, to add new blocks to it, and get a reward for their work. As a result of their work, a block is incorporated into the blockchain in a secure way, which maintains the stability of the whole blockchain database. Itâ€™s worth noting that, the one who finished the work has to prove this.
è¿™ç§æœºåˆ¶ä¸ç°å®ç”Ÿæ´»ä¸­çš„æœºåˆ¶éå¸¸ç›¸ä¼¼ï¼šäººä»¬å¿…é¡»åŠªåŠ›å·¥ä½œï¼Œæ‰èƒ½è·å¾—å›æŠ¥ï¼Œç»´æŒç”Ÿæ´»ã€‚åœ¨åŒºå—é“¾ä¸­ï¼Œç½‘ç»œçš„ä¸€äº›å‚ä¸è€…ï¼ˆçŸ¿å·¥ï¼‰åŠªåŠ›ç»´æŒç½‘ç»œï¼Œä¸ºç½‘ç»œæ·»åŠ æ–°çš„åŒºå—ï¼Œå¹¶ä»ä»–ä»¬çš„å·¥ä½œä¸­è·å¾—å›æŠ¥ã€‚ç”±äºä»–ä»¬çš„å·¥ä½œï¼Œä¸€ä¸ªåŒºå—ä»¥å®‰å…¨çš„æ–¹å¼è¢«çº³å…¥åŒºå—é“¾ï¼Œä»è€Œä¿æŒäº†æ•´ä¸ªåŒºå—é“¾æ•°æ®åº“çš„ç¨³å®šæ€§ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå®Œæˆå·¥ä½œçš„äººå¿…é¡»è¯æ˜è¿™ä¸€ç‚¹ã€‚

This whole â€œdo hard work and proveâ€ mechanism is called proof-of-work. Itâ€™s hard because it requires a lot of computational power: even high performance computers cannot do it quickly. Moreover, the difficulty of this work increases from time to time to keep new blocks rate at about 6 blocks per hour. In Bitcoin, the goal of such work is to find a hash for a block, that meets some requirements. And itâ€™s this hash that serves as a proof. Thus, finding a proof is the actual work.
è¿™ç§ "åšè‰°è‹¦çš„å·¥ä½œå¹¶è¯æ˜ "çš„æœºåˆ¶è¢«ç§°ä¸ºå·¥ä½œé‡è¯æ˜ï¼ˆproof-of-workï¼‰ã€‚è¯´å®ƒéš¾ï¼Œæ˜¯å› ä¸ºå®ƒéœ€è¦å¤§é‡çš„è®¡ç®—èƒ½åŠ›ï¼šå³ä½¿æ˜¯é«˜æ€§èƒ½è®¡ç®—æœºä¹Ÿæ— æ³•å¿«é€Ÿå®Œæˆã€‚æ­¤å¤–ï¼Œè¿™é¡¹å·¥ä½œçš„éš¾åº¦ä¼šä¸æ—¶å¢åŠ ï¼Œä»¥ä¿æŒæ¯å°æ—¶å¤§çº¦ 6 ä¸ªæ–°åŒºå—çš„é€Ÿåº¦ã€‚åœ¨æ¯”ç‰¹å¸ä¸­ï¼Œè¿™é¡¹å·¥ä½œçš„ç›®æ ‡æ˜¯ä¸ºä¸€ä¸ªåŒºå—æ‰¾åˆ°ç¬¦åˆæŸäº›è¦æ±‚çš„å“ˆå¸Œå€¼ã€‚è¿™ä¸ªå“ˆå¸Œå€¼å°±æ˜¯è¯æ˜ã€‚å› æ­¤ï¼Œæ‰¾åˆ°è¯æ˜æ‰æ˜¯çœŸæ­£çš„å·¥ä½œã€‚

One last thing to note. Proof-of-Work algorithms must meet a requirement: doing the work is hard, but verifying the proof is easy. A proof is usually handed to someone else, so for them, it shouldnâ€™t take much time to verify it.
æœ€åä¸€ç‚¹éœ€è¦æ³¨æ„ã€‚å·¥ä½œè¯æ˜ç®—æ³•å¿…é¡»æ»¡è¶³ä¸€ä¸ªè¦æ±‚ï¼šåšå·¥ä½œå¾ˆéš¾ï¼Œä½†éªŒè¯è¯æ˜å¾ˆå®¹æ˜“ã€‚è¯æ˜é€šå¸¸æ˜¯äº¤ç»™åˆ«äººçš„ï¼Œå› æ­¤å¯¹ä»–ä»¬æ¥è¯´ï¼ŒéªŒè¯å®ƒä¸åº”è¯¥èŠ±è´¹å¤ªå¤šæ—¶é—´ã€‚

### Hashing æ•£åˆ—

In this paragraph, weâ€™ll discuss hashing. If youâ€™re familiar with the concept, you can skip this part.
åœ¨æœ¬æ®µä¸­ï¼Œæˆ‘ä»¬å°†è®¨è®ºæ•£åˆ—ã€‚å¦‚æœä½ ç†Ÿæ‚‰è¿™ä¸ªæ¦‚å¿µï¼Œå¯ä»¥è·³è¿‡è¿™ä¸€éƒ¨åˆ†ã€‚

Hashing is a process of obtaining a hash for specified data. A hash is a unique representation of the data it was calculated on. A hash function is a function that takes data of arbitrary size and produces a fixed size hash. Here are some key features of hashing:
æ•£åˆ—æ˜¯ä¸ºæŒ‡å®šæ•°æ®è·å–æ•£åˆ—å€¼çš„è¿‡ç¨‹ã€‚æ•£åˆ—æ˜¯è®¡ç®—æ•°æ®çš„å”¯ä¸€è¡¨ç¤ºã€‚æ•£åˆ—å‡½æ•°æ˜¯ä¸€ç§å¯ä»¥è·å–ä»»æ„å¤§å°æ•°æ®å¹¶ç”Ÿæˆå›ºå®šå¤§å°æ•£åˆ—çš„å‡½æ•°ã€‚ä¸‹é¢æ˜¯æ•£åˆ—çš„ä¸€äº›ä¸»è¦ç‰¹å¾ï¼š

1. Original data cannot be restored from a hash. Thus, hashing is not encryption.
   åŸå§‹æ•°æ®æ— æ³•ä»æ•£åˆ—å€¼ä¸­è¿˜åŸã€‚å› æ­¤ï¼Œæ•£åˆ—ä¸æ˜¯åŠ å¯†ã€‚
2. Certain data can have only one hash and the hash is unique.
   æŸäº›æ•°æ®åªèƒ½æœ‰ä¸€ä¸ªå“ˆå¸Œå€¼ï¼Œè€Œä¸”è¯¥å“ˆå¸Œå€¼æ˜¯å”¯ä¸€çš„ã€‚
3. Changing even one byte in the input data will result in a completely different hash.
   å“ªæ€•æ˜¯æ”¹å˜è¾“å…¥æ•°æ®ä¸­çš„ä¸€ä¸ªå­—èŠ‚ï¼Œéƒ½ä¼šäº§ç”Ÿå®Œå…¨ä¸åŒçš„å“ˆå¸Œå€¼ã€‚

![Hashing example](https://jeiwan.net/images/hashing-example.png)

Hashing functions are widely used to check the consistency of data. Some software providers publish checksums in addition to a software package. After downloading a file you can feed it to a hashing function and compare produced hash with the one provided by the software developer.
æ•£åˆ—å‡½æ•°è¢«å¹¿æ³›ç”¨äºæ£€æŸ¥æ•°æ®çš„ä¸€è‡´æ€§ã€‚ä¸€äº›è½¯ä»¶æä¾›å•†ä¼šåœ¨è½¯ä»¶åŒ…ä¸­å‘å¸ƒæ ¡éªŒå’Œã€‚ä¸‹è½½æ–‡ä»¶åï¼Œæ‚¨å¯ä»¥å°†å…¶è¾“å…¥æ•£åˆ—å‡½æ•°ï¼Œç„¶åå°†äº§ç”Ÿçš„æ•£åˆ—ä¸è½¯ä»¶å¼€å‘å•†æä¾›çš„æ•£åˆ—è¿›è¡Œæ¯”è¾ƒã€‚

In blockchain, hashing is used to guarantee the consistency of a block. The input data for a hashing algorithm contains the hash of the previous block, thus making it impossible (or, at least, quite difficult) to modify a block in the chain: one has to recalculate its hash and hashes of all the blocks after it.
åœ¨åŒºå—é“¾ä¸­ï¼Œå“ˆå¸Œç®—æ³•ç”¨äºä¿è¯åŒºå—çš„ä¸€è‡´æ€§ã€‚å“ˆå¸Œç®—æ³•çš„è¾“å…¥æ•°æ®åŒ…å«å‰ä¸€ä¸ªåŒºå—çš„å“ˆå¸Œå€¼ï¼Œå› æ­¤ä¸å¯èƒ½ï¼ˆæˆ–è‡³å°‘ç›¸å½“å›°éš¾ï¼‰ä¿®æ”¹é“¾ä¸­çš„ä¸€ä¸ªåŒºå—ï¼šå¿…é¡»é‡æ–°è®¡ç®—å…¶å“ˆå¸Œå€¼å’Œå…¶åæ‰€æœ‰åŒºå—çš„å“ˆå¸Œå€¼ã€‚

### Hashcash å“ˆå¸Œç°é‡‘

Bitcoin uses [Hashcash](https://en.wikipedia.org/wiki/Hashcash), a Proof-of-Work algorithm that was initially developed to prevent email spam. It can be split into the following steps:
æ¯”ç‰¹å¸ä½¿ç”¨å“ˆå¸Œç°é‡‘ï¼Œè¿™æ˜¯ä¸€ç§å·¥ä½œè¯æ˜ç®—æ³•ï¼Œæœ€åˆæ˜¯ä¸ºäº†é˜²æ­¢åƒåœ¾é‚®ä»¶è€Œå¼€å‘çš„ã€‚å®ƒå¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š

1. Take some publicly known data (in case of email, itâ€™s receiverâ€™s email address; in case of Bitcoin, itâ€™s block headers).
   è·å–ä¸€äº›å…¬å¼€çš„æ•°æ®ï¼ˆå¦‚æœæ˜¯ç”µå­é‚®ä»¶ï¼Œåˆ™æ˜¯æ¥æ”¶è€…çš„ç”µå­é‚®ä»¶åœ°å€ï¼›å¦‚æœæ˜¯æ¯”ç‰¹å¸ï¼Œåˆ™æ˜¯åŒºå—å¤´ä¿¡æ¯ï¼‰ã€‚

2. Add a counter to it. The counter starts at 0.
   æ·»åŠ ä¸€ä¸ªè®¡æ•°å™¨ã€‚è®¡æ•°å™¨ä» 0 å¼€å§‹ã€‚

3. Get a hash of the `data + counter` combination.
   è·å– `data + counter` ç»„åˆçš„å“ˆå¸Œå€¼ã€‚

4. Check that the hash meets certain requirements.

   
   æ£€æŸ¥å“ˆå¸Œå€¼æ˜¯å¦ç¬¦åˆæŸäº›è¦æ±‚ã€‚

   1. If it does, youâ€™re done.
      å¦‚æœæ˜¯è¿™æ ·ï¼Œä½ å°±å®Œäº†ã€‚
   2. If it doesnâ€™t, increase the counter and repeat the steps 3 and 4.
      å¦‚æœæ²¡æœ‰ï¼Œåˆ™å¢åŠ è®¡æ•°å™¨å¹¶é‡å¤æ­¥éª¤ 3 å’Œ 4ã€‚

Thus, this is a brute force algorithm: you change the counter, calculate a new hash, check it, increment the counter, calculate a hash, etc. Thatâ€™s why itâ€™s computationally expensive.
å› æ­¤ï¼Œè¿™æ˜¯ä¸€ç§è›®åŠ›ç®—æ³•ï¼šæ”¹å˜è®¡æ•°å™¨ï¼Œè®¡ç®—æ–°çš„å“ˆå¸Œå€¼ï¼Œæ£€æŸ¥ï¼Œé€’å¢è®¡æ•°å™¨ï¼Œè®¡ç®—å“ˆå¸Œå€¼ï¼Œç­‰ç­‰ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå®ƒçš„è®¡ç®—æˆæœ¬å¾ˆé«˜ã€‚

Now letâ€™s look closer at the requirements a hash has to meet. In the original Hashcash implementation, the requirement sounds like â€œfirst 20 bits of a hash must be zerosâ€. In Bitcoin, the requirement is adjusted from time to time, because, by design, a block must be generated every 10 minutes, despite computation power increasing with time and more and more miners joining the network.
ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä»”ç»†çœ‹çœ‹å“ˆå¸Œå€¼å¿…é¡»æ»¡è¶³çš„è¦æ±‚ã€‚åœ¨æœ€åˆçš„ Hashcash å®ç°ä¸­ï¼Œè¿™ä¸ªè¦æ±‚å¬èµ·æ¥åƒæ˜¯ "å“ˆå¸Œå€¼çš„å‰ 20 ä½å¿…é¡»ä¸ºé›¶"ã€‚åœ¨æ¯”ç‰¹å¸ä¸­ï¼Œè¿™ä¸€è¦æ±‚ä¼šä¸æ—¶è°ƒæ•´ï¼Œå› ä¸ºæ ¹æ®è®¾è®¡ï¼Œå°½ç®¡è®¡ç®—èƒ½åŠ›ä¼šéšç€æ—¶é—´çš„æ¨ç§»è€Œå¢åŠ ï¼Œè€Œä¸”è¶Šæ¥è¶Šå¤šçš„çŸ¿å·¥åŠ å…¥ç½‘ç»œï¼Œä½†æ¯éš” 10 åˆ†é’Ÿå°±å¿…é¡»ç”Ÿæˆä¸€ä¸ªåŒºå—ã€‚

To demonstrate this algorithm, I took the data from the previous example (â€œI like donutsâ€) and found a hash that starts with 3 zero-bytes:
ä¸ºäº†æ¼”ç¤ºè¿™ç§ç®—æ³•ï¼Œæˆ‘ä»ä¸Šä¸€ä¸ªä¾‹å­ï¼ˆ"æˆ‘å–œæ¬¢ç”œç”œåœˆ"ï¼‰ä¸­è·å–æ•°æ®ï¼Œå¹¶æ‰¾åˆ°ä¸€ä¸ªä»¥ 3 ä¸ª 0 å­—èŠ‚å¼€å¤´çš„å“ˆå¸Œå€¼ï¼š

![Hashcash example](https://jeiwan.net/images/hashcash-example.png)

`ca07ca` is the hexadecimal value of the counter, which is 13240266 in the decimal system.
`ca07ca` æ˜¯è®¡æ•°å™¨çš„åå…­è¿›åˆ¶å€¼ï¼Œåè¿›åˆ¶ä¸º 13240266ã€‚

### Implementation å®æ–½æƒ…å†µ

Ok, weâ€™re done with the theory, letâ€™s write code! First, letâ€™s define the difficulty of mining:
å¥½äº†ï¼Œç†è®ºè®²å®Œäº†ï¼Œæˆ‘ä»¬æ¥å†™ä»£ç å§ï¼é¦–å…ˆï¼Œæˆ‘ä»¬æ¥å®šä¹‰é‡‡çŸ¿çš„éš¾åº¦ï¼š

```go
const targetBits = 24
```

In Bitcoin, â€œtarget bitsâ€ is the block header storing the difficulty at which the block was mined. We wonâ€™t implement a target adjusting algorithm, for now, so we can just define the difficulty as a global constant.
åœ¨æ¯”ç‰¹å¸ä¸­ï¼Œ"ç›®æ ‡æ¯”ç‰¹ "æ˜¯æŒ‡å­˜å‚¨åŒºå—å¼€é‡‡éš¾åº¦çš„åŒºå—å¤´ã€‚æˆ‘ä»¬æš‚æ—¶ä¸ä¼šå®æ–½ç›®æ ‡è°ƒæ•´ç®—æ³•ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†éš¾åº¦å®šä¹‰ä¸ºä¸€ä¸ªå…¨å±€å¸¸é‡ã€‚

24 is an arbitrary number, our goal is to have a target that takes less than 256 bits in memory. And we want the difference to be significant enough, but not too big, because the bigger the difference the more difficult itâ€™s to find a proper hash.
24 æ˜¯ä¸€ä¸ªä»»æ„æ•°å­—ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯åœ¨å†…å­˜ä¸­å ç”¨å°‘äº 256 ä½çš„ç›®æ ‡å€¼ã€‚æˆ‘ä»¬å¸Œæœ›å·®å€¼è¶³å¤Ÿå¤§ï¼Œä½†åˆä¸èƒ½å¤ªå¤§ï¼Œå› ä¸ºå·®å€¼è¶Šå¤§ï¼Œæ‰¾åˆ°åˆé€‚çš„å“ˆå¸Œå€¼å°±è¶Šå›°éš¾ã€‚

```go
type ProofOfWork struct {
	block  *Block
	target *big.Int
}

func NewProofOfWork(b *Block) *ProofOfWork {
	target := big.NewInt(1)
	target.Lsh(target, uint(256-targetBits))

	pow := &ProofOfWork{b, target}

	return pow
}
```

Here create `ProofOfWork` structure that holds a pointer to a block and a pointer to a target. â€œtargetâ€ is another name for the requirement described in the previous paragraph. We use a [big](https://golang.org/pkg/math/big/) integer because of the way weâ€™ll compare a hash to the target: weâ€™ll convert a hash to a big integer and check if itâ€™s less than the target.
åœ¨æ­¤åˆ›å»º `ProofOfWork` ç»“æ„ï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ªæŒ‡å‘ä»£ç å—çš„æŒ‡é’ˆå’Œä¸€ä¸ªæŒ‡å‘ç›®æ ‡çš„æŒ‡é’ˆã€‚"ç›®æ ‡ "æ˜¯ä¸Šä¸€æ®µæè¿°çš„éœ€æ±‚çš„å¦ä¸€ä¸ªåç§°ã€‚æˆ‘ä»¬ä½¿ç”¨å¤§æ•´æ•°æ˜¯å› ä¸ºæˆ‘ä»¬å°†å“ˆå¸Œå€¼ä¸ç›®æ ‡å€¼è¿›è¡Œæ¯”è¾ƒçš„æ–¹å¼ï¼šæˆ‘ä»¬å°†å“ˆå¸Œå€¼è½¬æ¢ä¸ºå¤§æ•´æ•°ï¼Œç„¶åæ£€æŸ¥å®ƒæ˜¯å¦å°äºç›®æ ‡å€¼ã€‚

In the `NewProofOfWork` function, we initialize a `big.Int` with the value of 1 and shift it left by `256 - targetBits` bits. `256` is the length of a SHA-256 hash in bits, and itâ€™s SHA-256 hashing algorithm that weâ€™re going to use. The hexadecimal representation of `target` is:
åœ¨ `NewProofOfWork` å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬å°† `big.Int` åˆå§‹åŒ–ä¸º 1ï¼Œç„¶åå°†å…¶å·¦ç§» `256 - targetBits` ä½ã€‚ `256` æ˜¯ SHA-256 å“ˆå¸Œå€¼çš„é•¿åº¦ï¼ˆä½ï¼‰ï¼Œæˆ‘ä»¬è¦ä½¿ç”¨çš„å°±æ˜¯ SHA-256 å“ˆå¸Œç®—æ³•ã€‚ `target` çš„åå…­è¿›åˆ¶è¡¨ç¤ºä¸º

```
0x10000000000000000000000000000000000000000000000000000000000
```

And it occupies 29 bytes in memory. And hereâ€™s its visual comparison with the hashes from the previous examples:
å®ƒå ç”¨å†…å­˜ 29 ä¸ªå­—èŠ‚ã€‚ä¸‹é¢æ˜¯å®ƒä¸å‰é¢ä¾‹å­ä¸­çš„å“ˆå¸Œå€¼çš„ç›´è§‚å¯¹æ¯”ï¼š

```
0fac49161af82ed938add1d8725835cc123a1a87b1b196488360e58d4bfb51e3
0000010000000000000000000000000000000000000000000000000000000000
0000008b0f41ec78bab747864db66bcb9fb89920ee75f43fdaaeb5544f7f76ca
```

The first hash (calculated on â€œI like donutsâ€) is bigger than the target, thus itâ€™s not a valid proof of work. The second hash (calculated on â€œI like donutsca07caâ€) is smaller than the target, thus itâ€™s a valid proof.
ç¬¬ä¸€ä¸ªå“ˆå¸Œå€¼ï¼ˆæ ¹æ® "æˆ‘å–œæ¬¢ç”œç”œåœˆ "è®¡ç®—ï¼‰å¤§äºç›®æ ‡å€¼ï¼Œå› æ­¤ä¸æ˜¯æœ‰æ•ˆçš„å·¥ä½œè¯æ˜ã€‚ç¬¬äºŒä¸ªå“ˆå¸Œå€¼ï¼ˆæ ¹æ® "æˆ‘å–œæ¬¢ç”œç”œåœˆ "è®¡ç®—ï¼‰å°äºç›®æ ‡å€¼ï¼Œå› æ­¤æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„è¯æ˜ã€‚

You can think of a target as the upper boundary of a range: if a number (a hash) is lower than the boundary, itâ€™s valid, and vice versa. Lowering the boundary will result in fewer valid numbers, and thus, more difficult work required to find a valid one.
ä½ å¯ä»¥æŠŠç›®æ ‡è§†ä¸ºä¸€ä¸ªèŒƒå›´çš„ä¸Šè¾¹ç•Œï¼šå¦‚æœä¸€ä¸ªæ•°å­—ï¼ˆå“ˆå¸Œå€¼ï¼‰ä½äºè¾¹ç•Œï¼Œå®ƒå°±æ˜¯æœ‰æ•ˆçš„ï¼Œåä¹‹äº¦ç„¶ã€‚è¾¹ç•Œè¶Šä½ï¼Œæœ‰æ•ˆæ•°å­—è¶Šå°‘ï¼Œå› æ­¤æ‰¾åˆ°æœ‰æ•ˆæ•°å­—çš„éš¾åº¦ä¹Ÿå°±è¶Šå¤§ã€‚

Now, we need the data to hash. Letâ€™s prepare it:
ç°åœ¨ï¼Œæˆ‘ä»¬éœ€è¦æ•£åˆ—æ•°æ®ã€‚è®©æˆ‘ä»¬æ¥å‡†å¤‡ä¸€ä¸‹ï¼š

```go
func (pow *ProofOfWork) prepareData(nonce int) []byte {
	data := bytes.Join(
		[][]byte{
			pow.block.PrevBlockHash,
			pow.block.Data,
			IntToHex(pow.block.Timestamp),
			IntToHex(int64(targetBits)),
			IntToHex(int64(nonce)),
		},
		[]byte{},
	)

	return data
}
```

This piece is straightforward: we just merge block fields with the target and nonce. `nonce` here is the counter from the Hashcash description above, this is a cryptographic term.
`nonce` æ˜¯ä¸Šé¢ Hashcash æè¿°ä¸­çš„è®¡æ•°å™¨ï¼Œè¿™æ˜¯ä¸€ä¸ªåŠ å¯†æœ¯è¯­ã€‚

Ok, all preparations are done, letâ€™s implement the core of the PoW algorithm:
å¥½äº†ï¼Œæ‰€æœ‰å‡†å¤‡å·¥ä½œéƒ½å®Œæˆäº†ï¼Œè®©æˆ‘ä»¬æ¥å®ç° PoW ç®—æ³•çš„æ ¸å¿ƒï¼š

```go
func (pow *ProofOfWork) Run() (int, []byte) {
	var hashInt big.Int
	var hash [32]byte
	nonce := 0

	fmt.Printf("Mining the block containing \"%s\"\n", pow.block.Data)
	for nonce < maxNonce {
		data := pow.prepareData(nonce)
		hash = sha256.Sum256(data)
		fmt.Printf("\r%x", hash)
		hashInt.SetBytes(hash[:])

		if hashInt.Cmp(pow.target) == -1 {
			break
		} else {
			nonce++
		}
	}
	fmt.Print("\n\n")

	return nonce, hash[:]
}
```

First, we initialize variables: `hashInt` is the integer representation of `hash`; `nonce` is the counter. Next, we run an â€œinfiniteâ€ loop: itâ€™s limited by `maxNonce`, which equals to `math.MaxInt64`; this is done to avoid a possible overflow of `nonce`. Although the difficulty of our PoW implementation is too low for the counter to overflow, itâ€™s still better to have this check, just in case.
é¦–å…ˆï¼Œæˆ‘ä»¬å¯¹å˜é‡è¿›è¡Œåˆå§‹åŒ–ï¼š `hashInt` æ˜¯ `hash` çš„æ•´æ•°è¡¨ç¤ºï¼› `nonce` æ˜¯è®¡æ•°å™¨ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è¿è¡Œä¸€ä¸ª "æ— é™ "å¾ªç¯ï¼šå®ƒå— `maxNonce` çš„é™åˆ¶ï¼Œç­‰äº `math.MaxInt64` ï¼›è¿™æ ·åšæ˜¯ä¸ºäº†é¿å… `nonce` å¯èƒ½å‡ºç°çš„æº¢å‡ºã€‚è™½ç„¶æˆ‘ä»¬çš„ PoW å®ç°éš¾åº¦å¾ˆä½ï¼Œè®¡æ•°å™¨ä¸ä¼šæº¢å‡ºï¼Œä½†æœ€å¥½è¿˜æ˜¯è¿›è¡Œè¿™ç§æ£€æŸ¥ï¼Œä»¥é˜²ä¸‡ä¸€ã€‚

In the loop we:
åœ¨å¾ªç¯ä¸­ï¼Œæˆ‘ä»¬

1. Prepare data. å‡†å¤‡æ•°æ®ã€‚
2. Hash it with SHA-256.
   ä½¿ç”¨ SHA-256 å¯¹å…¶è¿›è¡Œæ•£åˆ—ã€‚
3. Convert the hash to a big integer.
   å°†å“ˆå¸Œå€¼è½¬æ¢ä¸ºå¤§æ•´æ•°ã€‚
4. Compare the integer with the target.
   å°†æ•´æ•°ä¸ç›®æ ‡å€¼è¿›è¡Œæ¯”è¾ƒã€‚

As easy as it was explained earlier. Now we can remove the `SetHash` method of `Block` and modify the `NewBlock` function:
å°±åƒå‰é¢è§£é‡Šçš„é‚£æ ·ç®€å•ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥åˆ é™¤ `Block` ä¸­çš„ `SetHash` æ–¹æ³•ï¼Œå¹¶ä¿®æ”¹ `NewBlock` å‡½æ•°ï¼š

```go
func NewBlock(data string, prevBlockHash []byte) *Block {
	block := &Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}, 0}
	pow := NewProofOfWork(block)
	nonce, hash := pow.Run()

	block.Hash = hash[:]
	block.Nonce = nonce

	return block
}
```

Here you can see that `nonce` is saved as a `Block` property. This is necessary because `nonce` is required to verify a proof. The `Block` structure now looks so:
åœ¨è¿™é‡Œï¼Œæ‚¨å¯ä»¥çœ‹åˆ° `nonce` è¢«ä¿å­˜ä¸º `Block` å±æ€§ã€‚è¿™æ˜¯å¿…è¦çš„ï¼Œå› ä¸ºéœ€è¦ `nonce` æ¥éªŒè¯è¯æ˜ã€‚ `Block` ç»“æ„ç°åœ¨çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š

```go
type Block struct {
	Timestamp     int64
	Data          []byte
	PrevBlockHash []byte
	Hash          []byte
	Nonce         int
}
```

Alright! Letâ€™s run the program to see if everything works fine:
å¥½å§ï¼è®©æˆ‘ä»¬è¿è¡Œç¨‹åºï¼Œçœ‹çœ‹æ˜¯å¦ä¸€åˆ‡æ­£å¸¸ï¼š

```
Mining the block containing "Genesis Block"
00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1

Mining the block containing "Send 1 BTC to Ivan"
00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804

Mining the block containing "Send 2 more BTC to Ivan"
000000b33185e927c9a989cc7d5aaaed739c56dad9fd9361dea558b9bfaf5fbe

Prev. hash:
Data: Genesis Block
Hash: 00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1

Prev. hash: 00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1
Data: Send 1 BTC to Ivan
Hash: 00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804

Prev. hash: 00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804
Data: Send 2 more BTC to Ivan
Hash: 000000b33185e927c9a989cc7d5aaaed739c56dad9fd9361dea558b9bfaf5fbe
```

Yay! You can see that every hash now starts with three zero bytes, and it takes some time to get these hashes.
æ˜¯å•Šï¼ä½ å¯ä»¥çœ‹åˆ°ï¼Œç°åœ¨æ¯ä¸ªå“ˆå¸Œå€¼éƒ½ä»¥ä¸‰ä¸ª 0 å­—èŠ‚å¼€å§‹ï¼Œè€Œè·å–è¿™äº›å“ˆå¸Œå€¼éœ€è¦ä¸€äº›æ—¶é—´ã€‚

Thereâ€™s one more thing left to do: letâ€™s make it possible to validate proof of works.
è¿˜æœ‰ä¸€ä»¶äº‹è¦åšï¼šè®©éªŒè¯ä½œå“è¯æ˜æˆä¸ºå¯èƒ½ã€‚

```go
func (pow *ProofOfWork) Validate() bool {
	var hashInt big.Int

	data := pow.prepareData(pow.block.Nonce)
	hash := sha256.Sum256(data)
	hashInt.SetBytes(hash[:])

	isValid := hashInt.Cmp(pow.target) == -1

	return isValid
}
```

And this is where we need the saved nonce.
è¿™å°±æ˜¯æˆ‘ä»¬éœ€è¦å·²ä¿å­˜çš„ nonce çš„åœ°æ–¹ã€‚

Letâ€™s check one more time that everythingâ€™s ok:
è®©æˆ‘ä»¬å†æ£€æŸ¥ä¸€éæ˜¯å¦ä¸€åˆ‡æ­£å¸¸ï¼š

```go
func main() {
	...

	for _, block := range bc.blocks {
		...
		pow := NewProofOfWork(block)
		fmt.Printf("PoW: %s\n", strconv.FormatBool(pow.Validate()))
		fmt.Println()
	}
}
```

Output: è¾“å‡ºï¼š

```
...

Prev. hash:
Data: Genesis Block
Hash: 00000093253acb814afb942e652a84a8f245069a67b5eaa709df8ac612075038
PoW: true

Prev. hash: 00000093253acb814afb942e652a84a8f245069a67b5eaa709df8ac612075038
Data: Send 1 BTC to Ivan
Hash: 0000003eeb3743ee42020e4a15262fd110a72823d804ce8e49643b5fd9d1062b
PoW: true

Prev. hash: 0000003eeb3743ee42020e4a15262fd110a72823d804ce8e49643b5fd9d1062b
Data: Send 2 more BTC to Ivan
Hash: 000000e42afddf57a3daa11b43b2e0923f23e894f96d1f24bfd9b8d2d494c57a
PoW: true
```

### Conclusion ç»“è®º

Our blockchain is a step closer to its actual architecture: adding blocks now requires hard work, thus mining is possible. But it still lacks some crucial features: the blockchain database is not persistent, there are no wallets, addresses, transactions, and thereâ€™s no consensus mechanism. All these things weâ€™ll implement in future articles, and for now, happy mining!
æˆ‘ä»¬çš„åŒºå—é“¾å‘å…¶å®é™…æ¶æ„åˆè¿ˆè¿›äº†ä¸€æ­¥ï¼šç°åœ¨æ·»åŠ åŒºå—éœ€è¦è‰°è‹¦çš„å·¥ä½œï¼Œå› æ­¤æŒ–çŸ¿æ˜¯å¯èƒ½çš„ã€‚ä½†å®ƒä»ç„¶ç¼ºä¹ä¸€äº›å…³é”®åŠŸèƒ½ï¼šåŒºå—é“¾æ•°æ®åº“ä¸æ˜¯æŒä¹…çš„ï¼Œæ²¡æœ‰é’±åŒ…ã€åœ°å€ã€äº¤æ˜“ï¼Œä¹Ÿæ²¡æœ‰å…±è¯†æœºåˆ¶ã€‚æ‰€æœ‰è¿™äº›æˆ‘ä»¬éƒ½å°†åœ¨æœªæ¥çš„æ–‡ç« ä¸­å®ç°ï¼Œç°åœ¨ï¼Œç¥æ‚¨æŒ–çŸ¿æ„‰å¿«ï¼

------

Links: é“¾æ¥

1. [Full source codes å®Œæ•´æºä»£ç ](https://github.com/Jeiwan/blockchain_go/tree/part_2)
2. [Blockchain hashing algorithm
   åŒºå—é“¾æ•£åˆ—ç®—æ³•](https://en.bitcoin.it/wiki/Block_hashing_algorithm)
3. [Proof of work å·¥ä½œè¯æ˜](https://en.bitcoin.it/wiki/Proof_of_work)
4. [Hashcash å“ˆå¸Œç°é‡‘](https://en.bitcoin.it/wiki/Hashcash)



## Building Blockchain in Go. Part 3: Persistence and CLI

29 Aug 2017

> Chinese translations: [by liuchengxu](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-3/persistence-and-cli.md), [by zhangli1](https://zhangli1.gitbooks.io/dummies-for-blockchain/content/).
> ä¸­æ–‡ç¿»è¯‘ï¼šåˆ˜æˆæ—­ã€å¼ è‰1ã€‚

### Introduction å¯¼è¨€

[So](https://jeiwan.net/posts/building-blockchain-in-go-part-1/) [far](https://jeiwan.net/posts/building-blockchain-in-go-part-2/), weâ€™ve built a blockchain with a proof-of-work system, which makes mining possible. Our implementation is getting closer to a fully functional blockchain, but it still lacks some important features. Today will start storing a blockchain in a database, and after that weâ€™ll make a simple command-line interface to perform operations with the blockchain. In its essence, blockchain is a distributed database. Weâ€™re going to omit the â€œdistributedâ€ part for now and focus on the â€œdatabaseâ€ part.
åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»å»ºç«‹äº†ä¸€ä¸ªå¸¦æœ‰å·¥ä½œé‡è¯æ˜ç³»ç»Ÿçš„åŒºå—é“¾ï¼Œè¿™ä½¿å¾—æŒ–çŸ¿æˆä¸ºå¯èƒ½ã€‚æˆ‘ä»¬çš„å®ç°è¶Šæ¥è¶Šæ¥è¿‘ä¸€ä¸ªåŠŸèƒ½é½å…¨çš„åŒºå—é“¾ï¼Œä½†å®ƒä»ç„¶ç¼ºä¹ä¸€äº›é‡è¦åŠŸèƒ½ã€‚ä»Šå¤©æˆ‘ä»¬å°†å¼€å§‹åœ¨æ•°æ®åº“ä¸­å­˜å‚¨åŒºå—é“¾ï¼Œä¹‹åæˆ‘ä»¬å°†åˆ¶ä½œä¸€ä¸ªç®€å•çš„å‘½ä»¤è¡Œç•Œé¢æ¥å¯¹åŒºå—é“¾è¿›è¡Œæ“ä½œã€‚ä»æœ¬è´¨ä¸Šè®²ï¼ŒåŒºå—é“¾æ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼æ•°æ®åº“ã€‚æˆ‘ä»¬æš‚æ—¶çœç•¥ "åˆ†å¸ƒå¼ "è¿™ä¸€éƒ¨åˆ†ï¼Œé‡ç‚¹è®¨è®º "æ•°æ®åº“ "è¿™ä¸€éƒ¨åˆ†ã€‚

### Database Choice æ•°æ®åº“é€‰æ‹©

Currently, thereâ€™s no database in our implementation; instead, we create blocks every time we run the program and store them in memory. We cannot reuse a blockchain, we cannot share it with others, thus we need to store it on the disk.
ç›®å‰ï¼Œæˆ‘ä»¬çš„å®ç°ä¸­æ²¡æœ‰æ•°æ®åº“ï¼›ç›¸åï¼Œæˆ‘ä»¬æ¯æ¬¡è¿è¡Œç¨‹åºæ—¶éƒ½ä¼šåˆ›å»ºåŒºå—ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨å†…å­˜ä¸­ã€‚æˆ‘ä»¬ä¸èƒ½é‡å¤ä½¿ç”¨åŒºå—é“¾ï¼Œä¹Ÿä¸èƒ½ä¸ä»–äººå…±äº«ï¼Œå› æ­¤éœ€è¦å°†å…¶å­˜å‚¨åœ¨ç£ç›˜ä¸Šã€‚

Which database do we need? Actually, any of them. In [the original Bitcoin paper](https://bitcoin.org/bitcoin.pdf), nothing is said about using a certain database, so itâ€™s up to a developer what DB to use. [Bitcoin Core](https://github.com/bitcoin/bitcoin), which was initially published by Satoshi Nakamoto and which is currently a reference implementation of Bitcoin, uses [LevelDB](https://github.com/google/leveldb) (although it was introduced to the client only in 2012). And weâ€™ll useâ€¦
æˆ‘ä»¬éœ€è¦å“ªä¸ªæ•°æ®åº“ï¼Ÿå…¶å®ï¼Œä»»ä½•ä¸€ä¸ªéƒ½å¯ä»¥ã€‚åœ¨æœ€åˆçš„æ¯”ç‰¹å¸è®ºæ–‡ä¸­ï¼Œå¹¶æ²¡æœ‰æåˆ°è¦ä½¿ç”¨æŸç§æ•°æ®åº“ï¼Œæ‰€ä»¥ä½¿ç”¨ä»€ä¹ˆæ•°æ®åº“å–å†³äºå¼€å‘è€…ã€‚æœ€åˆç”±ä¸­æœ¬èªå‘å¸ƒçš„ Bitcoin Core ç›®å‰æ˜¯æ¯”ç‰¹å¸çš„å‚è€ƒå®ç°ï¼Œå®ƒä½¿ç”¨ LevelDBï¼ˆå°½ç®¡å®ƒåœ¨ 2012 å¹´æ‰è¢«å¼•å…¥å®¢æˆ·ç«¯ï¼‰ã€‚æˆ‘ä»¬å°†ä½¿ç”¨...

### BoltDB

Because: å› ä¸º

1. Itâ€™s simple and minimalistic.
   å®ƒç®€å•è€Œç®€çº¦ã€‚
2. Itâ€™s implemented in Go.
   å®ƒæ˜¯ç”¨ Go è¯­è¨€å®ç°çš„ã€‚
3. It doesnâ€™t require to run a server.
   å®ƒä¸éœ€è¦è¿è¡ŒæœåŠ¡å™¨ã€‚
4. It allows to build the data structure we want.
   å®ƒå…è®¸å»ºç«‹æˆ‘ä»¬æƒ³è¦çš„æ•°æ®ç»“æ„ã€‚

From the BoltDBâ€™s [README on Github](https://github.com/boltdb/bolt):
æ‘˜è‡ª Github ä¸Š BoltDB çš„ READMEï¼š

> Bolt is a pure Go key/value store inspired by Howard Chuâ€™s LMDB project. The goal of the project is to provide a simple, fast, and reliable database for projects that donâ€™t require a full database server such as Postgres or MySQL.
> Bolt æ˜¯ä¸€ä¸ªçº¯ Go çš„é”®/å€¼å­˜å‚¨åº“ï¼Œå…¶çµæ„Ÿæ¥è‡ª Howard Chu çš„ LMDB é¡¹ç›®ã€‚è¯¥é¡¹ç›®çš„ç›®æ ‡æ˜¯ä¸ºä¸éœ€è¦ Postgres æˆ– MySQL ç­‰å®Œæ•´æ•°æ®åº“æœåŠ¡å™¨çš„é¡¹ç›®æä¾›ä¸€ä¸ªç®€å•ã€å¿«é€Ÿã€å¯é çš„æ•°æ®åº“ã€‚

> Since Bolt is meant to be used as such a low-level piece of functionality, simplicity is key. The API will be small and only focus on getting values and setting values. Thatâ€™s it.
> ç”±äº Bolt åªæ˜¯ä¸€ä¸ªä½çº§åŠŸèƒ½ï¼Œå› æ­¤ç®€å•æ˜¯å…³é”®ã€‚åº”ç”¨ç¨‹åºæ¥å£ï¼ˆAPIï¼‰å°†éå¸¸å°ï¼Œåªå…³æ³¨è·å–å€¼å’Œè®¾ç½®å€¼ã€‚å°±æ˜¯è¿™æ ·ã€‚

Sounds perfect for our needs! Letâ€™s spend a minute reviewing it.
å¬èµ·æ¥éå¸¸é€‚åˆæˆ‘ä»¬çš„éœ€è¦ï¼è®©æˆ‘ä»¬èŠ±ä¸€åˆ†é’Ÿæ¥å›é¡¾ä¸€ä¸‹ã€‚

BoltDB is a key/value storage, which means thereâ€™re no tables like in SQL RDBMS (MySQL, PostgreSQL, etc.), no rows, no columns. Instead, data is stored as key-value pairs (like in Golang maps). Key-value pairs are stored in buckets, which are intended to group similar pairs (this is similar to tables in RDBMS). Thus, in order to get a value, you need to know a bucket and a key.
BoltDB æ˜¯é”®/å€¼å­˜å‚¨ï¼Œè¿™æ„å‘³ç€æ²¡æœ‰åƒ SQL RDBMSï¼ˆMySQLã€PostgreSQL ç­‰ï¼‰é‚£æ ·çš„è¡¨æ ¼ï¼Œæ²¡æœ‰è¡Œï¼Œä¹Ÿæ²¡æœ‰åˆ—ã€‚ç›¸åï¼Œæ•°æ®æ˜¯ä»¥é”®å€¼å¯¹çš„å½¢å¼å­˜å‚¨çš„ï¼ˆå°±åƒåœ¨ Golang åœ°å›¾ä¸­ä¸€æ ·ï¼‰ã€‚é”®å€¼å¯¹å­˜å‚¨åœ¨æ¡¶ä¸­ï¼Œç›®çš„æ˜¯å°†ç±»ä¼¼çš„é”®å€¼å¯¹åˆ†ç»„ï¼ˆè¿™ä¸ RDBMS ä¸­çš„è¡¨æ ¼ç±»ä¼¼ï¼‰ã€‚å› æ­¤ï¼Œè¦è·å–ä¸€ä¸ªå€¼ï¼Œä½ éœ€è¦çŸ¥é“ä¸€ä¸ªæ¡¶å’Œä¸€ä¸ªé”®ã€‚

One important thing about BoltDB is that there are no data types: keys and values are byte arrays. Since weâ€™ll store Go structs (`Block`, in particular) in it, weâ€™ll need to serialize them, i.e. implement a mechanism of converting a Go struct into a byte array and restoring it back from a byte array. Weâ€™ll use [encoding/gob](https://golang.org/pkg/encoding/gob/) for this, but `JSON`, `XML`, `Protocol Buffers`, etc. can be used as well. Weâ€™re using `encoding/gob` because itâ€™s simple and is a part of the standard Go library.
BoltDB çš„ä¸€ä¸ªé‡è¦ç‰¹ç‚¹æ˜¯æ²¡æœ‰æ•°æ®ç±»å‹ï¼šé”®å’Œå€¼éƒ½æ˜¯å­—èŠ‚æ•°ç»„ã€‚ç”±äºæˆ‘ä»¬å°†åœ¨å…¶ä¸­å­˜å‚¨ Go ç»“æ„ä½“ï¼ˆå°¤å…¶æ˜¯ `Block` ï¼‰ï¼Œå› æ­¤éœ€è¦å¯¹å…¶è¿›è¡Œåºåˆ—åŒ–ï¼Œå³å®ç°ä¸€ç§æœºåˆ¶ï¼Œå°† Go ç»“æ„ä½“è½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„ï¼Œå¹¶ä»å­—èŠ‚æ•°ç»„è¿˜åŸå›æ¥ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ç¼–ç /gobï¼Œä½†ä¹Ÿå¯ä»¥ä½¿ç”¨ `JSON` , `XML` , `Protocol Buffers` ç­‰ã€‚æˆ‘ä»¬ä½¿ç”¨ `encoding/gob` æ˜¯å› ä¸ºå®ƒå¾ˆç®€å•ï¼Œè€Œä¸”æ˜¯æ ‡å‡† Go åº“çš„ä¸€éƒ¨åˆ†ã€‚

### Database Structure æ•°æ®åº“ç»“æ„

Before starting implementing persistence logic, we first need to decide how weâ€™ll store data in the DB. And for this, weâ€™ll refer to the way Bitcoin Core does that.
åœ¨å¼€å§‹å®æ–½æŒä¹…åŒ–é€»è¾‘ä¹‹å‰ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦å†³å®šå¦‚ä½•åœ¨æ•°æ®åº“ä¸­å­˜å‚¨æ•°æ®ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†å‚è€ƒ Bitcoin Core çš„åšæ³•ã€‚

In simple words, Bitcoin Core uses two â€œbucketsâ€ to store data:
ç®€å•åœ°è¯´ï¼ŒBitcoin Core ä½¿ç”¨ä¸¤ä¸ª "æ¡¶ "æ¥å­˜å‚¨æ•°æ®ï¼š

1. `blocks` stores metadata describing all the blocks in a chain.
   `blocks` å­˜å‚¨æè¿°é“¾ä¸­æ‰€æœ‰åŒºå—çš„å…ƒæ•°æ®ã€‚
2. `chainstate` stores the state of a chain, which is all currently unspent transaction outputs and some metadata.
   `chainstate` å­˜å‚¨é“¾çš„çŠ¶æ€ï¼Œå³å½“å‰æ‰€æœ‰æœªä½¿ç”¨çš„äº‹åŠ¡è¾“å‡ºå’Œä¸€äº›å…ƒæ•°æ®ã€‚

Also, blocks are stored as separate files on the disk. This is done for a performance purpose: reading a single block wonâ€™t require loading all (or some) of them into memory. We wonâ€™t implement this.
æ­¤å¤–ï¼Œæ•°æ®å—ä»¥å•ç‹¬æ–‡ä»¶çš„å½¢å¼å­˜å‚¨åœ¨ç£ç›˜ä¸Šã€‚è¿™æ ·åšçš„ç›®çš„æ˜¯ä¸ºäº†æé«˜æ€§èƒ½ï¼šè¯»å–å•ä¸ªæ•°æ®å—æ—¶ä¸éœ€è¦å°†æ‰€æœ‰ï¼ˆæˆ–éƒ¨åˆ†ï¼‰æ•°æ®å—åŠ è½½åˆ°å†…å­˜ä¸­ã€‚æˆ‘ä»¬ä¸ä¼šå®ç°è¿™ä¸€ç‚¹ã€‚

In `blocks`, the `key -> value` pairs are:
åœ¨ `blocks` ä¸­ï¼Œ `key -> value` å¯¹ï¼š

1. `'b' + 32-byte block hash -> block index record`
2. `'f' + 4-byte file number -> file information record`
3. `'l' -> 4-byte file number: the last block file number used`
4. `'R' -> 1-byte boolean: whether we're in the process of reindexing`
5. `'F' + 1-byte flag name length + flag name string -> 1 byte boolean: various flags that can be on or off`
6. `'t' + 32-byte transaction hash -> transaction index record`

In `chainstate`, the `key -> value` pairs are:
åœ¨ `chainstate` ä¸­ï¼Œ `key -> value` å¯¹ï¼š

1. `'c' + 32-byte transaction hash -> unspent transaction output record for that transaction`
2. `'B' -> 32-byte block hash: the block hash up to which the database represents the unspent transaction outputs`

*(Detailed explanation can be found [here](https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2):_Data_Storage))
(è¯¦ç»†è§£é‡Šè§æ­¤å¤„ï¼‰*

Since we donâ€™t have transactions yet, weâ€™re going to have only `blocks` bucket. Also, as said above, we will store the whole DB as a single file, without storing blocks in separate files. So we wonâ€™t need anything related to file numbers. So these are `key -> value` pairs weâ€™ll use:
ç”±äºæˆ‘ä»¬è¿˜æ²¡æœ‰äº‹åŠ¡ï¼Œæ‰€ä»¥åªæœ‰ `blocks` bucketã€‚æ­¤å¤–ï¼Œå¦‚ä¸Šæ‰€è¿°ï¼Œæˆ‘ä»¬ä¼šå°†æ•´ä¸ªæ•°æ®åº“å­˜å‚¨ä¸ºä¸€ä¸ªæ–‡ä»¶ï¼Œè€Œä¸ä¼šå°†æ•°æ®å—å­˜å‚¨åœ¨å•ç‹¬çš„æ–‡ä»¶ä¸­ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä»»ä½•ä¸æ–‡ä»¶ç¼–å·ç›¸å…³çš„ä¸œè¥¿ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ `key -> value` å¯¹ï¼š

1. `32-byte block-hash -> Block structure (serialized)`
2. `'l' -> the hash of the last block in a chain`

Thatâ€™s all we need to know to start implementing the persistence mechanism.
è¿™å°±æ˜¯æˆ‘ä»¬å¼€å§‹å®æ–½æŒä¹…æ€§æœºåˆ¶æ‰€éœ€è¦çŸ¥é“çš„ä¸€åˆ‡ã€‚

### Serialization åºåˆ—åŒ–

As said before, in BoltDB values can be only of `[]byte` type, and we want to store `Block` structs in the DB. Weâ€™ll use [encoding/gob](https://golang.org/pkg/encoding/gob/) to serialize the structs.
å¦‚å‰æ‰€è¿°ï¼Œåœ¨ BoltDB ä¸­ï¼Œå€¼åªèƒ½æ˜¯ `[]byte` ç±»å‹ï¼Œè€Œæˆ‘ä»¬å¸Œæœ›åœ¨æ•°æ®åº“ä¸­å­˜å‚¨ `Block` ç»“æ„ä½“ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ç¼–ç /gob æ¥åºåˆ—åŒ–ç»“æ„ä½“ã€‚

Letâ€™s implement `Serialize` method of `Block` (errors processing is omitted for brevity):
è®©æˆ‘ä»¬å®ç° `Serialize` æ–¹æ³• `Block` ï¼ˆä¸ºç®€æ´èµ·è§ï¼Œé”™è¯¯å¤„ç†çœç•¥ï¼‰ï¼š

```go
func (b *Block) Serialize() []byte {
	var result bytes.Buffer
	encoder := gob.NewEncoder(&result)

	err := encoder.Encode(b)

	return result.Bytes()
}
```

The piece is straightforward: at first, we declare a buffer that will store serialized data; then we initialize a `gob` encoder and encode the block; the result is returned as a byte array.
è¯¥ç¨‹åºç®€å•æ˜äº†ï¼šé¦–å…ˆï¼Œæˆ‘ä»¬å£°æ˜ä¸€ä¸ªå°†å­˜å‚¨åºåˆ—åŒ–æ•°æ®çš„ç¼“å†²åŒºï¼›ç„¶åï¼Œæˆ‘ä»¬åˆå§‹åŒ–ä¸€ä¸ª `gob` ç¼–ç å™¨å¹¶å¯¹æ•°æ®å—è¿›è¡Œç¼–ç ï¼›ç»“æœä»¥å­—èŠ‚æ•°ç»„çš„å½¢å¼è¿”å›ã€‚

Next, we need a deserializing function that will receive a byte array as input and return a `Block`. This wonâ€™t be a method but an independent function:
æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªååºåˆ—åŒ–å‡½æ•°ï¼Œæ¥æ”¶å­—èŠ‚æ•°ç»„ä½œä¸ºè¾“å…¥ï¼Œå¹¶è¿”å› `Block` ã€‚è¿™ä¸æ˜¯ä¸€ä¸ªæ–¹æ³•ï¼Œè€Œæ˜¯ä¸€ä¸ªç‹¬ç«‹å‡½æ•°ï¼š

```go
func DeserializeBlock(d []byte) *Block {
	var block Block

	decoder := gob.NewDecoder(bytes.NewReader(d))
	err := decoder.Decode(&block)

	return &block
}
```

And thatâ€™s it for the serialization!
è¿è½½åˆ°æ­¤ä¸ºæ­¢ï¼

### Persistence åšæŒä¸æ‡ˆ

Letâ€™s start with the `NewBlockchain` function. Currently, it creates a new instance of `Blockchain` and adds the genesis block to it. What we want it to do is to:
è®©æˆ‘ä»¬ä» `NewBlockchain` å‡½æ•°å¼€å§‹ã€‚ç›®å‰ï¼Œå®ƒåˆ›å»ºäº†ä¸€ä¸ª `Blockchain` çš„æ–°å®ä¾‹ï¼Œå¹¶æ·»åŠ äº† genesis å—ã€‚æˆ‘ä»¬æƒ³è®©å®ƒåšçš„æ˜¯

1. Open a DB file.
   æ‰“å¼€ DB æ–‡ä»¶ã€‚

2. Check if thereâ€™s a blockchain stored in it.
   æ£€æŸ¥å…¶ä¸­æ˜¯å¦å­˜å‚¨æœ‰åŒºå—é“¾ã€‚

3. If thereâ€™s a blockchain:

   
   å¦‚æœæœ‰åŒºå—é“¾

   1. Create a new `Blockchain` instance.
      åˆ›å»ºä¸€ä¸ªæ–°çš„ `Blockchain` å®ä¾‹ã€‚
   2. Set the tip of the `Blockchain` instance to the last block hash stored in the DB.
      å°† `Blockchain` å®ä¾‹çš„æç¤ºè®¾ç½®ä¸ºæ•°æ®åº“ä¸­å­˜å‚¨çš„æœ€åä¸€ä¸ªå—å“ˆå¸Œå€¼ã€‚

4. If thereâ€™s no existing blockchain:

   
   å¦‚æœæ²¡æœ‰ç°æˆçš„åŒºå—é“¾ï¼š

   1. Create the genesis block.
      åˆ›å»ºåˆ›ä¸–åŒºå—ã€‚
   2. Store in the DB.
      å­˜å‚¨åœ¨æ•°æ®åº“ä¸­ã€‚
   3. Save the genesis blockâ€™s hash as the last block hash.
      å°†åˆ›ä¸–åŒºå—çš„å“ˆå¸Œå€¼ä¿å­˜ä¸ºæœ€åä¸€ä¸ªåŒºå—çš„å“ˆå¸Œå€¼ã€‚
   4. Create a new `Blockchain` instance with its tip pointing at the genesis block.
      åˆ›å»ºä¸€ä¸ªæ–°çš„ `Blockchain` å®ä¾‹ï¼Œå…¶å°–ç«¯æŒ‡å‘åˆ›ä¸–å—ã€‚

In code, it looks like this:
ä»£ç æ˜¯è¿™æ ·çš„

```go
func NewBlockchain() *Blockchain {
	var tip []byte
	db, err := bolt.Open(dbFile, 0600, nil)

	err = db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blocksBucket))

		if b == nil {
			genesis := NewGenesisBlock()
			b, err := tx.CreateBucket([]byte(blocksBucket))
			err = b.Put(genesis.Hash, genesis.Serialize())
			err = b.Put([]byte("l"), genesis.Hash)
			tip = genesis.Hash
		} else {
			tip = b.Get([]byte("l"))
		}

		return nil
	})

	bc := Blockchain{tip, db}

	return &bc
}
```

Letâ€™s review this piece by piece.
è®©æˆ‘ä»¬é€ä¸€å›é¡¾ä¸€ä¸‹ã€‚

```go
db, err := bolt.Open(dbFile, 0600, nil)
```

This is a standard way of opening a BoltDB file. Notice that it wonâ€™t return an error if thereâ€™s no such file.
è¿™æ˜¯æ‰“å¼€ BoltDB æ–‡ä»¶çš„æ ‡å‡†æ–¹æ³•ã€‚è¯·æ³¨æ„ï¼Œå¦‚æœæ²¡æœ‰æ­¤ç±»æ–‡ä»¶ï¼Œå®ƒä¸ä¼šè¿”å›é”™è¯¯ã€‚

```go
err = db.Update(func(tx *bolt.Tx) error {
...
})
```

In BoltDB, operations with a database are run within a transaction. And there are two types of transactions: read-only and read-write. Here, we open a read-write transaction (`db.Update(...)`), because we expect to put the genesis block in the DB.
åœ¨ BoltDB ä¸­ï¼Œå¯¹æ•°æ®åº“çš„æ“ä½œæ˜¯åœ¨äº‹åŠ¡ä¸­è¿›è¡Œçš„ã€‚äº‹åŠ¡æœ‰ä¸¤ç§ç±»å‹ï¼šåªè¯»äº‹åŠ¡å’Œè¯»å†™äº‹åŠ¡ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æ‰“å¼€ä¸€ä¸ªè¯»å†™äº‹åŠ¡ ( `db.Update(...)` )ï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›æŠŠåˆ›ä¸–å—æ”¾åˆ°æ•°æ®åº“ä¸­ã€‚

```go
b := tx.Bucket([]byte(blocksBucket))

if b == nil {
	genesis := NewGenesisBlock()
	b, err := tx.CreateBucket([]byte(blocksBucket))
	err = b.Put(genesis.Hash, genesis.Serialize())
	err = b.Put([]byte("l"), genesis.Hash)
	tip = genesis.Hash
} else {
	tip = b.Get([]byte("l"))
}
```

This is the core of the function. Here, we obtain the bucket storing our blocks: if it exists, we read the `l` key from it; if it doesnâ€™t exist, we generate the genesis block, create the bucket, save the block into it, and update the `l` key storing the last block hash of the chain.
è¿™æ˜¯åŠŸèƒ½çš„æ ¸å¿ƒã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬è·å–å­˜å‚¨åŒºå—çš„ "æ¡¶"ï¼šå¦‚æœ "æ¡¶ "å­˜åœ¨ï¼Œæˆ‘ä»¬å°±ä»ä¸­è¯»å– `l` å¯†é’¥ï¼›å¦‚æœ "æ¡¶ "ä¸å­˜åœ¨ï¼Œæˆ‘ä»¬å°±ç”Ÿæˆåˆ›ä¸–åŒºå—ï¼Œåˆ›å»º "æ¡¶"ï¼Œå°†åŒºå—ä¿å­˜åˆ° "æ¡¶ "ä¸­ï¼Œå¹¶æ›´æ–°å­˜å‚¨é“¾ä¸Šæœ€åä¸€ä¸ªåŒºå—å“ˆå¸Œå€¼çš„ `l` å¯†é’¥ã€‚

Also, notice the new way of creating a `Blockchain`:
æ­¤å¤–ï¼Œè¯·æ³¨æ„åˆ›å»º `Blockchain` çš„æ–°æ–¹æ³•ï¼š

```go
bc := Blockchain{tip, db}
```

We donâ€™t store all the blocks in it anymore, instead only the tip of the chain is stored. Also, we store a DB connection, because we want to open it once and keep it open while the program is running. Thus, the `Blockchain` structure now looks like this:
æˆ‘ä»¬ä¸å†åœ¨å…¶ä¸­å­˜å‚¨æ‰€æœ‰åŒºå—ï¼Œè€Œæ˜¯åªå­˜å‚¨é“¾çš„é¡¶ç«¯ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜å­˜å‚¨äº†ä¸€ä¸ªæ•°æ®åº“è¿æ¥ï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›åªæ‰“å¼€ä¸€æ¬¡ï¼Œå¹¶åœ¨ç¨‹åºè¿è¡Œæ—¶ä¿æŒæ‰“å¼€çŠ¶æ€ã€‚å› æ­¤ï¼Œ `Blockchain` ç»“æ„ç°åœ¨çœ‹èµ·æ¥åƒè¿™æ ·ï¼š

```go
type Blockchain struct {
	tip []byte
	db  *bolt.DB
}
```

Next thing we want to update is the `AddBlock` method: adding blocks to a chain now is not as easy as adding an element to an array. From now on weâ€™ll store blocks in the DB:
æ¥ä¸‹æ¥æˆ‘ä»¬è¦æ›´æ–°çš„æ˜¯ `AddBlock` æ–¹æ³•ï¼šç°åœ¨å‘é“¾ä¸­æ·»åŠ åŒºå—å¹¶ä¸åƒå‘æ•°ç»„ä¸­æ·»åŠ å…ƒç´ é‚£ä¹ˆç®€å•ã€‚ä»ç°åœ¨èµ·ï¼Œæˆ‘ä»¬å°†åœ¨æ•°æ®åº“ä¸­å­˜å‚¨åŒºå—ï¼š

```go
func (bc *Blockchain) AddBlock(data string) {
	var lastHash []byte

	err := bc.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blocksBucket))
		lastHash = b.Get([]byte("l"))

		return nil
	})

	newBlock := NewBlock(data, lastHash)

	err = bc.db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blocksBucket))
		err := b.Put(newBlock.Hash, newBlock.Serialize())
		err = b.Put([]byte("l"), newBlock.Hash)
		bc.tip = newBlock.Hash

		return nil
	})
}
```

Letâ€™s review this piece by piece:
è®©æˆ‘ä»¬é€ä¸€å›é¡¾ä¸€ä¸‹ï¼š

```go
err := bc.db.View(func(tx *bolt.Tx) error {
	b := tx.Bucket([]byte(blocksBucket))
	lastHash = b.Get([]byte("l"))

	return nil
})
```

This is the other (read-only) type of BoltDB transactions. Here we get the last block hash from the DB to use it to mine a new block hash.
è¿™æ˜¯ BoltDB äº‹åŠ¡çš„å¦ä¸€ç§ï¼ˆåªè¯»ï¼‰ç±»å‹ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä»æ•°æ®åº“ä¸­è·å–æœ€åä¸€ä¸ªåŒºå—çš„å“ˆå¸Œå€¼ï¼Œç”¨äºæŒ–æ˜æ–°çš„åŒºå—å“ˆå¸Œå€¼ã€‚

```go
newBlock := NewBlock(data, lastHash)
b := tx.Bucket([]byte(blocksBucket))
err := b.Put(newBlock.Hash, newBlock.Serialize())
err = b.Put([]byte("l"), newBlock.Hash)
bc.tip = newBlock.Hash
```

After mining a new block, we save its serialized representation into the DB and update the `l` key, which now stores the new blockâ€™s hash.
æŒ–å‡ºä¸€ä¸ªæ–°åŒºå—åï¼Œæˆ‘ä»¬ä¼šå°†å…¶åºåˆ—åŒ–è¡¨ç¤ºä¿å­˜åˆ°æ•°æ®åº“ä¸­ï¼Œå¹¶æ›´æ–° `l` å¯†é’¥ï¼Œç°åœ¨è¯¥å¯†é’¥å­˜å‚¨äº†æ–°åŒºå—çš„å“ˆå¸Œå€¼ã€‚

Done! It wasnâ€™t hard, was it?
å®Œæˆäº†ä¸éš¾å§ï¼Ÿ

### Inspecting Blockchain æ£€æŸ¥åŒºå—é“¾

All new blocks are now saved in a database, so we can reopen a blockchain and add a new block to it. But after implementing this, we lost a nice feature: we cannot print out blockchain blocks anymore because we donâ€™t store blocks in an array any longer. Letâ€™s fix this flaw!
ç°åœ¨ï¼Œæ‰€æœ‰æ–°åŒºå—éƒ½ä¿å­˜åœ¨æ•°æ®åº“ä¸­ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é‡æ–°æ‰“å¼€åŒºå—é“¾å¹¶å‘å…¶ä¸­æ·»åŠ æ–°åŒºå—ã€‚ä½†æ˜¯ï¼Œå®ç°è¿™ä¸€ç‚¹åï¼Œæˆ‘ä»¬å¤±å»äº†ä¸€ä¸ªå¾ˆå¥½çš„åŠŸèƒ½ï¼šæˆ‘ä»¬æ— æ³•å†æ‰“å°å‡ºåŒºå—é“¾åŒºå—ï¼Œå› ä¸ºæˆ‘ä»¬ä¸å†å°†åŒºå—å­˜å‚¨åœ¨æ•°ç»„ä¸­ã€‚è®©æˆ‘ä»¬æ¥ä¿®å¤è¿™ä¸ªç¼ºé™·ï¼

BoltDB allows to iterate over all the keys in a bucket, but the keys are stored in byte-sorted order, and we want blocks to be printed in the order they take in a blockchain. Also, because we donâ€™t want to load all the blocks into memory (our blockchain DB could be huge!.. or letâ€™s just pretend it could), weâ€™ll read them one by one. For this purpose, weâ€™ll need a blockchain iterator:
BoltDB å…è®¸éå†ä¸€ä¸ªæ¡¶ä¸­çš„æ‰€æœ‰å¯†é’¥ï¼Œä½†å¯†é’¥æ˜¯æŒ‰å­—èŠ‚æ’åºå­˜å‚¨çš„ï¼Œè€Œæˆ‘ä»¬å¸Œæœ›æŒ‰åŒºå—é“¾ä¸­çš„é¡ºåºæ‰“å°åŒºå—ã€‚æ­¤å¤–ï¼Œç”±äºæˆ‘ä»¬ä¸æƒ³å°†æ‰€æœ‰åŒºå—åŠ è½½åˆ°å†…å­˜ä¸­ï¼ˆæˆ‘ä»¬çš„åŒºå—é“¾æ•°æ®åº“å¯èƒ½éå¸¸åºå¤§ï¼æˆ–è€…è®©æˆ‘ä»¬å‡è£…å®ƒéå¸¸åºå¤§ï¼‰ï¼Œå› æ­¤æˆ‘ä»¬å°†é€ä¸ªè¯»å–ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåŒºå—é“¾è¿­ä»£å™¨ï¼š

```go
type BlockchainIterator struct {
	currentHash []byte
	db          *bolt.DB
}
```

An iterator will be created each time we want to iterate over blocks in a blockchain and itâ€™ll store the block hash of the current iteration and a connection to a DB. Because of the latter, an iterator is logically attached to a blockchain (itâ€™s a `Blockchain` instance that stores a DB connection) and, thus, is created in a `Blockchain` method:
æ¯æ¬¡æˆ‘ä»¬è¦è¿­ä»£åŒºå—é“¾ä¸­çš„åŒºå—æ—¶ï¼Œéƒ½ä¼šåˆ›å»ºä¸€ä¸ªè¿­ä»£å™¨ï¼Œå®ƒå°†å­˜å‚¨å½“å‰è¿­ä»£çš„åŒºå—å“ˆå¸Œå€¼å’Œä¸æ•°æ®åº“çš„è¿æ¥ã€‚ç”±äºåè€…ï¼Œè¿­ä»£å™¨åœ¨é€»è¾‘ä¸Šä¸åŒºå—é“¾ç›¸è¿ï¼ˆå®ƒæ˜¯ä¸€ä¸ªå­˜å‚¨æ•°æ®åº“è¿æ¥çš„ `Blockchain` å®ä¾‹ï¼‰ï¼Œå› æ­¤åœ¨ `Blockchain` æ–¹æ³•ä¸­åˆ›å»ºï¼š

```go
func (bc *Blockchain) Iterator() *BlockchainIterator {
	bci := &BlockchainIterator{bc.tip, bc.db}

	return bci
}
```

Notice that an iterator initially points at the tip of a blockchain, thus blocks will be obtained from top to bottom, from newest to oldest. In fact, **choosing a tip means â€œvotingâ€ for a blockchain**. A blockchain can have multiple branches, and itâ€™s the longest of them thatâ€™s considered main. After getting a tip (it can be any block in the blockchain) we can reconstruct the whole blockchain and find its length and the work required to build it. This fact also means that a tip is a kind of an identifier of a blockchain.
è¯·æ³¨æ„ï¼Œè¿­ä»£å™¨æœ€åˆæŒ‡å‘çš„æ˜¯åŒºå—é“¾çš„é¡¶ç«¯ï¼Œå› æ­¤åŒºå—å°†ä»ä¸Šåˆ°ä¸‹ã€ä»æœ€æ–°åˆ°æœ€æ—§åœ°è·å–ã€‚äº‹å®ä¸Šï¼Œé€‰æ‹©é¡¶ç«¯æ„å‘³ç€ä¸ºåŒºå—é“¾ "æŠ•ç¥¨"ã€‚ä¸€ä¸ªåŒºå—é“¾å¯ä»¥æœ‰å¤šä¸ªåˆ†æ”¯ï¼Œå…¶ä¸­æœ€é•¿çš„åˆ†æ”¯æ‰è¢«è§†ä¸ºä¸»é“¾ã€‚å¾—åˆ°ä¸€ä¸ªæç¤ºï¼ˆå¯ä»¥æ˜¯åŒºå—é“¾ä¸­çš„ä»»ä½•åŒºå—ï¼‰åï¼Œæˆ‘ä»¬å°±å¯ä»¥é‡æ„æ•´ä¸ªåŒºå—é“¾ï¼Œæ‰¾å‡ºå®ƒçš„é•¿åº¦å’Œæ„å»ºå®ƒæ‰€éœ€çš„å·¥ä½œé‡ã€‚è¿™ä¸€äº‹å®ä¹Ÿæ„å‘³ç€æç¤ºæ˜¯åŒºå—é“¾çš„ä¸€ç§æ ‡è¯†ç¬¦ã€‚

`BlockchainIterator` will do only one thing: itâ€™ll return the next block from a blockchain.
`BlockchainIterator` åªä¼šåšä¸€ä»¶äº‹ï¼šä»åŒºå—é“¾ä¸­è¿”å›ä¸‹ä¸€ä¸ªåŒºå—ã€‚

```go
func (i *BlockchainIterator) Next() *Block {
	var block *Block

	err := i.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blocksBucket))
		encodedBlock := b.Get(i.currentHash)
		block = DeserializeBlock(encodedBlock)

		return nil
	})

	i.currentHash = block.PrevBlockHash

	return block
}
```

Thatâ€™s it for the DB part!
DB éƒ¨åˆ†åˆ°æ­¤ä¸ºæ­¢ï¼

### CLI

Until now our implementation hasnâ€™t provided any interface to interact with the program: weâ€™ve simply executed `NewBlockchain`, `bc.AddBlock` in the `main` function. Time to improve this! We want to have these commands:
åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬çš„å®ç°è¿˜æ²¡æœ‰æä¾›ä»»ä½•ä¸ç¨‹åºäº¤äº’çš„æ¥å£ï¼šæˆ‘ä»¬åªæ˜¯åœ¨ `main` å‡½æ•°ä¸­æ‰§è¡Œäº† `NewBlockchain` , `bc.AddBlock` ã€‚æ˜¯æ—¶å€™æ”¹è¿›äº†ï¼æˆ‘ä»¬éœ€è¦è¿™äº›å‘½ä»¤ï¼š

```
blockchain_go addblock "Pay 0.031337 for a coffee"
blockchain_go printchain
```

All command-line related operations will be processed by the `CLI` struct:
æ‰€æœ‰ä¸å‘½ä»¤è¡Œç›¸å…³çš„æ“ä½œéƒ½å°†ç”± `CLI` ç»“æ„å¤„ç†ï¼š

```go
type CLI struct {
	bc *Blockchain
}
```

Its â€œentrypointâ€ is the `Run` function:
å…¶ "å…¥å£ç‚¹ "æ˜¯ `Run` å‡½æ•°ï¼š

```go
func (cli *CLI) Run() {
	cli.validateArgs()

	addBlockCmd := flag.NewFlagSet("addblock", flag.ExitOnError)
	printChainCmd := flag.NewFlagSet("printchain", flag.ExitOnError)

	addBlockData := addBlockCmd.String("data", "", "Block data")

	switch os.Args[1] {
	case "addblock":
		err := addBlockCmd.Parse(os.Args[2:])
	case "printchain":
		err := printChainCmd.Parse(os.Args[2:])
	default:
		cli.printUsage()
		os.Exit(1)
	}

	if addBlockCmd.Parsed() {
		if *addBlockData == "" {
			addBlockCmd.Usage()
			os.Exit(1)
		}
		cli.addBlock(*addBlockData)
	}

	if printChainCmd.Parsed() {
		cli.printChain()
	}
}
```

Weâ€™re using the standard [flag](https://golang.org/pkg/flag/) package to parse command-line arguments.
æˆ‘ä»¬ä½¿ç”¨æ ‡å‡†æ ‡å¿—åŒ…æ¥è§£æå‘½ä»¤è¡Œå‚æ•°ã€‚

```go
addBlockCmd := flag.NewFlagSet("addblock", flag.ExitOnError)
printChainCmd := flag.NewFlagSet("printchain", flag.ExitOnError)
addBlockData := addBlockCmd.String("data", "", "Block data")
```

First, we create two subcommands, `addblock` and `printchain`, then we add `-data` flag to the former. `printchain` wonâ€™t have any flags.
é¦–å…ˆï¼Œæˆ‘ä»¬åˆ›å»ºä¸¤ä¸ªå­å‘½ä»¤ `addblock` å’Œ `printchain` ï¼Œç„¶ååœ¨å‰è€…ä¸­æ·»åŠ  `-data` æ ‡å¿—ã€‚ `printchain` ä¸ä¼šæœ‰ä»»ä½•æ ‡å¿—ã€‚

```go
switch os.Args[1] {
case "addblock":
	err := addBlockCmd.Parse(os.Args[2:])
case "printchain":
	err := printChainCmd.Parse(os.Args[2:])
default:
	cli.printUsage()
	os.Exit(1)
}
```

Next we check the command provided by user and parse related `flag` subcommand.
æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ£€æŸ¥ç”¨æˆ·æä¾›çš„å‘½ä»¤ï¼Œå¹¶è§£æç›¸å…³çš„ `flag` å­å‘½ä»¤ã€‚

```go
if addBlockCmd.Parsed() {
	if *addBlockData == "" {
		addBlockCmd.Usage()
		os.Exit(1)
	}
	cli.addBlock(*addBlockData)
}

if printChainCmd.Parsed() {
	cli.printChain()
}
```

Next we check which of the subcommands were parsed and run related functions.
æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ£€æŸ¥å“ªäº›å­å‘½ä»¤å·²è¢«è§£æï¼Œå¹¶è¿è¡Œç›¸å…³å‡½æ•°ã€‚

```go
func (cli *CLI) addBlock(data string) {
	cli.bc.AddBlock(data)
	fmt.Println("Success!")
}

func (cli *CLI) printChain() {
	bci := cli.bc.Iterator()

	for {
		block := bci.Next()

		fmt.Printf("Prev. hash: %x\n", block.PrevBlockHash)
		fmt.Printf("Data: %s\n", block.Data)
		fmt.Printf("Hash: %x\n", block.Hash)
		pow := NewProofOfWork(block)
		fmt.Printf("PoW: %s\n", strconv.FormatBool(pow.Validate()))
		fmt.Println()

		if len(block.PrevBlockHash) == 0 {
			break
		}
	}
}
```

This piece is very similar to the one we had before. The only difference is that weâ€™re now using a `BlockchainIterator` to iterate over blocks in a blockchain.
è¿™ä¸€å—ä¸æˆ‘ä»¬ä¹‹å‰çš„ä¸€å—éå¸¸ç›¸ä¼¼ã€‚å”¯ä¸€ä¸åŒçš„æ˜¯ï¼Œæˆ‘ä»¬ç°åœ¨ä½¿ç”¨ `BlockchainIterator` æ¥éå†åŒºå—é“¾ä¸­çš„åŒºå—ã€‚

Also letâ€™s not forget to modify the `main` function accordingly:
æ­¤å¤–ï¼Œä¸è¦å¿˜è®°å¯¹ `main` å‡½æ•°è¿›è¡Œç›¸åº”çš„ä¿®æ”¹ï¼š

```go
func main() {
	bc := NewBlockchain()
	defer bc.db.Close()

	cli := CLI{bc}
	cli.Run()
}
```

Note that a new `Blockchain` is created no matter what command-line arguments are provided.
è¯·æ³¨æ„ï¼Œæ— è®ºæä¾›ä»€ä¹ˆå‘½ä»¤è¡Œå‚æ•°ï¼Œéƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ `Blockchain` ã€‚

And thatâ€™s it! Letâ€™s check that everything works as expected:
å°±æ˜¯è¿™æ ·ï¼è®©æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸‹æ˜¯å¦ä¸€åˆ‡æ­£å¸¸ï¼š

```shell
$ blockchain_go printchain
No existing blockchain found. Creating a new one...
Mining the block containing "Genesis Block"
000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b

Prev. hash:
Data: Genesis Block
Hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b
PoW: true

$ blockchain_go addblock -data "Send 1 BTC to Ivan"
Mining the block containing "Send 1 BTC to Ivan"
000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13

Success!

$ blockchain_go addblock -data "Pay 0.31337 BTC for a coffee"
Mining the block containing "Pay 0.31337 BTC for a coffee"
000000aa0748da7367dec6b9de5027f4fae0963df89ff39d8f20fd7299307148

Success!

$ blockchain_go printchain
Prev. hash: 000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13
Data: Pay 0.31337 BTC for a coffee
Hash: 000000aa0748da7367dec6b9de5027f4fae0963df89ff39d8f20fd7299307148
PoW: true

Prev. hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b
Data: Send 1 BTC to Ivan
Hash: 000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13
PoW: true

Prev. hash:
Data: Genesis Block
Hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b
PoW: true
```

*(sound of a beer can opening)
(å•¤é…’ç½æ‰“å¼€çš„å£°éŸ³ï¼‰*

### Conclusion ç»“è®º

Next time weâ€™ll implement addresses, wallets, and (probably) transactions. So stay tuned!
ä¸‹ä¸€æ¬¡ï¼Œæˆ‘ä»¬å°†å®ç°åœ°å€ã€é’±åŒ…å’Œï¼ˆå¯èƒ½ï¼‰äº¤æ˜“ã€‚æ•¬è¯·æœŸå¾…ï¼

### Links é“¾æ¥

1. [Full source codes å®Œæ•´æºä»£ç ](https://github.com/Jeiwan/blockchain_go/tree/part_3)
2. [Bitcoin Core Data Storage
   æ¯”ç‰¹å¸æ ¸å¿ƒæ•°æ®å­˜å‚¨](https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2):_Data_Storage)
3. [boltdb èºæ “åº“](https://github.com/boltdb/bolt)
4. [encoding/gob ç¼–ç /gob](https://golang.org/pkg/encoding/gob/)
5. [flag å›½æ——](https://golang.org/pkg/flag/)



## Building Blockchain in Go. Part 4: Transactions 1

04 Sep 2017

> Chinese translations: [by liuchengxu](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-4/transactions-1.md), [by zhangli1](https://zhangli1.gitbooks.io/dummies-for-blockchain/content/)
> ä¸­æ–‡ç¿»è¯‘ï¼šåˆ˜æˆæ—­ã€å¼ è‰1

### Introduction å¯¼è¨€

Transactions are the heart of Bitcoin and the only purpose of blockchain is to store transactions in a secure and reliable way, so no one could modify them after they are created. Today weâ€™re starting implementing transactions. But because this is quite a big topic, Iâ€™ll split it into two parts: in this part, weâ€™ll implement the general mechanism of transactions and in the second part weâ€™ll work through details.
äº¤æ˜“æ˜¯æ¯”ç‰¹å¸çš„æ ¸å¿ƒï¼Œè€ŒåŒºå—é“¾çš„å”¯ä¸€ç›®çš„å°±æ˜¯ä»¥å®‰å…¨å¯é çš„æ–¹å¼å­˜å‚¨äº¤æ˜“ï¼Œè¿™æ ·å°±ä¸ä¼šæœ‰äººåœ¨äº¤æ˜“åˆ›å»ºåå¯¹å…¶è¿›è¡Œä¿®æ”¹ã€‚ä»Šå¤©ï¼Œæˆ‘ä»¬å¼€å§‹å®ç°äº¤æ˜“ã€‚ä½†ç”±äºè¿™æ˜¯ä¸€ä¸ªç›¸å½“å¤§çš„è¯é¢˜ï¼Œæˆ‘å°†æŠŠå®ƒåˆ†æˆä¸¤éƒ¨åˆ†ï¼šåœ¨è¿™ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†å®ç°äº¤æ˜“çš„ä¸€èˆ¬æœºåˆ¶ï¼Œè€Œåœ¨ç¬¬äºŒéƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ç ”ç©¶ç»†èŠ‚ã€‚

Also, since code changes are massive, it makes no sense describing all of them here. You can see all the changes [here](https://github.com/Jeiwan/blockchain_go/compare/part_3...part_4#files_bucket).
æ­¤å¤–ï¼Œç”±äºä»£ç æ”¹åŠ¨éå¸¸å¤§ï¼Œåœ¨æ­¤æ— æ³•ä¸€ä¸€æè¿°ã€‚æ‚¨å¯ä»¥åœ¨è¿™é‡ŒæŸ¥çœ‹æ‰€æœ‰æ›´æ”¹ã€‚

### There is no spoon æ²¡æœ‰å‹ºå­

If youâ€™ve ever developed a web application, in order to implement payments you would likely to create these tables in a DB: `accounts` and `transactions`. An account would store information about a user, including their personal information and balance, and a transaction would store information about money transferring from one account to another. In Bitcoin, payments are realized in completely different way. There are:
å¦‚æœæ‚¨æ›¾ç»å¼€å‘è¿‡ä¸€ä¸ªç½‘ç»œåº”ç”¨ç¨‹åºï¼Œä¸ºäº†å®ç°æ”¯ä»˜åŠŸèƒ½ï¼Œæ‚¨å¾ˆå¯èƒ½è¦åœ¨æ•°æ®åº“ä¸­åˆ›å»ºè¿™äº›è¡¨ï¼š `accounts` å’Œ `transactions` ã€‚è´¦æˆ·å­˜å‚¨ç”¨æˆ·çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬ä¸ªäººä¿¡æ¯å’Œä½™é¢ï¼Œäº¤æ˜“åˆ™å­˜å‚¨ä»ä¸€ä¸ªè´¦æˆ·å‘å¦ä¸€ä¸ªè´¦æˆ·è½¬è´¦çš„ä¿¡æ¯ã€‚åœ¨æ¯”ç‰¹å¸ä¸­ï¼Œæ”¯ä»˜æ˜¯ä»¥å®Œå…¨ä¸åŒçš„æ–¹å¼å®ç°çš„ã€‚æœ‰

1. No accounts. æ²¡æœ‰è´¦æˆ·ã€‚
2. No balances. æ²¡æœ‰ä½™é¢ã€‚
3. No addresses. æ²¡æœ‰åœ°å€ã€‚
4. No coins. æ²¡æœ‰ç¡¬å¸
5. No senders and receivers.
   æ²¡æœ‰å‘é€å™¨å’Œæ¥æ”¶å™¨ã€‚

Since blockchain is a public and open database, we donâ€™t want to store sensitive information about wallet owners. Coins are not collected in accounts. Transactions do not transfer money from one address to another. Thereâ€™s no field or attribute that holds account balance. There are only transactions. But whatâ€™s inside a transaction?
ç”±äºåŒºå—é“¾æ˜¯ä¸€ä¸ªå…¬å¼€ã€å¼€æ”¾çš„æ•°æ®åº“ï¼Œæˆ‘ä»¬ä¸æƒ³å­˜å‚¨é’±åŒ…æ‰€æœ‰è€…çš„æ•æ„Ÿä¿¡æ¯ã€‚ç¡¬å¸ä¸ä¼šè¢«æ”¶é›†åˆ°è´¦æˆ·ä¸­ã€‚äº¤æ˜“ä¸ä¼šå°†é’±ä»ä¸€ä¸ªåœ°å€è½¬ç§»åˆ°å¦ä¸€ä¸ªåœ°å€ã€‚æ²¡æœ‰è®°å½•è´¦æˆ·ä½™é¢çš„å­—æ®µæˆ–å±æ€§ã€‚åªæœ‰äº¤æ˜“ã€‚ä½†æ˜¯ï¼Œäº¤æ˜“é‡Œé¢æœ‰ä»€ä¹ˆå‘¢ï¼Ÿ

### Bitcoin Transaction æ¯”ç‰¹å¸äº¤æ˜“

A transaction is a combination of inputs and outputs:
äº¤æ˜“æ˜¯è¾“å…¥å’Œè¾“å‡ºçš„ç»„åˆï¼š

```go
type Transaction struct {
	ID   []byte
	Vin  []TXInput
	Vout []TXOutput
}
```

Inputs of a new transaction reference outputs of a previous transaction (thereâ€™s an exception though, which weâ€™ll discuss later). Outputs are where coins are actually stored. The following diagram demonstrates the interconnection of transactions:
æ–°äº¤æ˜“çš„è¾“å…¥ä¼šå‚è€ƒä¹‹å‰äº¤æ˜“çš„è¾“å‡ºï¼ˆä½†æœ‰ä¸€ä¸ªä¾‹å¤–ï¼Œæˆ‘ä»¬ç¨åä¼šè®¨è®ºï¼‰ã€‚è¾“å‡ºæ˜¯å®é™…å­˜å‚¨ç¡¬å¸çš„åœ°æ–¹ã€‚ä¸‹å›¾å±•ç¤ºäº†äº¤æ˜“ä¹‹é—´çš„ç›¸äº’è¿æ¥ï¼š

![Transactions](https://jeiwan.net/images/transactions-diagram.png)

Notice that: è¯·æ³¨æ„

1. There are outputs that are not linked to inputs.
   æœ‰äº›è¾“å‡ºä¸è¾“å…¥æ²¡æœ‰å…³è”ã€‚
2. In one transaction, inputs can reference outputs from multiple transactions.
   åœ¨ä¸€ä¸ªäº‹åŠ¡ä¸­ï¼Œè¾“å…¥å¯ä»¥å¼•ç”¨å¤šä¸ªäº‹åŠ¡çš„è¾“å‡ºã€‚
3. An input must reference an output.
   è¾“å…¥å¿…é¡»å¼•ç”¨è¾“å‡ºã€‚

Throughout this article, weâ€™ll use words like â€œmoneyâ€, â€œcoinsâ€, â€œspendâ€, â€œsendâ€, â€œaccountâ€, etc. But there are no such concepts in Bitcoin. Transactions just lock values with a script, which can be unlocked only by the one who locked them.
åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ "é’±"ã€"å¸"ã€"èŠ±"ã€"å‘é€"ã€"è´¦æˆ· "ç­‰è¯æ±‡ã€‚ä½†æ¯”ç‰¹å¸ä¸­æ²¡æœ‰è¿™äº›æ¦‚å¿µã€‚äº¤æ˜“åªæ˜¯ç”¨è„šæœ¬é”å®šä»·å€¼ï¼Œåªæœ‰é”å®šè€…æ‰èƒ½è§£é”ã€‚

### Transaction Outputs äº¤æ˜“è¾“å‡º

Letâ€™s start with outputs first:
å…ˆè¯´äº§å‡ºï¼š

```go
type TXOutput struct {
	Value        int
	ScriptPubKey string
}
```

Actually, itâ€™s outputs that store â€œcoinsâ€ (notice the `Value` field above). And storing means locking them with a puzzle, which is stored in the `ScriptPubKey`. Internally, Bitcoin uses a scripting language called *Script*, that is used to define outputs locking and unlocking logic. The language is quite primitive (this is made intentionally, to avoid possible hacks and misuses), but we wonâ€™t discuss it in details. You can find a detailed explanation of it [here](https://en.bitcoin.it/wiki/Script).
å®é™…ä¸Šï¼Œå­˜å‚¨ "ç¡¬å¸ "çš„æ˜¯è¾“å‡ºï¼ˆæ³¨æ„ä¸Šé¢çš„ `Value` å­—æ®µï¼‰ã€‚å­˜å‚¨çš„æ„æ€æ˜¯ç”¨ä¸€ä¸ªè°œé¢˜é”å®šå®ƒä»¬ï¼Œè°œé¢˜å­˜å‚¨åœ¨ `ScriptPubKey` ä¸­ã€‚æ¯”ç‰¹å¸å†…éƒ¨ä½¿ç”¨ä¸€ç§å«åšè„šæœ¬çš„è„šæœ¬è¯­è¨€ï¼Œç”¨æ¥å®šä¹‰è¾“å‡ºé”å®šå’Œè§£é”é€»è¾‘ã€‚è¿™ç§è¯­è¨€éå¸¸åŸå§‹ï¼ˆè¿™æ˜¯æœ‰æ„ä¸ºä¹‹ï¼Œä»¥é¿å…å¯èƒ½çš„é»‘å®¢æ”»å‡»å’Œæ»¥ç”¨ï¼‰ï¼Œä½†æˆ‘ä»¬ä¸ä¼šè¯¦ç»†è®¨è®ºå®ƒã€‚ä½ å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°è¯¦ç»†çš„è§£é‡Šã€‚

> In Bitcoin, the *value* field stores the number of *satoshis*, not the number of BTC. A *satoshi* is a hundred millionth of a bitcoin (0.00000001 BTC), thus this is the smallest unit of currency in Bitcoin (like a cent).
> åœ¨æ¯”ç‰¹å¸ä¸­ï¼Œä»·å€¼å­—æ®µå­˜å‚¨çš„æ˜¯ satoshis çš„æ•°é‡ï¼Œè€Œä¸æ˜¯ BTC çš„æ•°é‡ã€‚ä¸€ä¸ª satoshi æ˜¯ä¸€ä¸ªæ¯”ç‰¹å¸çš„ä¸€äº¿åˆ†ä¹‹ä¸€ï¼ˆ0.00000001 BTCï¼‰ï¼Œå› æ­¤å®ƒæ˜¯æ¯”ç‰¹å¸ä¸­æœ€å°çš„è´§å¸å•ä½ï¼ˆå°±åƒç¾åˆ†ä¸€æ ·ï¼‰ã€‚

Since we donâ€™t have addresses implemented, weâ€™ll avoid the whole scripting related logic for now. `ScriptPubKey` will store an arbitrary string (user defined wallet address).
`ScriptPubKey` å°†å­˜å‚¨ä»»æ„å­—ç¬¦ä¸²ï¼ˆç”¨æˆ·å®šä¹‰çš„é’±åŒ…åœ°å€ï¼‰ã€‚

> By the way, having such scripting language means that Bitcoin can be used as a smart-contract platform as well.
> é¡ºä¾¿è¯´ä¸€å¥ï¼Œæ‹¥æœ‰è¿™æ ·çš„è„šæœ¬è¯­è¨€æ„å‘³ç€æ¯”ç‰¹å¸ä¹Ÿå¯ä»¥ç”¨ä½œæ™ºèƒ½åˆçº¦å¹³å°ã€‚

One important thing about outputs is that they are **indivisible**, which means that you cannot reference a part of its value. When an output is referenced in a new transaction, itâ€™s spent as a whole. And if its value is greater than required, a change is generated and sent back to the sender. This is similar to a real world situation when you pay, say, a $5 banknote for something that costs $1 and get a change of $4.
å…³äºè¾“å‡ºï¼Œæœ‰ä¸€ç‚¹å¾ˆé‡è¦ï¼Œé‚£å°±æ˜¯å®ƒä»¬æ˜¯ä¸å¯åˆ†å‰²çš„ï¼Œè¿™æ„å‘³ç€ä½ ä¸èƒ½å¼•ç”¨å…¶ä»·å€¼çš„ä¸€éƒ¨åˆ†ã€‚å½“åœ¨æ–°äº‹åŠ¡ä¸­å¼•ç”¨ä¸€ä¸ªè¾“å‡ºæ—¶ï¼Œå®ƒå°†ä½œä¸ºä¸€ä¸ªæ•´ä½“ä½¿ç”¨ã€‚å¦‚æœå®ƒçš„å€¼å¤§äºæ‰€éœ€å€¼ï¼Œå°±ä¼šäº§ç”Ÿå˜åŒ–å¹¶å‘é€å›å‘é€æ–¹ã€‚è¿™ä¸ç°å®ä¸–ç•Œä¸­çš„æƒ…å†µç±»ä¼¼ï¼Œæ¯”å¦‚ä½ ç”¨ä¸€å¼  5 ç¾å…ƒçš„çº¸å¸æ”¯ä»˜äº† 1 ç¾å…ƒçš„ä¸œè¥¿ï¼Œå¹¶å¾—åˆ°äº† 4 ç¾å…ƒçš„é›¶é’±ã€‚

### Transaction Inputs äº¤æ˜“è¾“å…¥

And hereâ€™s the input:
è¿™å°±æ˜¯è¾“å…¥ï¼š

```go
type TXInput struct {
	Txid      []byte
	Vout      int
	ScriptSig string
}
```

As mentioned earlier, an input references a previous output: `Txid` stores the ID of such transaction, and `Vout` stores an index of an output in the transaction. `ScriptSig` is a script which provides data to be used in an outputâ€™s `ScriptPubKey`. If the data is correct, the output can be unlocked, and its value can be used to generate new outputs; if itâ€™s not correct, the output cannot be referenced in the input. This is the mechanism that guarantees that users cannot spend coins belonging to other people.
å¦‚å‰æ‰€è¿°ï¼Œè¾“å…¥ä¼šå¼•ç”¨ä¹‹å‰çš„è¾“å‡ºï¼š `Txid` å­˜å‚¨è¯¥äº‹åŠ¡çš„ IDï¼Œ `Vout` å­˜å‚¨è¯¥äº‹åŠ¡ä¸­è¾“å‡ºçš„ç´¢å¼•ã€‚ `ScriptSig` æ˜¯ä¸€ä¸ªè„šæœ¬ï¼Œæä¾›ç”¨äºè¾“å‡ºçš„æ•°æ® `ScriptPubKey` ã€‚å¦‚æœæ•°æ®æ­£ç¡®ï¼Œè¾“å‡ºå°±å¯ä»¥è§£é”ï¼Œå…¶å€¼å¯ç”¨äºç”Ÿæˆæ–°çš„è¾“å‡ºï¼›å¦‚æœæ•°æ®ä¸æ­£ç¡®ï¼Œè¾“å‡ºå°±ä¸èƒ½åœ¨è¾“å…¥ä¸­å¼•ç”¨ã€‚è¿™å°±æ˜¯ä¿è¯ç”¨æˆ·ä¸èƒ½èŠ±è´¹å±äºå…¶ä»–äººçš„ç¡¬å¸çš„æœºåˆ¶ã€‚

Again, since we donâ€™t have addresses implemented yet, `ScriptSig` will store just an arbitrary user defined wallet address. Weâ€™ll implement public keys and signatures checking in the next article.
åŒæ ·ï¼Œç”±äºæˆ‘ä»¬è¿˜æ²¡æœ‰å®ç°åœ°å€ï¼Œ `ScriptSig` åªä¼šå­˜å‚¨ç”¨æˆ·å®šä¹‰çš„ä»»æ„é’±åŒ…åœ°å€ã€‚æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­å®ç°å…¬é’¥å’Œç­¾åæ£€æŸ¥ã€‚

Letâ€™s sum it up. Outputs are where â€œcoinsâ€ are stored. Each output comes with an unlocking script, which determines the logic of unlocking the output. Every new transaction must have at least one input and output. An input references an output from a previous transaction and provides data (the `ScriptSig` field) that is used in the outputâ€™s unlocking script to unlock it and use its value to create new outputs.
è®©æˆ‘ä»¬æ¥æ€»ç»“ä¸€ä¸‹ã€‚è¾“å‡ºç«¯æ˜¯å­˜å‚¨ "ç¡¬å¸ "çš„åœ°æ–¹ã€‚æ¯ä¸ªè¾“å‡ºéƒ½æœ‰ä¸€ä¸ªè§£é”è„šæœ¬ï¼Œå®ƒå†³å®šäº†è§£é”è¾“å‡ºçš„é€»è¾‘ã€‚æ¯ç¬”æ–°äº¤æ˜“å¿…é¡»è‡³å°‘æœ‰ä¸€ä¸ªè¾“å…¥å’Œè¾“å‡ºã€‚è¾“å…¥ä¼šå¼•ç”¨ä¸Šä¸€ç¬”äº¤æ˜“çš„è¾“å‡ºï¼Œå¹¶æä¾›æ•°æ®ï¼ˆ `ScriptSig` å­—æ®µï¼‰ï¼Œè¾“å‡ºçš„è§£é”è„šæœ¬ä¼šä½¿ç”¨è¿™äº›æ•°æ®æ¥è§£é”è¾“å‡ºï¼Œå¹¶ä½¿ç”¨å…¶å€¼åˆ›å»ºæ–°çš„è¾“å‡ºã€‚

But what came first: inputs or outputs?
ä½†æ˜¯ï¼ŒæŠ•å…¥å’Œäº§å‡ºå“ªä¸ªåœ¨å…ˆï¼Ÿ

### The egg é¸¡è›‹

In Bitcoin, itâ€™s the egg that came before the chicken. The inputs-referencing-outputs logic is the classical â€œchicken or the eggâ€ situation: inputs produce outputs and outputs make inputs possible. And in Bitcoin, outputs come before inputs.
åœ¨æ¯”ç‰¹å¸ä¸­ï¼Œå…ˆæœ‰è›‹åæœ‰é¸¡ã€‚è¾“å…¥-å‚è€ƒ-è¾“å‡ºé€»è¾‘æ˜¯ç»å…¸çš„ "å…ˆæœ‰é¸¡è¿˜æ˜¯å…ˆæœ‰è›‹"ï¼šè¾“å…¥äº§ç”Ÿè¾“å‡ºï¼Œè¾“å‡ºä½¿è¾“å…¥æˆä¸ºå¯èƒ½ã€‚è€Œåœ¨æ¯”ç‰¹å¸ä¸­ï¼Œäº§å‡ºå…ˆäºæŠ•å…¥ã€‚

When a miner starts mining a block, it adds a **coinbase transaction** to it. A coinbase transaction is a special type of transactions, which doesnâ€™t require previously existing outputs. It creates outputs (i.e., â€œcoinsâ€) out of nowhere. The egg without a chicken. This is the reward miners get for mining new blocks.
å½“çŸ¿å·¥å¼€å§‹æŒ–æ˜ä¸€ä¸ªåŒºå—æ—¶ï¼Œå°±ä¼šä¸ºè¯¥åŒºå—æ·»åŠ  Coinbase äº¤æ˜“ã€‚Coinbase äº¤æ˜“æ˜¯ä¸€ç§ç‰¹æ®Šç±»å‹çš„äº¤æ˜“ï¼Œå®ƒä¸éœ€è¦å…ˆå‰å­˜åœ¨çš„è¾“å‡ºã€‚å®ƒå¯ä»¥å‡­ç©ºäº§ç”Ÿè¾“å‡ºï¼ˆå³ "å¸"ï¼‰ã€‚æ²¡æœ‰é¸¡çš„è›‹ã€‚è¿™æ˜¯çŸ¿å·¥æŒ–æ˜æ–°åŒºå—è·å¾—çš„å¥–åŠ±ã€‚

As you know, thereâ€™s the genesis block in the beginning of a blockchain. Itâ€™s this block that generates the very first output in the blockchain. And no previous outputs are required since there are no previous transactions and no such outputs.
ä¼—æ‰€å‘¨çŸ¥ï¼ŒåŒºå—é“¾çš„å¼€å¤´æœ‰ä¸€ä¸ªåˆ›ä¸–åŒºå—ã€‚æ­£æ˜¯è¿™ä¸ªåŒºå—äº§ç”Ÿäº†åŒºå—é“¾ä¸­çš„ç¬¬ä¸€ä¸ªè¾“å‡ºã€‚ç”±äºæ²¡æœ‰ä¹‹å‰çš„äº¤æ˜“å’Œè¾“å‡ºï¼Œå› æ­¤ä¸éœ€è¦ä¹‹å‰çš„è¾“å‡ºã€‚

Letâ€™s create a coinbase transaction:
è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª Coinbase äº¤æ˜“ï¼š

```go
func NewCoinbaseTX(to, data string) *Transaction {
	if data == "" {
		data = fmt.Sprintf("Reward to '%s'", to)
	}

	txin := TXInput{[]byte{}, -1, data}
	txout := TXOutput{subsidy, to}
	tx := Transaction{nil, []TXInput{txin}, []TXOutput{txout}}
	tx.SetID()

	return &tx
}
```

A coinbase transaction has only one input. In our implementation its `Txid` is empty and `Vout` equals to -1. Also, a coinbase transaction doesnâ€™t store a script in `ScriptSig`. Instead, arbitrary data is stored there.
Coinbase äº¤æ˜“åªæœ‰ä¸€ä¸ªè¾“å…¥ã€‚åœ¨æˆ‘ä»¬çš„å®ç°ä¸­ï¼Œ `Txid` ä¸ºç©ºï¼Œ `Vout` ç­‰äº-1ã€‚æ­¤å¤–ï¼ŒCoinbase äº¤æ˜“ä¸ä¼šåœ¨ `ScriptSig` ä¸­å­˜å‚¨è„šæœ¬ã€‚è€Œæ˜¯å­˜å‚¨ä»»æ„æ•°æ®ã€‚

> In Bitcoin, the very first coinbase transaction contains the following message: â€œThe Times 03/Jan/2009 Chancellor on brink of second bailout for banksâ€. [You can see it yourself](https://blockchain.info/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b?show_adv=true).
> åœ¨æ¯”ç‰¹å¸ä¸­ï¼Œç¬¬ä¸€ç¬”Coinbaseäº¤æ˜“åŒ…å«ä»¥ä¸‹ä¿¡æ¯ï¼š"æ³°æ™¤å£«æŠ¥ 2009å¹´1æœˆ3æ—¥ è‹±å›½é¦–ç›¸æ¿’ä¸´ç¬¬äºŒæ¬¡æ•‘åŠ©é“¶è¡Œ"ä½ å¯ä»¥è‡ªå·±çœ‹çœ‹

```
subsidy` is the amount of reward. In Bitcoin, this number is not stored anywhere and calculated based only on the total number of blocks: the number of blocks is divided by `210000`. Mining the genesis block produced 50 BTC, and every `210000` blocks the reward is halved. In our implementation, weâ€™ll store the reward as a constant (at least for now ğŸ˜‰ ).
`subsidy` æ˜¯å¥–åŠ±é‡‘é¢ã€‚åœ¨æ¯”ç‰¹å¸ä¸­ï¼Œè¿™ä¸ªæ•°å­—ä¸å­˜å‚¨åœ¨ä»»ä½•åœ°æ–¹ï¼Œåªæ ¹æ®åŒºå—æ€»æ•°è®¡ç®—ï¼šåŒºå—æ•°é™¤ä»¥ ã€‚æŒ–æ˜åˆ›ä¸–åŒºå—å¯ä»¥è·å¾— 50 BTCï¼Œæ¯æŒ–æ˜ ä¸ªåŒºå—ï¼Œå¥–åŠ±å°±ä¼šå‡åŠã€‚åœ¨æˆ‘ä»¬çš„å®ç°ä¸­ï¼Œæˆ‘ä»¬ä¼šå°†å¥–åŠ±å­˜å‚¨ä¸ºä¸€ä¸ªå¸¸æ•°ï¼ˆè‡³å°‘ç°åœ¨æ˜¯è¿™æ ·ğŸ˜‰ï¼‰ã€‚ `210000` `210000
```

### Storing Transactions in Blockchain åœ¨åŒºå—é“¾ä¸­å­˜å‚¨äº¤æ˜“

From now on, every block must store at least one transaction and itâ€™s no more possible to mine blocks without transactions. This means that we should remove the `Data` field of `Block` and store transactions instead:
ä»ç°åœ¨èµ·ï¼Œæ¯ä¸ªåŒºå—éƒ½å¿…é¡»è‡³å°‘å­˜å‚¨ä¸€ç¬”äº¤æ˜“ï¼Œæ²¡æœ‰äº¤æ˜“çš„åŒºå—æ˜¯æ— æ³•æŒ–çŸ¿çš„ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬åº”è¯¥åˆ é™¤ `Block` çš„ `Data` å­—æ®µï¼Œè½¬è€Œå­˜å‚¨äº¤æ˜“ï¼š

```go
type Block struct {
	Timestamp     int64
	Transactions  []*Transaction
	PrevBlockHash []byte
	Hash          []byte
	Nonce         int
}
NewBlock` and `NewGenesisBlock` also must be changed accordingly:
`NewBlock` å’Œ ä¹Ÿå¿…é¡»ç›¸åº”æ›´æ”¹ï¼š `NewGenesisBlock
func NewBlock(transactions []*Transaction, prevBlockHash []byte) *Block {
	block := &Block{time.Now().Unix(), transactions, prevBlockHash, []byte{}, 0}
	...
}

func NewGenesisBlock(coinbase *Transaction) *Block {
	return NewBlock([]*Transaction{coinbase}, []byte{})
}
```

Next thing to change is the creation of a new blockchain:
ä¸‹ä¸€ä¸ªå˜åŒ–æ˜¯åˆ›å»ºæ–°çš„åŒºå—é“¾ï¼š

```go
func CreateBlockchain(address string) *Blockchain {
	...
	err = db.Update(func(tx *bolt.Tx) error {
		cbtx := NewCoinbaseTX(address, genesisCoinbaseData)
		genesis := NewGenesisBlock(cbtx)

		b, err := tx.CreateBucket([]byte(blocksBucket))
		err = b.Put(genesis.Hash, genesis.Serialize())
		...
	})
	...
}
```

Now, the function takes an address which will receive the reward for mining the genesis block.
ç°åœ¨ï¼Œè¯¥å‡½æ•°å°†è·å–ä¸€ä¸ªåœ°å€ï¼Œè¯¥åœ°å€å°†è·å¾—å¼€é‡‡åˆ›ä¸–åŒºå—çš„å¥–åŠ±ã€‚

### Proof-of-Work å·¥ä½œè¯æ˜

The Proof-of-Work algorithm must consider transactions stored in a block, to guarantee the consistency and reliability of blockchain as a storage of transaction. So now we must modify the `ProofOfWork.prepareData` method:
å·¥ä½œè¯æ˜ç®—æ³•å¿…é¡»è€ƒè™‘å­˜å‚¨åœ¨åŒºå—ä¸­çš„äº¤æ˜“ï¼Œä»¥ä¿è¯åŒºå—é“¾ä½œä¸ºäº¤æ˜“å­˜å‚¨çš„ä¸€è‡´æ€§å’Œå¯é æ€§ã€‚å› æ­¤ï¼Œç°åœ¨æˆ‘ä»¬å¿…é¡»ä¿®æ”¹ `ProofOfWork.prepareData` æ–¹æ³•ï¼š

```go
func (pow *ProofOfWork) prepareData(nonce int) []byte {
	data := bytes.Join(
		[][]byte{
			pow.block.PrevBlockHash,
			pow.block.HashTransactions(), // This line was changed
			IntToHex(pow.block.Timestamp),
			IntToHex(int64(targetBits)),
			IntToHex(int64(nonce)),
		},
		[]byte{},
	)

	return data
}
```

Instead of `pow.block.Data` we now use `pow.block.HashTransactions()` which is:
æˆ‘ä»¬ç°åœ¨ä¸ä½¿ç”¨ `pow.block.Data` ï¼Œè€Œæ˜¯ä½¿ç”¨ `pow.block.HashTransactions()` ï¼š

```go
func (b *Block) HashTransactions() []byte {
	var txHashes [][]byte
	var txHash [32]byte

	for _, tx := range b.Transactions {
		txHashes = append(txHashes, tx.ID)
	}
	txHash = sha256.Sum256(bytes.Join(txHashes, []byte{}))

	return txHash[:]
}
```

Again, weâ€™re using hashing as a mechanism of providing unique representation of data. We want all transactions in a block to be uniquely identified by a single hash. To achieve this, we get hashes of each transaction, concatenate them, and get a hash of the concatenated combination.
åŒæ ·ï¼Œæˆ‘ä»¬ä½¿ç”¨å“ˆå¸Œç®—æ³•ä½œä¸ºä¸€ç§æä¾›å”¯ä¸€æ•°æ®è¡¨ç¤ºçš„æœºåˆ¶ã€‚æˆ‘ä»¬å¸Œæœ›ä¸€ä¸ªåŒºå—ä¸­çš„æ‰€æœ‰äº‹åŠ¡éƒ½èƒ½é€šè¿‡ä¸€ä¸ªå“ˆå¸Œå€¼å”¯ä¸€æ ‡è¯†ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç›®æ ‡ï¼Œæˆ‘ä»¬éœ€è¦è·å–æ¯ç¬”äº¤æ˜“çš„å“ˆå¸Œå€¼ï¼Œå°†å®ƒä»¬è¿æ¥èµ·æ¥ï¼Œç„¶åè·å–è¿æ¥ç»„åˆçš„å“ˆå¸Œå€¼ã€‚

> Bitcoin uses a more elaborate technique: it represents all transactions containing in a block as a [Merkle tree](https://en.wikipedia.org/wiki/Merkle_tree) and uses the root hash of the tree in the Proof-of-Work system. This approach allows to quickly check if a block contains certain transaction, having only just the root hash and without downloading all the transactions.
> æ¯”ç‰¹å¸ä½¿ç”¨äº†ä¸€ç§æ›´å¤æ‚çš„æŠ€æœ¯ï¼šå®ƒå°†ä¸€ä¸ªåŒºå—ä¸­åŒ…å«çš„æ‰€æœ‰äº¤æ˜“è¡¨ç¤ºä¸ºä¸€æ£µæ¢…å…‹å°”æ ‘ï¼Œå¹¶åœ¨å·¥ä½œè¯æ˜ç³»ç»Ÿä¸­ä½¿ç”¨è¯¥æ ‘çš„æ ¹åˆ‡é›†å€¼ã€‚è¿™ç§æ–¹æ³•åªéœ€æ ¹å“ˆå¸Œå€¼ï¼Œæ— éœ€ä¸‹è½½æ‰€æœ‰äº¤æ˜“ï¼Œå°±èƒ½å¿«é€Ÿæ£€æŸ¥ä¸€ä¸ªåŒºå—æ˜¯å¦åŒ…å«æŸäº›äº¤æ˜“ã€‚

Letâ€™s check that everything is correct so far:
è®©æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸‹ç›®å‰çš„ä¸€åˆ‡æ˜¯å¦æ­£ç¡®ï¼š

```shell
$ blockchain_go createblockchain -address Ivan
00000093450837f8b52b78c25f8163bb6137caf43ff4d9a01d1b731fa8ddcc8a

Done!
```

Good! We received out first mining reward. But how do we check the balance?
å¾ˆå¥½ï¼æˆ‘ä»¬æ”¶åˆ°äº†ç¬¬ä¸€ç¬”é‡‡çŸ¿å¥–åŠ±ã€‚ä½†æˆ‘ä»¬å¦‚ä½•æŸ¥çœ‹ä½™é¢å‘¢ï¼Ÿ

### Unspent Transaction Outputs æœªç”¨äº¤æ˜“è¾“å‡º

We need to find all unspent transaction outputs (UTXO). *Unspent* means that these outputs werenâ€™t referenced in any inputs. On the diagram above, these are:
æˆ‘ä»¬éœ€è¦æ‰¾åˆ°æ‰€æœ‰æœªä½¿ç”¨çš„äº¤æ˜“è¾“å‡ºï¼ˆUTXOï¼‰ã€‚æœªä½¿ç”¨æ„å‘³ç€è¿™äº›è¾“å‡ºæ²¡æœ‰åœ¨ä»»ä½•è¾“å…¥ä¸­è¢«å¼•ç”¨ã€‚åœ¨ä¸Šå›¾ä¸­ï¼Œè¿™äº›è¾“å‡ºæ˜¯

1. tx0, output 1; tx0ï¼Œè¾“å‡º 1ï¼›
2. tx1, output 0; tx1ï¼Œè¾“å‡º 0ï¼›
3. tx3, output 0; tx3ï¼Œè¾“å‡º 0ï¼›
4. tx4, output 0. tx4ï¼Œè¾“å‡º 0ã€‚

Of course, when we check balance, we donâ€™t need all of them, but only those that can be unlocked by the key we own (currently we donâ€™t have keys implemented and will use user defined addresses instead). First, letâ€™s define locking-unlocking methods on inputs and outputs:
å½“ç„¶ï¼Œå½“æˆ‘ä»¬æ£€æŸ¥ä½™é¢æ—¶ï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦æ‰€æœ‰çš„ä½™é¢ï¼Œè€Œåªéœ€è¦é‚£äº›å¯ä»¥é€šè¿‡æˆ‘ä»¬æ‹¥æœ‰çš„å¯†é’¥è§£é”çš„ä½™é¢ï¼ˆç›®å‰æˆ‘ä»¬è¿˜æ²¡æœ‰å®ç°å¯†é’¥ï¼Œå°†ä½¿ç”¨ç”¨æˆ·å®šä¹‰çš„åœ°å€æ¥ä»£æ›¿ï¼‰ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬å®šä¹‰è¾“å…¥å’Œè¾“å‡ºçš„é”å®š-è§£é”æ–¹æ³•ï¼š

```go
func (in *TXInput) CanUnlockOutputWith(unlockingData string) bool {
	return in.ScriptSig == unlockingData
}

func (out *TXOutput) CanBeUnlockedWith(unlockingData string) bool {
	return out.ScriptPubKey == unlockingData
}
```

Here we just compare the script fields with `unlockingData`. These pieces will be improved in a future article, after we implement addresses based on private keys.
åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬åªæ˜¯å°†è„šæœ¬å­—æ®µä¸ `unlockingData` è¿›è¡Œæ¯”è¾ƒã€‚åœ¨å®ç°åŸºäºç§é’¥çš„åœ°å€åï¼Œæˆ‘ä»¬å°†åœ¨ä»Šåçš„æ–‡ç« ä¸­å¯¹è¿™äº›éƒ¨åˆ†è¿›è¡Œæ”¹è¿›ã€‚

The next step - finding transactions containing unspent outputs - is quite difficult:
ä¸‹ä¸€æ­¥--æŸ¥æ‰¾åŒ…å«æœªç”¨äº§å‡ºçš„äº¤æ˜“--ç›¸å½“å›°éš¾ï¼š

```go
func (bc *Blockchain) FindUnspentTransactions(address string) []Transaction {
  var unspentTXs []Transaction
  spentTXOs := make(map[string][]int)
  bci := bc.Iterator()

  for {
    block := bci.Next()

    for _, tx := range block.Transactions {
      txID := hex.EncodeToString(tx.ID)

    Outputs:
      for outIdx, out := range tx.Vout {
        // Was the output spent?
        if spentTXOs[txID] != nil {
          for _, spentOut := range spentTXOs[txID] {
            if spentOut == outIdx {
              continue Outputs
            }
          }
        }

        if out.CanBeUnlockedWith(address) {
          unspentTXs = append(unspentTXs, *tx)
        }
      }

      if tx.IsCoinbase() == false {
        for _, in := range tx.Vin {
          if in.CanUnlockOutputWith(address) {
            inTxID := hex.EncodeToString(in.Txid)
            spentTXOs[inTxID] = append(spentTXOs[inTxID], in.Vout)
          }
        }
      }
    }

    if len(block.PrevBlockHash) == 0 {
      break
    }
  }

  return unspentTXs
}
```

Since transactions are stored in blocks, we have to check every block in a blockchain. We start with outputs:
ç”±äºäº¤æ˜“å­˜å‚¨åœ¨åŒºå—ä¸­ï¼Œæˆ‘ä»¬å¿…é¡»æ£€æŸ¥åŒºå—é“¾ä¸­çš„æ¯ä¸ªåŒºå—ã€‚æˆ‘ä»¬ä»è¾“å‡ºå¼€å§‹ï¼š

```go
if out.CanBeUnlockedWith(address) {
	unspentTXs = append(unspentTXs, tx)
}
```

If an output was locked by the same address weâ€™re searching unspent transaction outputs for, then this is the output we want. But before taking it, we need to check if an output was already referenced in an input:
å¦‚æœæŸä¸ªè¾“å‡ºè¢«é”å®šçš„åœ°å€ä¸æˆ‘ä»¬æœç´¢æœªç”¨äº‹åŠ¡è¾“å‡ºçš„åœ°å€ç›¸åŒï¼Œé‚£ä¹ˆè¿™å°±æ˜¯æˆ‘ä»¬æƒ³è¦çš„è¾“å‡ºã€‚ä½†åœ¨è·å–ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥æŸä¸ªè¾“å‡ºæ˜¯å¦å·²åœ¨è¾“å…¥ä¸­è¢«å¼•ç”¨ï¼š

```go
if spentTXOs[txID] != nil {
	for _, spentOut := range spentTXOs[txID] {
		if spentOut == outIdx {
			continue Outputs
		}
	}
}
```

We skip those that were referenced in inputs (their values were moved to other outputs, thus we cannot count them). After checking outputs we gather all inputs that could unlock outputs locked with the provided address (this doesnâ€™t apply to coinbase transactions, since they donâ€™t unlock outputs):
æˆ‘ä»¬è·³è¿‡é‚£äº›åœ¨è¾“å…¥ä¸­è¢«å¼•ç”¨çš„è¾“å…¥ï¼ˆå®ƒä»¬çš„å€¼è¢«è½¬ç§»åˆ°å…¶ä»–è¾“å‡ºä¸­ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•è®¡ç®—å®ƒä»¬ï¼‰ã€‚æ£€æŸ¥è¾“å‡ºåï¼Œæˆ‘ä»¬ä¼šæ”¶é›†æ‰€æœ‰å¯ä»¥è§£é”ä¸æ‰€æä¾›åœ°å€é”å®šçš„è¾“å‡ºçš„è¾“å…¥ï¼ˆè¿™ä¸é€‚ç”¨äº coinbase äº¤æ˜“ï¼Œå› ä¸ºå®ƒä»¬ä¸ä¼šè§£é”è¾“å‡ºï¼‰ï¼š

```go
if tx.IsCoinbase() == false {
    for _, in := range tx.Vin {
        if in.CanUnlockOutputWith(address) {
            inTxID := hex.EncodeToString(in.Txid)
            spentTXOs[inTxID] = append(spentTXOs[inTxID], in.Vout)
        }
    }
}
```

The function returns a list of transactions containing unspent outputs. To calculate balance we need one more function that takes the transactions and returns only outputs:
è¯¥å‡½æ•°è¿”å›ä¸€ä¸ªåŒ…å«æœªç”¨è¾“å‡ºçš„äº¤æ˜“åˆ—è¡¨ã€‚ä¸ºäº†è®¡ç®—ä½™é¢ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥æ”¶äº¤æ˜“å¹¶åªè¿”å›äº§å‡ºï¼š

```go
func (bc *Blockchain) FindUTXO(address string) []TXOutput {
       var UTXOs []TXOutput
       unspentTransactions := bc.FindUnspentTransactions(address)

       for _, tx := range unspentTransactions {
               for _, out := range tx.Vout {
                       if out.CanBeUnlockedWith(address) {
                               UTXOs = append(UTXOs, out)
                       }
               }
       }

       return UTXOs
}
```

Thatâ€™s it! Now we can implement `getbalance` command:
å°±æ˜¯è¿™æ ·ï¼ç°åœ¨æˆ‘ä»¬å¯ä»¥æ‰§è¡Œ `getbalance` å‘½ä»¤äº†ï¼š

```go
func (cli *CLI) getBalance(address string) {
	bc := NewBlockchain(address)
	defer bc.db.Close()

	balance := 0
	UTXOs := bc.FindUTXO(address)

	for _, out := range UTXOs {
		balance += out.Value
	}

	fmt.Printf("Balance of '%s': %d\n", address, balance)
}
```

The account balance is the sum of values of all unspent transaction outputs locked by the account address.
è´¦æˆ·ä½™é¢æ˜¯è´¦æˆ·åœ°å€é”å®šçš„æ‰€æœ‰æœªç”¨äº¤æ˜“è¾“å‡ºå€¼çš„æ€»å’Œã€‚

Letâ€™s check our balance after mining the genesis block:
å¼€é‡‡å®Œåˆ›ä¸–åŒºå—åï¼Œè®©æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸‹ä½™é¢ï¼š

```shell
$ blockchain_go getbalance -address Ivan
Balance of 'Ivan': 10
```

This is our first money!
è¿™æ˜¯æˆ‘ä»¬çš„ç¬¬ä¸€ç¬”é’±ï¼

### Sending Coins å‘é€ç¡¬å¸

Now, we want to send some coins to someone else. For this, we need to create a new transaction, put it in a block, and mine the block. So far, we implemented only the coinbase transaction (which is a special type of transactions), now we need a general transaction:
ç°åœ¨ï¼Œæˆ‘ä»¬æƒ³ç»™åˆ«äººå‘é€ä¸€äº›å¸ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„äº¤æ˜“ï¼Œå°†å…¶æ”¾å…¥ä¸€ä¸ªåŒºå—ä¸­ï¼Œå¹¶å¯¹è¯¥åŒºå—è¿›è¡ŒæŒ–çŸ¿ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªå®ç°äº† Coinbase äº¤æ˜“ï¼ˆè¿™æ˜¯ä¸€ç§ç‰¹æ®Šçš„äº¤æ˜“ç±»å‹ï¼‰ï¼Œç°åœ¨æˆ‘ä»¬éœ€è¦ä¸€ç§é€šç”¨äº¤æ˜“ï¼š

```go
func NewUTXOTransaction(from, to string, amount int, bc *Blockchain) *Transaction {
	var inputs []TXInput
	var outputs []TXOutput

	acc, validOutputs := bc.FindSpendableOutputs(from, amount)

	if acc < amount {
		log.Panic("ERROR: Not enough funds")
	}

	// Build a list of inputs
	for txid, outs := range validOutputs {
		txID, err := hex.DecodeString(txid)

		for _, out := range outs {
			input := TXInput{txID, out, from}
			inputs = append(inputs, input)
		}
	}

	// Build a list of outputs
	outputs = append(outputs, TXOutput{amount, to})
	if acc > amount {
		outputs = append(outputs, TXOutput{acc - amount, from}) // a change
	}

	tx := Transaction{nil, inputs, outputs}
	tx.SetID()

	return &tx
}
```

Before creating new outputs, we first have to find all unspent outputs and ensure that they store enough value. This is what `FindSpendableOutputs` method does. After that, for each found output an input referencing it is created. Next, we create two outputs:
åœ¨åˆ›å»ºæ–°çš„è¾“å‡ºä¹‹å‰ï¼Œæˆ‘ä»¬é¦–å…ˆè¦æ‰¾åˆ°æ‰€æœ‰æœªä½¿ç”¨çš„è¾“å‡ºï¼Œå¹¶ç¡®ä¿å®ƒä»¬å­˜å‚¨äº†è¶³å¤Ÿçš„å€¼ã€‚è¿™å°±æ˜¯ `FindSpendableOutputs` æ–¹æ³•çš„ä½œç”¨ã€‚ç„¶åï¼Œä¸ºæ¯ä¸ªæ‰¾åˆ°çš„è¾“å‡ºåˆ›å»ºä¸€ä¸ªå¼•ç”¨å®ƒçš„è¾“å…¥ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬åˆ›å»ºä¸¤ä¸ªè¾“å‡ºï¼š

1. One thatâ€™s locked with the receiver address. This is the actual transferring of coins to other address.
   ä¸€ä¸ªä¸æ¥æ”¶åœ°å€é”å®šçš„åœ°å€ã€‚è¿™å°±æ˜¯å°†ç¡¬å¸å®é™…è½¬ç§»åˆ°å…¶ä»–åœ°å€çš„è¿‡ç¨‹ã€‚
2. One thatâ€™s locked with the sender address. This is a change. Itâ€™s only created when unspent outputs hold more value than required for the new transaction. Remember: outputs are **indivisible**.
   ä¸€ä¸ªä¸å‘ä»¶äººåœ°å€é”å®šçš„åœ°å€ã€‚è¿™æ˜¯ä¸€ç§å˜åŒ–ã€‚åªæœ‰å½“æœªä½¿ç”¨çš„è¾“å‡ºå€¼è¶…è¿‡æ–°äº¤æ˜“çš„éœ€è¦æ—¶ï¼Œæ‰ä¼šäº§ç”Ÿè¿™ç§å˜åŒ–ã€‚è®°ä½ï¼šè¾“å‡ºæ˜¯ä¸å¯åˆ†å‰²çš„ã€‚

```
FindSpendableOutputs` method is based on the `FindUnspentTransactions` method we defined earlier:
`FindSpendableOutputs` æ–¹æ³•åŸºäºæˆ‘ä»¬ä¹‹å‰å®šä¹‰çš„ æ–¹æ³•ï¼š `FindUnspentTransactions
func (bc *Blockchain) FindSpendableOutputs(address string, amount int) (int, map[string][]int) {
	unspentOutputs := make(map[string][]int)
	unspentTXs := bc.FindUnspentTransactions(address)
	accumulated := 0

Work:
	for _, tx := range unspentTXs {
		txID := hex.EncodeToString(tx.ID)

		for outIdx, out := range tx.Vout {
			if out.CanBeUnlockedWith(address) && accumulated < amount {
				accumulated += out.Value
				unspentOutputs[txID] = append(unspentOutputs[txID], outIdx)

				if accumulated >= amount {
					break Work
				}
			}
		}
	}

	return accumulated, unspentOutputs
}
```

The method iterates over all unspent transactions and accumulates their values. When the accumulated value is more or equals to the amount we want to transfer, it stops and returns the accumulated value and output indices grouped by transaction IDs. We donâ€™t want to take more than weâ€™re going to spend.
è¯¥æ–¹æ³•éå†æ‰€æœ‰æœªä½¿ç”¨çš„äº¤æ˜“ï¼Œå¹¶ç´¯ç§¯å…¶å€¼ã€‚å½“ç´¯ç§¯å€¼å¤§äºæˆ–ç­‰äºæˆ‘ä»¬è¦è½¬è´¦çš„é‡‘é¢æ—¶ï¼Œå®ƒå°±ä¼šåœæ­¢ï¼Œå¹¶è¿”å›ç´¯ç§¯å€¼å’ŒæŒ‰äº¤æ˜“ ID åˆ†ç»„çš„è¾“å‡ºæŒ‡æ•°ã€‚æˆ‘ä»¬ä¸å¸Œæœ›æå–çš„é‡‘é¢è¶…è¿‡æˆ‘ä»¬è¦èŠ±è´¹çš„é‡‘é¢ã€‚

Now we can modify the `Blockchain.MineBlock` method:
ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ä¿®æ”¹ `Blockchain.MineBlock` æ–¹æ³•ï¼š

```go
func (bc *Blockchain) MineBlock(transactions []*Transaction) {
	...
	newBlock := NewBlock(transactions, lastHash)
	...
}
```

Finally, letâ€™s implement `send` command:
æœ€åï¼Œè®©æˆ‘ä»¬æ‰§è¡Œ `send` å‘½ä»¤ï¼š

```go
func (cli *CLI) send(from, to string, amount int) {
	bc := NewBlockchain(from)
	defer bc.db.Close()

	tx := NewUTXOTransaction(from, to, amount, bc)
	bc.MineBlock([]*Transaction{tx})
	fmt.Println("Success!")
}
```

Sending coins means creating a transaction and adding it to the blockchain via mining a block. But Bitcoin doesnâ€™t do this immediately (as we do). Instead, it puts all new transactions into memory pool (or mempool), and when a miner is ready to mine a block, it takes all transactions from the mempool and creates a candidate block. Transactions become confirmed only when a block containing them is mined and added to the blockchain.
å‘å¸æ„å‘³ç€åˆ›å»ºä¸€ç¬”äº¤æ˜“ï¼Œå¹¶é€šè¿‡æŒ–æ˜ä¸€ä¸ªåŒºå—å°†å…¶æ·»åŠ åˆ°åŒºå—é“¾ä¸­ã€‚ä½†æ¯”ç‰¹å¸ä¸ä¼šç«‹å³è¿™æ ·åšï¼ˆå°±åƒæˆ‘ä»¬ä¸€æ ·ï¼‰ã€‚ç›¸åï¼Œå®ƒä¼šå°†æ‰€æœ‰æ–°äº¤æ˜“æ”¾å…¥å†…å­˜æ± ï¼ˆæˆ–å†…å­˜æ± ï¼‰ï¼Œå½“çŸ¿å·¥å‡†å¤‡å¥½å¼€é‡‡ä¸€ä¸ªåŒºå—æ—¶ï¼Œå®ƒä¼šä»å†…å­˜æ± ä¸­æå–æ‰€æœ‰äº¤æ˜“å¹¶åˆ›å»ºä¸€ä¸ªå€™é€‰åŒºå—ã€‚åªæœ‰å½“åŒ…å«äº¤æ˜“çš„åŒºå—è¢«æŒ–å‡ºå¹¶æ·»åŠ åˆ°åŒºå—é“¾ä¸­æ—¶ï¼Œäº¤æ˜“æ‰ä¼šè¢«ç¡®è®¤ã€‚

Letâ€™s check that sending coins works:
è®©æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸‹å‘é€ç¡¬å¸æ˜¯å¦æœ‰æ•ˆï¼š

```shell
$ blockchain_go send -from Ivan -to Pedro -amount 6
00000001b56d60f86f72ab2a59fadb197d767b97d4873732be505e0a65cc1e37

Success!

$ blockchain_go getbalance -address Ivan
Balance of 'Ivan': 4

$ blockchain_go getbalance -address Pedro
Balance of 'Pedro': 6
```

Nice! Now, letâ€™s create more transactions and ensure that sending from multiple outputs works fine:
å¾ˆå¥½ï¼ç°åœ¨ï¼Œè®©æˆ‘ä»¬åˆ›å»ºæ›´å¤šçš„äº‹åŠ¡ï¼Œç¡®ä¿ä»å¤šä¸ªè¾“å‡ºå‘é€æ­£å¸¸å·¥ä½œï¼š

```shell
$ blockchain_go send -from Pedro -to Helen -amount 2
00000099938725eb2c7730844b3cd40209d46bce2c2af9d87c2b7611fe9d5bdf

Success!

$ blockchain_go send -from Ivan -to Helen -amount 2
000000a2edf94334b1d94f98d22d7e4c973261660397dc7340464f7959a7a9aa

Success!
```

Now, Helenâ€™s coins are locked in two outputs: one from Pedro and one from Ivan. Letâ€™s send them to someone else:
ç°åœ¨ï¼Œæµ·ä¼¦çš„ç¡¬å¸è¢«é”å®šåœ¨ä¸¤ä¸ªè¾“å‡ºç«¯ï¼šä¸€ä¸ªæ¥è‡ªä½©å¾·ç½—ï¼Œä¸€ä¸ªæ¥è‡ªä¼Šä¸‡ã€‚è®©æˆ‘ä»¬æŠŠå®ƒä»¬å‘é€ç»™å…¶ä»–äººï¼š

```shell
$ blockchain_go send -from Helen -to Rachel -amount 3
000000c58136cffa669e767b8f881d16e2ede3974d71df43058baaf8c069f1a0

Success!

$ blockchain_go getbalance -address Ivan
Balance of 'Ivan': 2

$ blockchain_go getbalance -address Pedro
Balance of 'Pedro': 4

$ blockchain_go getbalance -address Helen
Balance of 'Helen': 1

$ blockchain_go getbalance -address Rachel
Balance of 'Rachel': 3
```

Looks fine! Now letâ€™s test a failure:
çœ‹èµ·æ¥æ²¡é—®é¢˜ï¼ç°åœ¨æˆ‘ä»¬æ¥æµ‹è¯•ä¸€ä¸‹å¤±è´¥ï¼š

```shell
$ blockchain_go send -from Pedro -to Ivan -amount 5
panic: ERROR: Not enough funds

$ blockchain_go getbalance -address Pedro
Balance of 'Pedro': 4

$ blockchain_go getbalance -address Ivan
Balance of 'Ivan': 2
```

### Conclusion ç»“è®º

Phew! It wasnâ€™t easy, but we have transactions now! Although, some key features of a Bitcoin-like cryptocurrency are missing:
å‘¼ï¼è™½ç„¶ä¸å®¹æ˜“ï¼Œä½†æˆ‘ä»¬ç°åœ¨æœ‰äº†äº¤æ˜“ï¼ä¸è¿‡ï¼Œç±»ä¼¼æ¯”ç‰¹å¸çš„åŠ å¯†è´§å¸è¿˜ç¼ºå°‘ä¸€äº›å…³é”®åŠŸèƒ½ï¼š

1. Addresses. We donâ€™t have real, private key based addresses yet.
   åœ°å€ã€‚æˆ‘ä»¬è¿˜æ²¡æœ‰çœŸæ­£åŸºäºç§é’¥çš„åœ°å€ã€‚
2. Rewards. Mining blocks is absolutely not profitable!
   å¥–åŠ±ã€‚å¼€é‡‡åŒºå—ç»å¯¹æ— åˆ©å¯å›¾ï¼
3. UTXO set. Getting balance requires scanning the whole blockchain, which can take very long time when there are many and many blocks. Also, it can take a lot of time if we want to validate later transactions. UTXO set is intended to solve these problems and make operations with transactions fast.
   UTXOè®¾ç½®ã€‚è·å–ä½™é¢éœ€è¦æ‰«ææ•´ä¸ªåŒºå—é“¾ï¼Œå½“åŒºå—å¾ˆå¤šå¾ˆå¤šæ—¶ï¼Œè¿™å¯èƒ½éœ€è¦å¾ˆé•¿æ—¶é—´ã€‚æ­¤å¤–ï¼Œå¦‚æœæˆ‘ä»¬è¦éªŒè¯åé¢çš„äº¤æ˜“ï¼Œä¹Ÿä¼šèŠ±è´¹å¤§é‡æ—¶é—´ã€‚UTXOé›†æ—¨åœ¨è§£å†³è¿™äº›é—®é¢˜ï¼Œä½¿äº¤æ˜“æ“ä½œæ›´åŠ å¿«æ·ã€‚
4. Mempool. This is where transactions are stored before being packed in a block. In our current implementation, a block contains only one transaction, and this is quite inefficient.
   å†…å­˜æ± ã€‚åœ¨å°†äº‹åŠ¡æ‰“åŒ…åˆ°ä¸€ä¸ªåŒºå—ä¹‹å‰ï¼Œäº‹åŠ¡å°±å­˜å‚¨åœ¨è¿™é‡Œã€‚åœ¨æˆ‘ä»¬ç›®å‰çš„å®ç°ä¸­ï¼Œä¸€ä¸ªåŒºå—åªåŒ…å«ä¸€ä¸ªäº‹åŠ¡ï¼Œæ•ˆç‡éå¸¸ä½ã€‚

Links: é“¾æ¥

1. [Full source codes å®Œæ•´æºä»£ç ](https://github.com/Jeiwan/blockchain_go/tree/part_4)
2. [Transaction äº¤æ˜“](https://en.bitcoin.it/wiki/Transaction)
3. [Merkle tree æ¢…å…‹å°”æ ‘](https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees)
4. [Coinbase](https://en.bitcoin.it/wiki/Coinbase)



## Building Blockchain in Go. Part 5: Addresses

11 Sep 2017

> Chinese translations: [by liuchengxu](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-5/address.md), [by zhangli1](https://zhangli1.gitbooks.io/dummies-for-blockchain/content/)
> ä¸­æ–‡ç¿»è¯‘ï¼šåˆ˜æˆæ—­ã€å¼ è‰1

### Introduction å¯¼è¨€

In [the previous article](https://jeiwan.net/posts/building-blockchain-in-go-part-4/), we started implementing transactions. You were also introduced to the impersonal nature of transactions: there are no user accounts, your personal data (e.g., name, passport number or SSN) is not required and not stored anywhere in Bitcoin. But there still must be something that identifies you as the owner of transaction outputs (i.e. the owner of coins locked on these outputs). And this is what Bitcoin addresses are needed for. So far weâ€™ve used arbitrary user defined strings as addresses, and the time has come to implement real addresses, as theyâ€™re implemented in Bitcoin.
åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å¼€å§‹å®æ–½äº¤æ˜“ã€‚æˆ‘ä»¬ä¹Ÿå‘æ‚¨ä»‹ç»äº†äº¤æ˜“çš„éä¸ªäººæ€§è´¨ï¼šæ²¡æœ‰ç”¨æˆ·è´¦æˆ·ï¼Œæ‚¨çš„ä¸ªäººæ•°æ®ï¼ˆå¦‚å§“åã€æŠ¤ç…§å·ç æˆ– SSNï¼‰ä¸éœ€è¦ï¼Œä¹Ÿä¸ä¼šå­˜å‚¨åœ¨æ¯”ç‰¹å¸ä¸­çš„ä»»ä½•åœ°æ–¹ã€‚ä½†æ˜¯ï¼Œä»ç„¶å¿…é¡»æœ‰ä¸€äº›ä¸œè¥¿å¯ä»¥ç¡®å®šä½ æ˜¯äº¤æ˜“è¾“å‡ºçš„æ‰€æœ‰è€…ï¼ˆå³é”å®šåœ¨è¿™äº›è¾“å‡ºä¸Šçš„å¸çš„æ‰€æœ‰è€…ï¼‰ã€‚è¿™å°±æ˜¯æ¯”ç‰¹å¸åœ°å€çš„ä½œç”¨ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä½¿ç”¨ä»»æ„ç”¨æˆ·å®šä¹‰çš„å­—ç¬¦ä¸²ä½œä¸ºåœ°å€ï¼Œç°åœ¨æ˜¯æ—¶å€™å®ç°çœŸæ­£çš„åœ°å€äº†ï¼Œå°±åƒåœ¨æ¯”ç‰¹å¸ä¸­å®ç°çš„é‚£æ ·ã€‚

> This part introduces significant code changes, so it makes no sense explaining all of them here. Please refer to [this page](https://github.com/Jeiwan/blockchain_go/compare/part_4...part_5#files_bucket) to see all the changes since the last article.
> æœ¬éƒ¨åˆ†å¼•å…¥äº†é‡è¦çš„ä»£ç æ›´æ”¹ï¼Œå› æ­¤åœ¨æ­¤æ— æ³•ä¸€ä¸€è§£é‡Šã€‚è¯·å‚é˜…æœ¬é¡µï¼ŒæŸ¥çœ‹è‡ªä¸Šä¸€ç¯‡æ–‡ç« ä»¥æ¥çš„æ‰€æœ‰æ›´æ”¹ã€‚

### Bitcoin Address æ¯”ç‰¹å¸åœ°å€

Hereâ€™s an example of a Bitcoin address: [1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa](https://blockchain.info/address/1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa). This is the very first Bitcoin address, which allegedly belongs to Satoshi Nakamoto. Bitcoin addresses are public. If you want to send coins to someone, you need to know their address. But addresses (despite being unique) are not something that identifies you as the owner of a â€œwalletâ€. In fact, such addresses are a human readable representation of public keys. In Bitcoin, your identity is a pair (or pairs) of private and public keys stored on your computer (or stored in some other place you have access to). Bitcoin relies on a combination of cryptography algorithms to create these keys, and guarantee that no one else in the world can access your coins without getting physical access to your keys. Letâ€™s discuss what these algorithms are.
ä¸‹é¢æ˜¯ä¸€ä¸ªæ¯”ç‰¹å¸åœ°å€çš„ä¾‹å­ï¼š1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa.è¿™æ˜¯ç¬¬ä¸€ä¸ªæ¯”ç‰¹å¸åœ°å€ï¼Œæ®ç§°å±äºä¸­æœ¬èªã€‚æ¯”ç‰¹å¸åœ°å€æ˜¯å…¬å¼€çš„ã€‚å¦‚æœä½ æƒ³ç»™æŸäººå‘é€æ¯”ç‰¹å¸ï¼Œä½ éœ€è¦çŸ¥é“ä»–çš„åœ°å€ã€‚ä½†æ˜¯ï¼Œåœ°å€ï¼ˆå°½ç®¡æ˜¯å”¯ä¸€çš„ï¼‰å¹¶ä¸èƒ½è¯æ˜ä½ æ˜¯ "é’±åŒ… "çš„æ‰€æœ‰è€…ã€‚äº‹å®ä¸Šï¼Œè¿™ç§åœ°å€æ˜¯å…¬é’¥çš„äººå¯è¯»è¡¨ç¤ºã€‚åœ¨æ¯”ç‰¹å¸ä¸­ï¼Œä½ çš„èº«ä»½æ˜¯ä¸€å¯¹ï¼ˆæˆ–å¤šå¯¹ï¼‰ç§é’¥å’Œå…¬é’¥ï¼Œå®ƒä»¬å­˜å‚¨åœ¨ä½ çš„ç”µè„‘ä¸­ï¼ˆæˆ–å­˜å‚¨åœ¨ä½ å¯ä»¥è®¿é—®çš„å…¶ä»–åœ°æ–¹ï¼‰ã€‚æ¯”ç‰¹å¸ä¾é å¯†ç å­¦ç®—æ³•çš„ç»„åˆæ¥åˆ›å»ºè¿™äº›å¯†é’¥ï¼Œå¹¶ä¿è¯ä¸–ç•Œä¸Šæ²¡æœ‰å…¶ä»–äººå¯ä»¥åœ¨ä¸å®é™…æ¥è§¦åˆ°ä½ çš„å¯†é’¥çš„æƒ…å†µä¸‹æ¥è§¦åˆ°ä½ çš„å¸ã€‚è®©æˆ‘ä»¬æ¥è®¨è®ºä¸€ä¸‹è¿™äº›ç®—æ³•æ˜¯ä»€ä¹ˆã€‚

### Public-key Cryptography å…¬é’¥å¯†ç å­¦

Public-key cryptography algorithms use pairs of keys: public keys and private keys. Public keys are not sensitive and can be disclosed to anyone. In contrast, private keys shouldnâ€™t be disclosed: no one but the owner should have access to them because itâ€™s private keys that serve as the identifier of the owner. You are your private keys (in the world of cryptocurrencies, of course).
å…¬é’¥åŠ å¯†ç®—æ³•ä½¿ç”¨æˆå¯¹çš„å¯†é’¥ï¼šå…¬é’¥å’Œç§é’¥ã€‚å…¬å¼€å¯†é’¥å¹¶ä¸æ•æ„Ÿï¼Œå¯ä»¥å‘ä»»ä½•äººå…¬å¼€ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œç§é’¥åˆ™ä¸åº”è¯¥å…¬å¼€ï¼šé™¤äº†æ‰€æœ‰è€…ï¼Œä»»ä½•äººéƒ½ä¸åº”è¯¥è·å–ç§é’¥ï¼Œå› ä¸ºç§é’¥æ˜¯æ‰€æœ‰è€…çš„èº«ä»½æ ‡è¯†ã€‚ä½ å°±æ˜¯ä½ çš„ç§äººå¯†é’¥ï¼ˆå½“ç„¶æ˜¯åœ¨åŠ å¯†è´§å¸çš„ä¸–ç•Œé‡Œï¼‰ã€‚

In essence, a Bitcoin wallet is just a pair of such keys. When you install a wallet application or use a Bitcoin client to generate a new address, a pair of keys is generated for you. The one who controls the private key controls all the coins sent to this key in Bitcoin.
ä»æœ¬è´¨ä¸Šè®²ï¼Œæ¯”ç‰¹å¸é’±åŒ…å°±æ˜¯ä¸€å¯¹è¿™æ ·çš„å¯†é’¥ã€‚å½“ä½ å®‰è£…ä¸€ä¸ªé’±åŒ…åº”ç”¨ç¨‹åºæˆ–ä½¿ç”¨æ¯”ç‰¹å¸å®¢æˆ·ç«¯ç”Ÿæˆä¸€ä¸ªæ–°åœ°å€æ—¶ï¼Œå°±ä¼šä¸ºä½ ç”Ÿæˆä¸€å¯¹å¯†é’¥ã€‚è°æ§åˆ¶äº†ç§é’¥ï¼Œè°å°±æ§åˆ¶äº†æ¯”ç‰¹å¸ä¸­å‘é€åˆ°è¿™ä¸ªç§é’¥çš„æ‰€æœ‰å¸ã€‚

Private and public keys are just random sequences of bytes, thus they cannot be printed on the screen and read by a human. Thatâ€™s why Bitcoin uses an algorithm to convert public keys into a human readable string.
ç§é’¥å’Œå…¬é’¥åªæ˜¯éšæœºçš„å­—èŠ‚åºåˆ—ï¼Œå› æ­¤æ— æ³•æ‰“å°åœ¨å±å¹•ä¸Šï¼Œä¹Ÿæ— æ³•è¢«äººç±»è¯»å–ã€‚è¿™å°±æ˜¯æ¯”ç‰¹å¸ä½¿ç”¨ç®—æ³•å°†å…¬é’¥è½¬æ¢æˆäººç±»å¯è¯»å­—ç¬¦ä¸²çš„åŸå› ã€‚

> If youâ€™ve ever used a Bitcoin wallet application, itâ€™s likely that a mnemonic pass phrase was generated for you. Such phrases are used instead of private keys and can be used to generate them. This mechanism is implemented in [BIP-039](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).
> å¦‚æœä½ æ›¾ç»ä½¿ç”¨è¿‡æ¯”ç‰¹å¸é’±åŒ…åº”ç”¨ç¨‹åºï¼Œå¾ˆå¯èƒ½ä¼šä¸ºä½ ç”Ÿæˆä¸€ä¸ªåŠ©è®°é€šè¡ŒçŸ­è¯­ã€‚è¿™ç§çŸ­è¯­å¯ä»¥ç”¨æ¥ä»£æ›¿ç§é’¥ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥ç”Ÿæˆç§é’¥ã€‚BIP-039 å®ç°äº†è¿™ç§æœºåˆ¶ã€‚

Ok, we now know what identifies users in Bitcoin. But how does Bitcoin check the ownership of transaction outputs (and coins stored on them)?
å¥½äº†ï¼Œæˆ‘ä»¬ç°åœ¨çŸ¥é“äº†ä»€ä¹ˆæ˜¯æ¯”ç‰¹å¸ç”¨æˆ·çš„èº«ä»½è¯†åˆ«ã€‚ä½†æ˜¯ï¼Œæ¯”ç‰¹å¸å¦‚ä½•æ£€æŸ¥äº¤æ˜“è¾“å‡ºï¼ˆä»¥åŠå­˜å‚¨åœ¨äº¤æ˜“è¾“å‡ºä¸Šçš„å¸ï¼‰çš„æ‰€æœ‰æƒå‘¢ï¼Ÿ

### Digital Signatures æ•°å­—ç­¾å

In mathematics and cryptography, thereâ€™s a concept of digital signature â€“ algorithms that guarantee:
åœ¨æ•°å­¦å’Œå¯†ç å­¦ä¸­ï¼Œæœ‰ä¸€ä¸ªæ•°å­—ç­¾åçš„æ¦‚å¿µï¼Œå³ä¿è¯æ•°å­—ç­¾åçš„ç®—æ³•ï¼š

1. that data wasnâ€™t modified while being transferred from a sender to a recipient;
   ç¡®ä¿æ•°æ®åœ¨ä»å‘ä»¶äººä¼ è¾“åˆ°æ”¶ä»¶äººçš„è¿‡ç¨‹ä¸­æ²¡æœ‰è¢«ä¿®æ”¹ï¼›
2. that data was created by a certain sender;
   è¯¥æ•°æ®æ˜¯ç”±æŸä¸ªå‘é€è€…åˆ›å»ºçš„ï¼›
3. that the sender cannot deny sending the data.
   å‘é€æ–¹ä¸èƒ½æ‹’ç»å‘é€æ•°æ®ã€‚

By applying a signing algorithm to data (i.e., signing the data), one gets a signature, which can later be verified. Digital signing happens with the usage of a private key, and verification requires a public key.
é€šè¿‡å¯¹æ•°æ®åº”ç”¨ç­¾åç®—æ³•ï¼ˆå³å¯¹æ•°æ®è¿›è¡Œç­¾åï¼‰ï¼Œå¯ä»¥å¾—åˆ°ä¸€ä¸ªç­¾åï¼Œéšåå¯ä»¥å¯¹å…¶è¿›è¡ŒéªŒè¯ã€‚æ•°å­—ç­¾åéœ€è¦ä½¿ç”¨ç§é’¥ï¼Œè€ŒéªŒè¯åˆ™éœ€è¦ä½¿ç”¨å…¬é’¥ã€‚

In order to sign data we need the following things:
ä¸ºäº†ç­¾ç½²æ•°æ®ï¼Œæˆ‘ä»¬éœ€è¦ä»¥ä¸‹ä¸œè¥¿ï¼š

1. data to sign; ç­¾ç½²æ•°æ®ï¼›
2. private key. ç§é’¥ã€‚

The operation of signing produces a signature, which is stored in transaction inputs. In order to verify a signature, the following is required:
ç­¾åæ“ä½œäº§ç”Ÿä¸€ä¸ªç­¾åï¼Œå­˜å‚¨åœ¨äº¤æ˜“è¾“å…¥ä¸­ã€‚è¦éªŒè¯ç­¾åï¼Œéœ€è¦æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š

1. data that was signed;
   å·²ç­¾ç½²çš„æ•°æ®ï¼›
2. the signature; ç­¾åï¼›
3. public key. å…¬å…±å¯†é’¥ã€‚

In simple terms, the verification process can be described as: check that this signature was obtained from this data with a private key used to generate the public key.
ç®€å•æ¥è¯´ï¼ŒéªŒè¯è¿‡ç¨‹å¯ä»¥æè¿°ä¸ºï¼šæ£€æŸ¥è¯¥ç­¾åæ˜¯å¦æ˜¯ç”¨ç”Ÿæˆå…¬é’¥çš„ç§é’¥ä»è¯¥æ•°æ®ä¸­è·å–çš„ã€‚

> Digital signatures are not encryption, you cannot reconstruct the data from a signature. This is similar to hashing: you run data through a hashing algorithm and get a unique representation of the data. The difference between signatures and hashes is key pairs: they make signature verification possible.
> æ•°å­—ç­¾åä¸æ˜¯åŠ å¯†ï¼Œä½ æ— æ³•æ ¹æ®ç­¾åé‡å»ºæ•°æ®ã€‚è¿™ä¸å“ˆå¸Œç®—æ³•ç±»ä¼¼ï¼šé€šè¿‡å“ˆå¸Œç®—æ³•è¿è¡Œæ•°æ®ï¼Œå¯ä»¥å¾—åˆ°æ•°æ®çš„å”¯ä¸€è¡¨ç¤ºã€‚ç­¾åä¸å“ˆå¸Œç®—æ³•çš„åŒºåˆ«åœ¨äºå¯†é’¥å¯¹ï¼šå¯†é’¥å¯¹ä½¿ç­¾åéªŒè¯æˆä¸ºå¯èƒ½ã€‚
> But key pairs can also be used to encrypt data: a private key is used to encrypt, and a public key is used to decrypt the data. Bitcoin doesnâ€™t use encryption algorithms though.
> ä½†æ˜¯å¯†é’¥å¯¹ä¹Ÿå¯ä»¥ç”¨æ¥åŠ å¯†æ•°æ®ï¼šç§é’¥ç”¨æ¥åŠ å¯†ï¼Œå…¬é’¥ç”¨æ¥è§£å¯†ã€‚ä½†æ¯”ç‰¹å¸ä¸ä½¿ç”¨åŠ å¯†ç®—æ³•ã€‚

Every transaction input in Bitcoin is signed by the one who created the transaction. Every transaction in Bitcoin must be verified before being put in a block. Verification means (besides other procedures):
åœ¨æ¯”ç‰¹å¸ä¸­è¾“å…¥çš„æ¯ä¸€ç¬”äº¤æ˜“éƒ½ç”±åˆ›å»ºäº¤æ˜“çš„äººç­¾åã€‚æ¯”ç‰¹å¸ä¸­çš„æ¯ç¬”äº¤æ˜“éƒ½å¿…é¡»ç»è¿‡éªŒè¯ï¼Œæ‰èƒ½æ”¾å…¥åŒºå—ä¸­ã€‚éªŒè¯æ„å‘³ç€ï¼ˆé™¤å…¶ä»–ç¨‹åºå¤–ï¼‰ï¼š

1. Checking that inputs have permission to use outputs from previous transactions.
   æ£€æŸ¥è¾“å…¥æ˜¯å¦å…è®¸ä½¿ç”¨ä»¥å‰äº¤æ˜“çš„è¾“å‡ºã€‚
2. Checking that the transaction signature is correct.
   æ£€æŸ¥äº¤æ˜“ç­¾åæ˜¯å¦æ­£ç¡®ã€‚

Schematically, the process of signing data and verifying signature looks likes this:
ä»åŸç†ä¸Šè®²ï¼Œç­¾ç½²æ•°æ®å’ŒéªŒè¯ç­¾åçš„è¿‡ç¨‹æ˜¯è¿™æ ·çš„ï¼š

![Digital Signatures](https://jeiwan.net/images/signing-scheme.png)

Letâ€™s now review the full lifecycle of a transaction:
ç°åœ¨è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹äº¤æ˜“çš„æ•´ä¸ªç”Ÿå‘½å‘¨æœŸï¼š

1. In the beginning, thereâ€™s the genesis block that contains a coinbase transaction. There are no real inputs in coinbase transactions, so signing is not necessary. The output of the coinbase transaction contains a hashed public key (`RIPEMD16(SHA256(PubKey))` algorithms are used).
   ä¸€å¼€å§‹ï¼Œåˆ›ä¸–åŒºå—åŒ…å«äº†ä¸€ä¸ªå¸å®‰äº¤æ˜“ã€‚å¸å®‰äº¤æ˜“ä¸­æ²¡æœ‰çœŸæ­£çš„è¾“å…¥ï¼Œå› æ­¤æ— éœ€ç­¾åã€‚Coinbase äº¤æ˜“çš„è¾“å‡ºåŒ…å«å“ˆå¸Œå…¬é’¥ï¼ˆä½¿ç”¨ `RIPEMD16(SHA256(PubKey))` ç®—æ³•ï¼‰ã€‚
2. When one sends coins, a transaction is created. Inputs of the transaction will reference outputs from previous transaction(s). Every input will store a public key (not hashed) and a signature of the whole transaction.
   å½“ä¸€ä¸ªäººå‘é€ç¡¬å¸æ—¶ï¼Œå°±åˆ›å»ºäº†ä¸€ä¸ªäº¤æ˜“ã€‚äº¤æ˜“çš„è¾“å…¥å°†å‚è€ƒä¹‹å‰äº¤æ˜“çš„è¾“å‡ºã€‚æ¯ä¸ªè¾“å…¥å°†å­˜å‚¨ä¸€ä¸ªå…¬é’¥ï¼ˆéæ•£åˆ—ï¼‰å’Œæ•´ä¸ªäº¤æ˜“çš„ç­¾åã€‚
3. Other nodes in the Bitcoin network that receive the transaction will verify it. Besides other things, they will check that: the hash of the public key in an input matches the hash of the referenced output (this ensures that the sender spends only coins belonging to them); the signature is correct (this ensures that the transaction is created by the real owner of the coins).
   æ¯”ç‰¹å¸ç½‘ç»œä¸­çš„å…¶ä»–èŠ‚ç‚¹æ”¶åˆ°äº¤æ˜“åä¼šè¿›è¡ŒéªŒè¯ã€‚é™¤å…¶ä»–äº‹é¡¹å¤–ï¼Œå®ƒä»¬è¿˜å°†æ£€æŸ¥ï¼šè¾“å…¥ä¸­å…¬é’¥çš„å“ˆå¸Œå€¼æ˜¯å¦ä¸å¼•ç”¨è¾“å‡ºçš„å“ˆå¸Œå€¼ç›¸åŒ¹é…ï¼ˆè¿™å¯ç¡®ä¿å‘é€è€…åªä½¿ç”¨å±äºè‡ªå·±çš„ç¡¬å¸ï¼‰ï¼›ç­¾åæ˜¯å¦æ­£ç¡®ï¼ˆè¿™å¯ç¡®ä¿äº¤æ˜“æ˜¯ç”±ç¡¬å¸çš„çœŸæ­£æ‰€æœ‰è€…åˆ›å»ºçš„ï¼‰ã€‚
4. When a miner node is ready to mine a new block, itâ€™ll put the transaction in a block and start mining it.
   å½“çŸ¿å·¥èŠ‚ç‚¹å‡†å¤‡å¥½å¼€é‡‡ä¸€ä¸ªæ–°åŒºå—æ—¶ï¼Œå®ƒå°±ä¼šå°†äº¤æ˜“æ”¾å…¥ä¸€ä¸ªåŒºå—å¹¶å¼€å§‹å¼€é‡‡ã€‚
5. When the blocked is mined, every other node in the network receives a message saying the block is mined and adds the block to the blockchain.
   å½“åŒºå—è¢«æŒ–å‡ºæ—¶ï¼Œç½‘ç»œä¸­çš„å…¶ä»–èŠ‚ç‚¹éƒ½ä¼šæ”¶åˆ°ä¸€æ¡ä¿¡æ¯ï¼Œè¯´æ˜è¯¥åŒºå—å·²è¢«æŒ–å‡ºï¼Œå¹¶å°†è¯¥åŒºå—æ·»åŠ åˆ°åŒºå—é“¾ä¸­ã€‚
6. After a block is added to the blockchain, the transaction is completed, its outputs can be referenced in new transactions.
   ä¸€ä¸ªåŒºå—æ·»åŠ åˆ°åŒºå—é“¾åï¼Œäº¤æ˜“å°±å®Œæˆäº†ï¼Œå…¶è¾“å‡ºå¯ä»¥åœ¨æ–°çš„äº¤æ˜“ä¸­è¢«å¼•ç”¨ã€‚

### Elliptic Curve Cryptography æ¤­åœ†æ›²çº¿å¯†ç å­¦

As described above, public and private keys are sequences of random bytes. Since itâ€™s private keys that are used to identify owners of coins, thereâ€™s a required condition: the randomness algorithm must produce truly random bytes. We donâ€™t want to accidentally generate a private key thatâ€™s owned by someone else.
å¦‚ä¸Šæ‰€è¿°ï¼Œå…¬é’¥å’Œç§é’¥éƒ½æ˜¯éšæœºå­—èŠ‚åºåˆ—ã€‚ç”±äºç§é’¥æ˜¯ç”¨æ¥è¯†åˆ«ç¡¬å¸æ‰€æœ‰è€…çš„ï¼Œå› æ­¤æœ‰ä¸€ä¸ªå¿…è¦æ¡ä»¶ï¼šéšæœºæ€§ç®—æ³•å¿…é¡»äº§ç”ŸçœŸæ­£çš„éšæœºå­—èŠ‚ã€‚æˆ‘ä»¬å¯ä¸æƒ³æ„å¤–ç”Ÿæˆä¸€æŠŠåˆ«äººæ‹¥æœ‰çš„ç§é’¥ã€‚

Bitcoin uses elliptic curves to generate private keys. Elliptic curves is a complex mathematical concept, which weâ€™re not going to explain in details here (if youâ€™re curious, check out [this gentle introduction to elliptic curves](http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/) WARNING: Math formulas!). What we need to know is that these curves can be used to generate really big and random numbers. The curve used by Bitcoin can randomly pick a number between 0 and 2Â²âµâ¶ (which is approximately 10â·â·, when there are between 10â·â¸ and 10â¸Â² atoms in the visible universe). Such a huge upper limit means that itâ€™s almost impossible to generate the same private key twice.
æ¯”ç‰¹å¸ä½¿ç”¨æ¤­åœ†æ›²çº¿ç”Ÿæˆç§é’¥ã€‚æ¤­åœ†æ›²çº¿æ˜¯ä¸€ä¸ªå¤æ‚çš„æ•°å­¦æ¦‚å¿µï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œå°±ä¸è¯¦ç»†è§£é‡Šäº†ï¼ˆå¦‚æœä½ å¥½å¥‡ï¼Œå¯ä»¥çœ‹çœ‹è¿™ç¯‡å…³äºæ¤­åœ†æ›²çº¿çš„æ¸©å’Œä»‹ç»ï¼Œè­¦å‘Šï¼šæ•°å­¦å…¬å¼ï¼ï¼‰ã€‚æˆ‘ä»¬éœ€è¦çŸ¥é“çš„æ˜¯ï¼Œè¿™äº›æ›²çº¿å¯ä»¥ç”¨æ¥ç”Ÿæˆéå¸¸å¤§çš„éšæœºæ•°ã€‚æ¯”ç‰¹å¸ä½¿ç”¨çš„æ›²çº¿å¯ä»¥éšæœºé€‰æ‹© 0 åˆ° 2Â²âµâ¶ ä¹‹é—´çš„æ•°å­—ï¼ˆçº¦ç­‰äº 10â·â·ï¼Œè€Œå¯è§å®‡å®™ä¸­çš„åŸå­æ•°é‡åœ¨ 10â·â¸ å’Œ 10â¸Â² ä¹‹é—´ï¼‰ã€‚å¦‚æ­¤å¤§çš„ä¸Šé™æ„å‘³ç€å‡ ä¹ä¸å¯èƒ½ç”Ÿæˆä¸¤æ¬¡ç›¸åŒçš„ç§é’¥ã€‚

Also, Bitcoin uses (and we will) ECDSA (Elliptic Curve Digital Signature Algorithm) algorithm to sign transactions.
æ­¤å¤–ï¼Œæ¯”ç‰¹å¸ä½¿ç”¨ï¼ˆæˆ‘ä»¬ä¹Ÿå°†ä½¿ç”¨ï¼‰ECDSAï¼ˆæ¤­åœ†æ›²çº¿æ•°å­—ç­¾åç®—æ³•ï¼‰æ¥ç­¾ç½²äº¤æ˜“ã€‚

### Base58 åŸºåœ°58

Now letâ€™s get back to the above mentioned Bitcoin address: 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa. Now we know that this is a human-readable representation of a public key. And if we decode it, hereâ€™s what the public key looks like (as a sequence of bytes written in the hexadecimal system):
ç°åœ¨è®©æˆ‘ä»¬å›åˆ°ä¸Šé¢æåˆ°çš„æ¯”ç‰¹å¸åœ°å€ï¼š1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa.ç°åœ¨æˆ‘ä»¬çŸ¥é“ï¼Œè¿™æ˜¯ä¸€ä¸ªå…¬é’¥çš„äººå¯è¯»è¡¨ç¤ºæ³•ã€‚å¦‚æœæˆ‘ä»¬å¯¹å…¶è¿›è¡Œè§£ç ï¼Œä¸‹é¢å°±æ˜¯å…¬é’¥çš„æ ·å­ï¼ˆä»¥åå…­è¿›åˆ¶å†™æˆçš„å­—èŠ‚åºåˆ—ï¼‰ï¼š

```shell
0062E907B15CBF27D5425399EBF6F0FB50EBB88F18C29B7D93
```

Bitcoin uses the Base58 algorithm to convert public keys into human readable format. The algorithm is very similar to famous Base64, but it uses shorter alphabet: some letters were removed from the alphabet to avoid some attacks that use letters similarity. Thus, there are no these symbols: 0 (zero), O (capital o), I (capital i), l (lowercase L), because they look similar. Also, there are no + and / symbols.
æ¯”ç‰¹å¸ä½¿ç”¨ Base58 ç®—æ³•å°†å…¬é’¥è½¬æ¢æˆäººç±»å¯è¯»çš„æ ¼å¼ã€‚è¯¥ç®—æ³•ä¸è‘—åçš„ Base64 ç®—æ³•éå¸¸ç›¸ä¼¼ï¼Œä½†å®ƒä½¿ç”¨çš„å­—æ¯è¡¨æ›´çŸ­ï¼šä»å­—æ¯è¡¨ä¸­åˆ é™¤äº†ä¸€äº›å­—æ¯ï¼Œä»¥é¿å…ä¸€äº›ä½¿ç”¨å­—æ¯ç›¸ä¼¼æ€§çš„æ”»å‡»ã€‚å› æ­¤ï¼Œæ²¡æœ‰è¿™äº›ç¬¦å·ï¼š0ï¼ˆé›¶ï¼‰ã€Oï¼ˆå¤§å†™ oï¼‰ã€Iï¼ˆå¤§å†™ iï¼‰ã€Lï¼ˆå°å†™ Lï¼‰ï¼Œå› ä¸ºå®ƒä»¬çœ‹èµ·æ¥å¾ˆç›¸ä¼¼ã€‚æ­¤å¤–ï¼Œä¹Ÿæ²¡æœ‰ + å’Œ / ç¬¦å·ã€‚

Letâ€™s schematically visualize the process of getting an address from a public key:
è®©æˆ‘ä»¬ç”¨ç¤ºæ„å›¾ç›´è§‚åœ°å±•ç¤ºä¸€ä¸‹ä»å…¬é’¥è·å–åœ°å€çš„è¿‡ç¨‹ï¼š

![Address Generation](https://jeiwan.net/images/address-generation-scheme.png)

Thus, the above mentioned decoded public key consists of three parts:
å› æ­¤ï¼Œä¸Šè¿°è§£ç åçš„å…¬å¼€å¯†é’¥ç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼š

```shell
Version  Public key hash                           Checksum
00       62E907B15CBF27D5425399EBF6F0FB50EBB88F18  C29B7D93
```

Since hashing functions are one way (i.e., they cannot be reversed), itâ€™s not possible to extract the public key from the hash. But we can check if a public key was used to get the hash by running it thought the save hash functions and comparing the hashes.
ç”±äºå“ˆå¸Œå‡½æ•°æ˜¯å•å‘çš„ï¼ˆå³æ— æ³•é€†è½¬ï¼‰ï¼Œå› æ­¤æ— æ³•ä»å“ˆå¸Œå€¼ä¸­æå–å…¬é’¥ã€‚ä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡è¿è¡Œä¿å­˜çš„å“ˆå¸Œå‡½æ•°å¹¶æ¯”è¾ƒå“ˆå¸Œå€¼æ¥æ£€æŸ¥æ˜¯å¦ä½¿ç”¨äº†å…¬é’¥è·å–å“ˆå¸Œå€¼ã€‚

Ok, now that we have all the pieces, letâ€™s write some code. Some of the concepts should be more clear when written in code.
å¥½äº†ï¼Œç°åœ¨æˆ‘ä»¬å·²ç»æŒæ¡äº†æ‰€æœ‰çš„çŸ¥è¯†ï¼Œè®©æˆ‘ä»¬æ¥å†™ä¸€äº›ä»£ç å§ã€‚æœ‰äº›æ¦‚å¿µç”¨ä»£ç å†™å‡ºæ¥ä¼šæ›´æ¸…æ¥šã€‚

### Implementing Addresses æ‰§è¡Œåœ°å€

Weâ€™ll start with the `Wallet` structure:
æˆ‘ä»¬å°†ä» `Wallet` ç»“æ„å¼€å§‹ï¼š

```go
type Wallet struct {
	PrivateKey ecdsa.PrivateKey
	PublicKey  []byte
}

type Wallets struct {
	Wallets map[string]*Wallet
}

func NewWallet() *Wallet {
	private, public := newKeyPair()
	wallet := Wallet{private, public}

	return &wallet
}

func newKeyPair() (ecdsa.PrivateKey, []byte) {
	curve := elliptic.P256()
	private, err := ecdsa.GenerateKey(curve, rand.Reader)
	pubKey := append(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...)

	return *private, pubKey
}
```

A wallet is nothing but a key pair. Weâ€™ll also need the `Wallets` type to keep a collection of wallets, save them to a file, and load them from it. In the construction function of `Wallet` a new key pair is generated. The `newKeyPair` function is straightforward: ECDSA is based on elliptic curves, so we need one. Next, a private key is generated using the curve, and a public key is generated from the private key. One thing to notice: in elliptic curve based algorithms, public keys are points on a curve. Thus, a public key is a combination of X, Y coordinates. In Bitcoin, these coordinates are concatenated and form a public key.
é’±åŒ…åªæ˜¯ä¸€ä¸ªå¯†é’¥å¯¹ã€‚æˆ‘ä»¬è¿˜éœ€è¦ `Wallets` ç±»å‹æ¥ä¿å­˜é’±åŒ…é›†åˆï¼Œå°†å®ƒä»¬ä¿å­˜åˆ°æ–‡ä»¶ä¸­ï¼Œå¹¶ä»æ–‡ä»¶ä¸­åŠ è½½å®ƒä»¬ã€‚åœ¨ `Wallet` çš„æ„é€ å‡½æ•°ä¸­ï¼Œä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„å¯†é’¥å¯¹ã€‚ `newKeyPair` å‡½æ•°éå¸¸ç®€å•ï¼šECDSA åŸºäºæ¤­åœ†æ›²çº¿ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ¤­åœ†æ›²çº¿ã€‚æ¥ä¸‹æ¥ï¼Œä½¿ç”¨æ¤­åœ†æ›²çº¿ç”Ÿæˆç§é’¥ï¼Œå†æ ¹æ®ç§é’¥ç”Ÿæˆå…¬é’¥ã€‚éœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼šåœ¨åŸºäºæ¤­åœ†æ›²çº¿çš„ç®—æ³•ä¸­ï¼Œå…¬é’¥æ˜¯æ›²çº¿ä¸Šçš„ç‚¹ã€‚å› æ­¤ï¼Œå…¬é’¥æ˜¯ Xã€Y åæ ‡çš„ç»„åˆã€‚åœ¨æ¯”ç‰¹å¸ä¸­ï¼Œè¿™äº›åæ ‡è¢«è¿æ¥èµ·æ¥ï¼Œå½¢æˆä¸€ä¸ªå…¬é’¥ã€‚

Now, letâ€™s generate an address:
ç°åœ¨ï¼Œè®©æˆ‘ä»¬ç”Ÿæˆä¸€ä¸ªåœ°å€ï¼š

```go
func (w Wallet) GetAddress() []byte {
	pubKeyHash := HashPubKey(w.PublicKey)

	versionedPayload := append([]byte{version}, pubKeyHash...)
	checksum := checksum(versionedPayload)

	fullPayload := append(versionedPayload, checksum...)
	address := Base58Encode(fullPayload)

	return address
}

func HashPubKey(pubKey []byte) []byte {
	publicSHA256 := sha256.Sum256(pubKey)

	RIPEMD160Hasher := ripemd160.New()
	_, err := RIPEMD160Hasher.Write(publicSHA256[:])
	publicRIPEMD160 := RIPEMD160Hasher.Sum(nil)

	return publicRIPEMD160
}

func checksum(payload []byte) []byte {
	firstSHA := sha256.Sum256(payload)
	secondSHA := sha256.Sum256(firstSHA[:])

	return secondSHA[:addressChecksumLen]
}
```

Here are the steps to convert a public key into a Base58 address:
ä»¥ä¸‹æ˜¯å°†å…¬é’¥è½¬æ¢ä¸º Base58 åœ°å€çš„æ­¥éª¤ï¼š

1. Take the public key and hash it twice with `RIPEMD160(SHA256(PubKey))` hashing algorithms.
   ä½¿ç”¨ `RIPEMD160(SHA256(PubKey))` å“ˆå¸Œç®—æ³•å¯¹å…¬é’¥è¿›è¡Œä¸¤æ¬¡å“ˆå¸Œã€‚
2. Prepend the version of the address generation algorithm to the hash.
   åœ¨å“ˆå¸Œå€¼å‰åŠ ä¸Šåœ°å€ç”Ÿæˆç®—æ³•çš„ç‰ˆæœ¬ã€‚
3. Calculate the checksum by hashing the result of step 2 with `SHA256(SHA256(payload))`. The checksum is the first four bytes of the resulted hash.
   ç”¨ `SHA256(SHA256(payload))` å¯¹æ­¥éª¤ 2 çš„ç»“æœè¿›è¡Œæ•£åˆ—ï¼Œè®¡ç®—æ ¡éªŒå’Œã€‚æ ¡éªŒå’Œæ˜¯æ•£åˆ—ç»“æœçš„å‰å››ä¸ªå­—èŠ‚ã€‚
4. Append the checksum to the `version+PubKeyHash` combination.
   å°†æ ¡éªŒå’Œé™„åŠ åˆ° `version+PubKeyHash` ç»„åˆä¸­ã€‚
5. Encode the `version+PubKeyHash+checksum` combination with Base58.
   ä½¿ç”¨ Base58 å¯¹ `version+PubKeyHash+checksum` ç»„åˆè¿›è¡Œç¼–ç ã€‚

As a result, youâ€™ll get a **real Bitcoin address**, you can even check its balance on [blockchain.info](https://blockchain.info/). But I can assure you that the balance is 0 no matter how many times you generate a new address and check its balance. This is why choosing proper public-key cryptography algorithm is so crucial: considering private keys are random numbers, the chance of generating the same number must be as low as possible. Ideally, it must be as low as â€œneverâ€.
è¿™æ ·ï¼Œä½ å°±ä¼šå¾—åˆ°ä¸€ä¸ªçœŸå®çš„æ¯”ç‰¹å¸åœ°å€ï¼Œä½ ç”šè‡³å¯ä»¥åœ¨ blockchain.info ä¸ŠæŸ¥çœ‹å®ƒçš„ä½™é¢ã€‚ä½†æˆ‘å¯ä»¥å‘ä½ ä¿è¯ï¼Œæ— è®ºä½ ç”Ÿæˆå¤šå°‘æ¬¡æ–°åœ°å€å¹¶æŸ¥çœ‹å…¶ä½™é¢ï¼Œä½™é¢éƒ½æ˜¯ 0ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆé€‰æ‹©åˆé€‚çš„å…¬é’¥åŠ å¯†ç®—æ³•å¦‚æ­¤é‡è¦ï¼šè€ƒè™‘åˆ°ç§é’¥æ˜¯éšæœºæ•°ï¼Œç”Ÿæˆç›¸åŒæ•°å­—çš„å‡ ç‡å¿…é¡»å°½å¯èƒ½ä½ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œå¿…é¡»ä½è‡³ "æ°¸è¿œä¸ä¼š"ã€‚

Also, pay attention that you donâ€™t need to connect to a Bitcoin node to get an address. The address generation algorithm utilizes a combination of open algorithms that are implemented in many programming languages and libraries.
å¦å¤–è¦æ³¨æ„çš„æ˜¯ï¼Œè·å–åœ°å€å¹¶ä¸éœ€è¦è¿æ¥åˆ°æ¯”ç‰¹å¸èŠ‚ç‚¹ã€‚åœ°å€ç”Ÿæˆç®—æ³•åˆ©ç”¨äº†å¤šç§å¼€æ”¾ç®—æ³•çš„ç»„åˆï¼Œè¿™äº›ç®—æ³•åœ¨è®¸å¤šç¼–ç¨‹è¯­è¨€å’Œç¨‹åºåº“ä¸­éƒ½èƒ½å®ç°ã€‚

Now we need to modify inputs and outputs for them to use addresses:
ç°åœ¨ï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹è¾“å…¥å’Œè¾“å‡ºï¼Œä»¥ä¾¿å®ƒä»¬ä½¿ç”¨åœ°å€ï¼š

```go
type TXInput struct {
	Txid      []byte
	Vout      int
	Signature []byte
	PubKey    []byte
}

func (in *TXInput) UsesKey(pubKeyHash []byte) bool {
	lockingHash := HashPubKey(in.PubKey)

	return bytes.Compare(lockingHash, pubKeyHash) == 0
}

type TXOutput struct {
	Value      int
	PubKeyHash []byte
}

func (out *TXOutput) Lock(address []byte) {
	pubKeyHash := Base58Decode(address)
	pubKeyHash = pubKeyHash[1 : len(pubKeyHash)-4]
	out.PubKeyHash = pubKeyHash
}

func (out *TXOutput) IsLockedWithKey(pubKeyHash []byte) bool {
	return bytes.Compare(out.PubKeyHash, pubKeyHash) == 0
}
```

Notice, that weâ€™re no longer using `ScriptPubKey` and `ScriptSig` fields, because weâ€™re not going to implement a scripting language. Instead, `ScriptSig` is split into `Signature` and `PubKey` fields, and `ScriptPubKey` is renamed to `PubKeyHash`. Weâ€™ll implement the same outputs locking/unlocking and inputs signing logics as in Bitcoin, but weâ€™ll do this in methods instead.
è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä¸å†ä½¿ç”¨ `ScriptPubKey` å’Œ `ScriptSig` å­—æ®µï¼Œå› ä¸ºæˆ‘ä»¬ä¸æ‰“ç®—å®ç°è„šæœ¬è¯­è¨€ã€‚å–è€Œä»£ä¹‹çš„æ˜¯ï¼Œ `ScriptSig` åˆ†æˆ `Signature` å’Œ `PubKey` ä¸¤ä¸ªå­—æ®µï¼Œ `ScriptPubKey` æ›´åä¸º `PubKeyHash` ã€‚æˆ‘ä»¬å°†å®ç°ä¸æ¯”ç‰¹å¸ç›¸åŒçš„è¾“å‡ºé”å®š/è§£é”å’Œè¾“å…¥ç­¾åé€»è¾‘ï¼Œä½†æˆ‘ä»¬å°†åœ¨æ–¹æ³•ä¸­å®ç°ã€‚

The `UsesKey` method checks that an input uses a specific key to unlock an output. Notice that inputs store raw public keys (i.e., not hashed), but the function takes a hashed one. `IsLockedWithKey` checks if provided public key hash was used to lock the output. This is a complementary function to `UsesKey`, and theyâ€™re both used in `FindUnspentTransactions` to build connections between transactions.
`UsesKey` æ–¹æ³•ä¼šæ£€æŸ¥è¾“å…¥æ˜¯å¦ä½¿ç”¨äº†ç‰¹å®šçš„å¯†é’¥æ¥è§£é”è¾“å‡ºã€‚è¯·æ³¨æ„ï¼Œè¾“å…¥å­˜å‚¨çš„æ˜¯åŸå§‹å…¬é’¥ï¼ˆå³æœªæ•£åˆ—ï¼‰ï¼Œè€Œå‡½æ•°ä½¿ç”¨çš„æ˜¯æ•£åˆ—å…¬é’¥ã€‚ `IsLockedWithKey` ä¼šæ£€æŸ¥æ‰€æä¾›çš„å…¬é’¥æ•£åˆ—å€¼æ˜¯å¦ç”¨äºé”å®šè¾“å‡ºã€‚è¿™æ˜¯ `UsesKey` çš„è¡¥å……å‡½æ•°ï¼Œå®ƒä»¬éƒ½åœ¨ `FindUnspentTransactions` ä¸­ç”¨äºå»ºç«‹äº‹åŠ¡ä¹‹é—´çš„è¿æ¥ã€‚

```
Lock` simply locks an output. When we send coins to someone, we know only their address, thus the function takes an address as the only argument. The address is then decoded and the public key hash is extracted from it and saved in the `PubKeyHash` field.
`Lock` åªéœ€é”å®šä¸€ä¸ªè¾“å‡ºã€‚å½“æˆ‘ä»¬å‘æŸäººå‘é€ç¡¬å¸æ—¶ï¼Œæˆ‘ä»¬åªçŸ¥é“ä»–çš„åœ°å€ï¼Œå› æ­¤å‡½æ•°å°†åœ°å€ä½œä¸ºå”¯ä¸€çš„å‚æ•°ã€‚ç„¶åå¯¹åœ°å€è¿›è¡Œè§£ç ï¼Œä»ä¸­æå–å…¬é’¥å“ˆå¸Œå€¼å¹¶ä¿å­˜åœ¨ å­—æ®µä¸­ã€‚ `PubKeyHash
```

Now, letâ€™s check that everything works correctly:
ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸‹ä¸€åˆ‡è¿è¡Œæ˜¯å¦æ­£å¸¸ï¼š

```shell
$ blockchain_go createwallet
Your new address: 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt

$ blockchain_go createwallet
Your new address: 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h

$ blockchain_go createwallet
Your new address: 1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy

$ blockchain_go createblockchain -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
0000005420fbfdafa00c093f56e033903ba43599fa7cd9df40458e373eee724d

Done!

$ blockchain_go getbalance -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
Balance of '13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt': 10

$ blockchain_go send -from 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -to 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -amount 5
2017/09/12 13:08:56 ERROR: Not enough funds

$ blockchain_go send -from 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -to 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -amount 6
00000019afa909094193f64ca06e9039849709f5948fbac56cae7b1b8f0ff162

Success!

$ blockchain_go getbalance -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
Balance of '13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt': 4

$ blockchain_go getbalance -address 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h
Balance of '15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h': 6

$ blockchain_go getbalance -address 1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy
Balance of '1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy': 0
```

Nice! Now letâ€™s implement transaction signatures.
ä¸é”™ï¼ç°åœ¨æˆ‘ä»¬æ¥å®ç°äº¤æ˜“ç­¾åã€‚

### Implementing Signatures å®æ–½ç­¾å

Transactions must be signed because this is the only way in Bitcoin to guarantee that one cannot spend coins belonging to someone else. If a signature is invalid, the transaction is considered invalid too and, thus, cannot be added to the blockchain.
äº¤æ˜“å¿…é¡»ç­¾åï¼Œå› ä¸ºåœ¨æ¯”ç‰¹å¸ä¸­ï¼Œåªæœ‰è¿™æ ·æ‰èƒ½ä¿è¯ä¸ä¼šèŠ±æ‰å±äºåˆ«äººçš„å¸ã€‚å¦‚æœç­¾åæ— æ•ˆï¼Œäº¤æ˜“ä¹Ÿå°†è¢«è§†ä¸ºæ— æ•ˆï¼Œå› æ­¤ä¸èƒ½æ·»åŠ åˆ°åŒºå—é“¾ä¸­ã€‚

We have all the pieces to implement transactions signing, except one thing: data to sign. What parts of a transaction are actually signed? Or a transaction is signed as a whole? Choosing data to sign is quite important. The thing is that data to be signed must contain information that identifies the data in a unique way. For example, it makes no sense signing just output values because such signature wonâ€™t consider the sender and the recipient.
æˆ‘ä»¬å·²ç»å…·å¤‡äº†å®ç°äº‹åŠ¡ç­¾åçš„æ‰€æœ‰è¦ç´ ï¼Œä½†è¿˜å·®ä¸€æ ·ä¸œè¥¿ï¼šéœ€è¦ç­¾åçš„æ•°æ®ã€‚äº¤æ˜“çš„å“ªäº›éƒ¨åˆ†éœ€è¦ç­¾åï¼Ÿè¿˜æ˜¯æ•´ä¸ªäº‹åŠ¡éƒ½è¦ç­¾åï¼Ÿé€‰æ‹©è¦ç­¾åçš„æ•°æ®ç›¸å½“é‡è¦ã€‚è¦ç­¾åçš„æ•°æ®å¿…é¡»åŒ…å«èƒ½ä»¥ç‹¬ç‰¹æ–¹å¼è¯†åˆ«æ•°æ®çš„ä¿¡æ¯ã€‚ä¾‹å¦‚ï¼Œåªç­¾ç½²è¾“å‡ºå€¼æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œå› ä¸ºè¿™æ ·çš„ç­¾åä¸ä¼šè€ƒè™‘å‘é€æ–¹å’Œæ¥æ”¶æ–¹ã€‚

Considering that transactions unlock previous outputs, redistribute their values, and lock new outputs, the following data must be signed:
è€ƒè™‘åˆ°äº‹åŠ¡ä¼šè§£é”å…ˆå‰çš„è¾“å‡ºã€é‡æ–°åˆ†é…å…¶å€¼å¹¶é”å®šæ–°çš„è¾“å‡ºï¼Œå› æ­¤å¿…é¡»å¯¹ä»¥ä¸‹æ•°æ®è¿›è¡Œç­¾åï¼š

1. Public key hashes stored in unlocked outputs. This identifies â€œsenderâ€ of a transaction.
   å­˜å‚¨åœ¨è§£é”è¾“å‡ºä¸­çš„å…¬é’¥å“ˆå¸Œå€¼ã€‚è¿™å¯ä»¥è¯†åˆ«äº¤æ˜“çš„ "å‘é€æ–¹"ã€‚
2. Public key hashes stored in new, locked, outputs. This identifies â€œrecipientâ€ of a transaction.
   å…¬é’¥å“ˆå¸Œå€¼å­˜å‚¨åœ¨æ–°çš„é”å®šè¾“å‡ºä¸­ã€‚è¿™å¯ä»¥è¯†åˆ«äº¤æ˜“çš„ "æ¥æ”¶è€…"ã€‚
3. Values of new outputs.
   æ–°äº§å‡ºçš„å€¼ã€‚

> In Bitcoin, locking/unlocking logic is stored in scripts, which are stored in `ScriptSig` and `ScriptPubKey` fields of inputs and outputs, respectively. Since Bitcoins allows different types of such scripts, it signs the whole content of `ScriptPubKey`.
> åœ¨æ¯”ç‰¹å¸ä¸­ï¼Œé”å®š/è§£é”é€»è¾‘å­˜å‚¨åœ¨è„šæœ¬ä¸­ï¼Œè„šæœ¬åˆ†åˆ«å­˜å‚¨åœ¨è¾“å…¥å’Œè¾“å‡ºçš„ `ScriptSig` å’Œ `ScriptPubKey` å­—æ®µä¸­ã€‚ç”±äºæ¯”ç‰¹å¸å…è®¸ä¸åŒç±»å‹çš„æ­¤ç±»è„šæœ¬ï¼Œå› æ­¤å®ƒå¯ä»¥å¯¹ `ScriptPubKey` çš„å…¨éƒ¨å†…å®¹è¿›è¡Œç­¾åã€‚

As you can see, we donâ€™t need to sign the public keys stored in inputs. Because of this, in Bitcoin, itâ€™s not a transaction thatâ€™s signed, but its trimmed copy with inputs storing `ScriptPubKey` from referenced outputs.
æ­£å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼Œæˆ‘ä»¬ä¸éœ€è¦ç­¾ç½²å­˜å‚¨åœ¨è¾“å…¥ä¸­çš„å…¬é’¥ã€‚æ­£å› ä¸ºå¦‚æ­¤ï¼Œåœ¨æ¯”ç‰¹å¸ä¸­ï¼Œè¢«ç­¾åçš„ä¸æ˜¯äº¤æ˜“ï¼Œè€Œæ˜¯å…¶ç»è¿‡ä¿®å‰ªçš„å‰¯æœ¬ï¼Œå…¶è¾“å…¥å­˜å‚¨äº†æ¥è‡ªå¼•ç”¨è¾“å‡ºçš„ `ScriptPubKey` ã€‚

> A detailed process of getting a trimmed transaction copy is described [here](https://en.bitcoin.it/wiki/File:Bitcoin_OpCheckSig_InDetail.png). Itâ€™s likely to be outdated, but I didnâ€™t manage to find a more reliable source of information.
> è¿™é‡Œæè¿°äº†è·å–ç»è¿‡ä¿®å‰ªçš„äº¤æ˜“å‰¯æœ¬çš„è¯¦ç»†è¿‡ç¨‹ã€‚è¿™å¾ˆå¯èƒ½å·²ç»è¿‡æ—¶ï¼Œä½†æˆ‘æ²¡æœ‰æ‰¾åˆ°æ›´å¯é çš„ä¿¡æ¯æ¥æºã€‚

Ok, it looks complicated, so letâ€™s start coding. Weâ€™ll start with the `Sign` method:
å¥½äº†ï¼Œçœ‹èµ·æ¥å¾ˆå¤æ‚ï¼Œè®©æˆ‘ä»¬å¼€å§‹ç¼–ç å§ã€‚æˆ‘ä»¬ä» `Sign` æ–¹æ³•å¼€å§‹ï¼š

```go
func (tx *Transaction) Sign(privKey ecdsa.PrivateKey, prevTXs map[string]Transaction) {
	if tx.IsCoinbase() {
		return
	}

	txCopy := tx.TrimmedCopy()

	for inID, vin := range txCopy.Vin {
		prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
		txCopy.Vin[inID].Signature = nil
		txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
		txCopy.ID = txCopy.Hash()
		txCopy.Vin[inID].PubKey = nil

		r, s, err := ecdsa.Sign(rand.Reader, &privKey, txCopy.ID)
		signature := append(r.Bytes(), s.Bytes()...)

		tx.Vin[inID].Signature = signature
	}
}
```

The method takes a private key and a map of previous transactions. As mentioned above, in order to sign a transaction, we need to access the outputs referenced in the inputs of the transaction, thus we need the transactions that store these outputs.
è¯¥æ–¹æ³•éœ€è¦ä¸€ä¸ªç§é’¥å’Œä¸€ä¸ªå…ˆå‰äº‹åŠ¡çš„æ˜ å°„ã€‚å¦‚ä¸Šæ‰€è¿°ï¼Œä¸ºäº†ç­¾ç½²äº‹åŠ¡ï¼Œæˆ‘ä»¬éœ€è¦è®¿é—®äº‹åŠ¡è¾“å…¥ä¸­å¼•ç”¨çš„è¾“å‡ºï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å­˜å‚¨è¿™äº›è¾“å‡ºçš„äº‹åŠ¡ã€‚

Letâ€™s review this method step by step:
è®©æˆ‘ä»¬é€æ­¥å›é¡¾ä¸€ä¸‹è¿™ç§æ–¹æ³•ï¼š

```go
if tx.IsCoinbase() {
	return
}
```

Coinbase transactions are not signed because there are no real inputs in them.
Coinbase äº¤æ˜“æ²¡æœ‰ç­¾åï¼Œå› ä¸ºå…¶ä¸­æ²¡æœ‰çœŸå®è¾“å…¥ã€‚

```go
txCopy := tx.TrimmedCopy()
```

A trimmed copy will be signed, not a full transaction:
å°†ç­¾ç½²ä¿®å‰ªè¿‡çš„å‰¯æœ¬ï¼Œè€Œä¸æ˜¯å®Œæ•´çš„äº¤æ˜“ï¼š

```go
func (tx *Transaction) TrimmedCopy() Transaction {
	var inputs []TXInput
	var outputs []TXOutput

	for _, vin := range tx.Vin {
		inputs = append(inputs, TXInput{vin.Txid, vin.Vout, nil, nil})
	}

	for _, vout := range tx.Vout {
		outputs = append(outputs, TXOutput{vout.Value, vout.PubKeyHash})
	}

	txCopy := Transaction{tx.ID, inputs, outputs}

	return txCopy
}
```

The copy will include all the inputs and outputs, but `TXInput.Signature` and `TXInput.PubKey` are set to nil.
å‰¯æœ¬å°†åŒ…æ‹¬æ‰€æœ‰è¾“å…¥å’Œè¾“å‡ºï¼Œä½† `TXInput.Signature` å’Œ `TXInput.PubKey` è®¾ç½®ä¸ºé›¶ã€‚

Next, we iterate over each input in the copy:
æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éå†å‰¯æœ¬ä¸­çš„æ¯ä¸ªè¾“å…¥ï¼š

```go
for inID, vin := range txCopy.Vin {
	prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
	txCopy.Vin[inID].Signature = nil
	txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
```

In each input, `Signature` is set to `nil` (just a double-check) and `PubKey` is set to the `PubKeyHash` of the referenced output. At this moment, all transactions but the current one are â€œemptyâ€, i.e. their `Signature` and `PubKey` fields are set to nil. Thus, **inputs are signed separately**, although this is not necessary for our application, but Bitcoin allows transactions to contain inputs referencing different addresses.
åœ¨æ¯ä¸ªè¾“å…¥ä¸­ï¼Œ `Signature` è®¾ç½®ä¸º `nil` ï¼ˆåªæ˜¯é‡å¤æ£€æŸ¥ï¼‰ï¼Œ `PubKey` è®¾ç½®ä¸ºå¼•ç”¨è¾“å‡ºçš„ `PubKeyHash` ã€‚æ­¤æ—¶ï¼Œé™¤å½“å‰äº¤æ˜“å¤–çš„æ‰€æœ‰äº¤æ˜“éƒ½æ˜¯ "ç©º "çš„ï¼Œå³å…¶ `Signature` å’Œ `PubKey` å­—æ®µè¢«è®¾ç½®ä¸ºé›¶ã€‚å› æ­¤ï¼Œè¾“å…¥æ˜¯å•ç‹¬ç­¾åçš„ï¼Œè™½ç„¶è¿™å¯¹æˆ‘ä»¬çš„åº”ç”¨æ¥è¯´ä¸æ˜¯å¿…é¡»çš„ï¼Œä½†æ¯”ç‰¹å¸å…è®¸äº¤æ˜“åŒ…å«å¼•ç”¨ä¸åŒåœ°å€çš„è¾“å…¥ã€‚

```go
	txCopy.ID = txCopy.Hash()
	txCopy.Vin[inID].PubKey = nil
```

The `Hash` method serializes the transaction and hashes it with the SHA-256 algorithm. The resulted hash is the data weâ€™re going to sign. After getting the hash we should reset the `PubKey` field, so it doesnâ€™t affect further iterations.
`Hash` æ–¹æ³•å°†äº‹åŠ¡åºåˆ—åŒ–ï¼Œå¹¶ä½¿ç”¨ SHA-256 ç®—æ³•å¯¹å…¶è¿›è¡Œæ•£åˆ—ã€‚æ•£åˆ—ç»“æœå°±æ˜¯æˆ‘ä»¬è¦ç­¾åçš„æ•°æ®ã€‚è·å–å“ˆå¸Œå€¼åï¼Œæˆ‘ä»¬åº”é‡ç½® `PubKey` å­—æ®µï¼Œä»¥å…å½±å“åç»­è¿­ä»£ã€‚

Now, the central piece:
ç°åœ¨æ˜¯ä¸­å¿ƒéƒ¨åˆ†ï¼š

```go
	r, s, err := ecdsa.Sign(rand.Reader, &privKey, txCopy.ID)
	signature := append(r.Bytes(), s.Bytes()...)

	tx.Vin[inID].Signature = signature
```

We sign `txCopy.ID` with `privKey`. An ECDSA signature is a pair of numbers, which we concatenate and store in the inputâ€™s `Signature` field.
æˆ‘ä»¬ä½¿ç”¨ `privKey` å¯¹ `txCopy.ID` è¿›è¡Œç­¾åã€‚ECDSA ç­¾åæ˜¯ä¸€å¯¹æ•°å­—ï¼Œæˆ‘ä»¬å°†å…¶è¿æ¥èµ·æ¥å¹¶å­˜å‚¨åœ¨è¾“å…¥çš„ `Signature` å­—æ®µä¸­ã€‚

Now, the verification function:
ç°åœ¨æ˜¯éªŒè¯åŠŸèƒ½ï¼š

```go
func (tx *Transaction) Verify(prevTXs map[string]Transaction) bool {
	txCopy := tx.TrimmedCopy()
	curve := elliptic.P256()

	for inID, vin := range tx.Vin {
		prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
		txCopy.Vin[inID].Signature = nil
		txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
		txCopy.ID = txCopy.Hash()
		txCopy.Vin[inID].PubKey = nil

		r := big.Int{}
		s := big.Int{}
		sigLen := len(vin.Signature)
		r.SetBytes(vin.Signature[:(sigLen / 2)])
		s.SetBytes(vin.Signature[(sigLen / 2):])

		x := big.Int{}
		y := big.Int{}
		keyLen := len(vin.PubKey)
		x.SetBytes(vin.PubKey[:(keyLen / 2)])
		y.SetBytes(vin.PubKey[(keyLen / 2):])

		rawPubKey := ecdsa.PublicKey{curve, &x, &y}
		if ecdsa.Verify(&rawPubKey, txCopy.ID, &r, &s) == false {
			return false
		}
	}

	return true
}
```

The method is quite straightforward. First, we need the same transaction copy:
æ–¹æ³•éå¸¸ç®€å•ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ç›¸åŒçš„äº‹åŠ¡å‰¯æœ¬ï¼š

```go
txCopy := tx.TrimmedCopy()
```

Next, weâ€™ll need the same curve that is used to generate key pairs:
æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸ç”Ÿæˆå¯†é’¥å¯¹ç›¸åŒçš„æ›²çº¿ï¼š

```go
curve := elliptic.P256()
```

Next, we check signature in each input:
æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ£€æŸ¥æ¯ä¸ªè¾“å…¥çš„ç­¾åï¼š

```go
for inID, vin := range tx.Vin {
	prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
	txCopy.Vin[inID].Signature = nil
	txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
	txCopy.ID = txCopy.Hash()
	txCopy.Vin[inID].PubKey = nil
```

This piece is identical to the one in the `Sign` method, because during verification we need the same data what was signed.
è¿™éƒ¨åˆ†å†…å®¹ä¸ `Sign` æ–¹æ³•ä¸­çš„å†…å®¹ç›¸åŒï¼Œå› ä¸ºåœ¨éªŒè¯è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ä¸ç­¾åç›¸åŒçš„æ•°æ®ã€‚

```go
	r := big.Int{}
	s := big.Int{}
	sigLen := len(vin.Signature)
	r.SetBytes(vin.Signature[:(sigLen / 2)])
	s.SetBytes(vin.Signature[(sigLen / 2):])

	x := big.Int{}
	y := big.Int{}
	keyLen := len(vin.PubKey)
	x.SetBytes(vin.PubKey[:(keyLen / 2)])
	y.SetBytes(vin.PubKey[(keyLen / 2):])
```

Here we unpack values stored in `TXInput.Signature` and `TXInput.PubKey`, since a signature is a pair of numbers and a public key is a pair of coordinates. We concatenated them earlier for storing, and now we need to unpack them to use in `crypto/ecdsa` functions.
åœ¨æ­¤ï¼Œæˆ‘ä»¬å°†è§£å‹å­˜å‚¨åœ¨ `TXInput.Signature` å’Œ `TXInput.PubKey` ä¸­çš„å€¼ï¼Œå› ä¸ºç­¾åæ˜¯ä¸€å¯¹æ•°å­—ï¼Œè€Œå…¬é’¥æ˜¯ä¸€å¯¹åæ ‡ã€‚æˆ‘ä»¬ä¹‹å‰å°†å®ƒä»¬è¿æ¥èµ·æ¥è¿›è¡Œå­˜å‚¨ï¼Œç°åœ¨æˆ‘ä»¬éœ€è¦å°†å®ƒä»¬è§£å‹ç¼©ï¼Œä»¥ä¾¿åœ¨ `crypto/ecdsa` å‡½æ•°ä¸­ä½¿ç”¨ã€‚

```go
	rawPubKey := ecdsa.PublicKey{curve, &x, &y}
	if ecdsa.Verify(&rawPubKey, txCopy.ID, &r, &s) == false {
		return false
	}
}

return true
```

Here it is: we create an `ecdsa.PublicKey` using the public key extracted from the input and execute `ecdsa.Verify` passing the signature extracted from the input. If all inputs are verified, return true; if at least one input fails verification, return false.
å°±æ˜¯è¿™æ ·ï¼šæˆ‘ä»¬ä½¿ç”¨ä»è¾“å…¥ä¸­æå–çš„å…¬é’¥åˆ›å»º `ecdsa.PublicKey` ï¼Œå¹¶é€šè¿‡ä»è¾“å…¥ä¸­æå–çš„ç­¾åæ‰§è¡Œ `ecdsa.Verify` ã€‚å¦‚æœæ‰€æœ‰è¾“å…¥éƒ½é€šè¿‡éªŒè¯ï¼Œåˆ™è¿”å› trueï¼›å¦‚æœè‡³å°‘æœ‰ä¸€ä¸ªè¾“å…¥æœªé€šè¿‡éªŒè¯ï¼Œåˆ™è¿”å› falseã€‚

Now, we need a function to obtain previous transactions. Since this requires interaction with the blockchain, weâ€™ll make it a method of `Blockchain`:
ç°åœ¨ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå‡½æ•°æ¥è·å–ä¹‹å‰çš„äº¤æ˜“ã€‚ç”±äºè¿™éœ€è¦ä¸åŒºå—é“¾äº¤äº’ï¼Œæˆ‘ä»¬å°†æŠŠå®ƒä½œä¸º `Blockchain` çš„ä¸€ä¸ªæ–¹æ³•ï¼š

```go
func (bc *Blockchain) FindTransaction(ID []byte) (Transaction, error) {
	bci := bc.Iterator()

	for {
		block := bci.Next()

		for _, tx := range block.Transactions {
			if bytes.Compare(tx.ID, ID) == 0 {
				return *tx, nil
			}
		}

		if len(block.PrevBlockHash) == 0 {
			break
		}
	}

	return Transaction{}, errors.New("Transaction is not found")
}

func (bc *Blockchain) SignTransaction(tx *Transaction, privKey ecdsa.PrivateKey) {
	prevTXs := make(map[string]Transaction)

	for _, vin := range tx.Vin {
		prevTX, err := bc.FindTransaction(vin.Txid)
		prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX
	}

	tx.Sign(privKey, prevTXs)
}

func (bc *Blockchain) VerifyTransaction(tx *Transaction) bool {
	prevTXs := make(map[string]Transaction)

	for _, vin := range tx.Vin {
		prevTX, err := bc.FindTransaction(vin.Txid)
		prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX
	}

	return tx.Verify(prevTXs)
}
```

These functions are simple: `FindTransaction` finds a transaction by ID (this requires iterating over all the blocks in the blockchain); `SignTransaction` takes a transaction, finds transactions it references, and signs it; `VerifyTransaction` does the same, but verifies the transaction instead.
è¿™äº›å‡½æ•°éå¸¸ç®€å•ï¼š `FindTransaction` é€šè¿‡ ID æŸ¥æ‰¾äº¤æ˜“ï¼ˆè¿™éœ€è¦éå†åŒºå—é“¾ä¸­çš„æ‰€æœ‰åŒºå—ï¼‰ï¼› `SignTransaction` è·å–äº¤æ˜“ï¼ŒæŸ¥æ‰¾å®ƒæ‰€å¼•ç”¨çš„äº¤æ˜“ï¼Œå¹¶å¯¹å…¶è¿›è¡Œç­¾åï¼› `VerifyTransaction` æ‰§è¡Œç›¸åŒçš„æ“ä½œï¼Œä½†å¯¹äº¤æ˜“è¿›è¡ŒéªŒè¯ã€‚

Now, we need to actually sign and verify transactions. Signing happens in the `NewUTXOTransaction`:
ç°åœ¨ï¼Œæˆ‘ä»¬éœ€è¦å®é™…ç­¾ç½²å’ŒéªŒè¯äº¤æ˜“ã€‚ç­¾åå‘ç”Ÿåœ¨ `NewUTXOTransaction` .NETï¼š

```go
func NewUTXOTransaction(from, to string, amount int, bc *Blockchain) *Transaction {
	...

	tx := Transaction{nil, inputs, outputs}
	tx.ID = tx.Hash()
	bc.SignTransaction(&tx, wallet.PrivateKey)

	return &tx
}
```

Verification happens before a transaction is put into a block:
éªŒè¯å‘ç”Ÿåœ¨äº¤æ˜“è¢«æ”¾å…¥åŒºå—ä¹‹å‰ï¼š

```go
func (bc *Blockchain) MineBlock(transactions []*Transaction) {
	var lastHash []byte

	for _, tx := range transactions {
		if bc.VerifyTransaction(tx) != true {
			log.Panic("ERROR: Invalid transaction")
		}
	}
	...
}
```

And thatâ€™s it! Letâ€™s check everything one more time:
å°±æ˜¯è¿™æ ·ï¼è®©æˆ‘ä»¬å†æ£€æŸ¥ä¸€éï¼š

```shell
$ blockchain_go createwallet
Your new address: 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR

$ blockchain_go createwallet
Your new address: 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab

$ blockchain_go createblockchain -address 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR
000000122348da06c19e5c513710340f4c307d884385da948a205655c6a9d008

Done!

$ blockchain_go send -from 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount 6
0000000f3dbb0ab6d56c4e4b9f7479afe8d5a5dad4d2a8823345a1a16cf3347b

Success!

$ blockchain_go getbalance -address 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR
Balance of '1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR': 4

$ blockchain_go getbalance -address 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab
Balance of '1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab': 6
```

Nothing is broken. Awesome!
æ²¡æœ‰ä»»ä½•ç ´æŸã€‚çœŸæ£’

Letâ€™s also comment out the `bc.SignTransaction(&tx, wallet.PrivateKey)` call in `NewUTXOTransaction` to ensure that unsigned transactions cannot be mined:
æˆ‘ä»¬è¿˜è¦æ³¨é‡Šæ‰ `NewUTXOTransaction` ä¸­çš„ `bc.SignTransaction(&tx, wallet.PrivateKey)` è°ƒç”¨ï¼Œä»¥ç¡®ä¿æœªç­¾åçš„äº¤æ˜“æ— æ³•è¢«æŒ–æ˜ï¼š

```go
func NewUTXOTransaction(from, to string, amount int, bc *Blockchain) *Transaction {
   ...
	tx := Transaction{nil, inputs, outputs}
	tx.ID = tx.Hash()
	// bc.SignTransaction(&tx, wallet.PrivateKey)

	return &tx
}
$ go install
$ blockchain_go send -from 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount 1
2017/09/12 16:28:15 ERROR: Invalid transaction
```

### Conclusion ç»“è®º

Itâ€™s really awesome that weâ€™ve got so far and implemented so many key features of Bitcoin! Weâ€™ve implemented almost everything outside networking, and in the next part, weâ€™ll finish transactions.
åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»å®ç°äº†æ¯”ç‰¹å¸çš„è®¸å¤šå…³é”®åŠŸèƒ½ï¼Œè¿™çœŸæ˜¯å¤ªæ£’äº†ï¼åœ¨ä¸‹ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†å®Œæˆäº¤æ˜“ã€‚

Links: é“¾æ¥

1. [Full source codes å®Œæ•´æºä»£ç ](https://github.com/Jeiwan/blockchain_go/tree/part_5)
2. [Public-key cryptography å…¬é’¥å¯†ç å­¦](https://en.wikipedia.org/wiki/Public-key_cryptography)
3. [Digital signatures æ•°å­—ç­¾å](https://en.wikipedia.org/wiki/Digital_signature)
4. [Elliptic curve æ¤­åœ†æ›²çº¿](https://en.wikipedia.org/wiki/Elliptic_curve)
5. [Elliptic curve cryptography
   æ¤­åœ†æ›²çº¿åŠ å¯†](https://en.wikipedia.org/wiki/Elliptic_curve_cryptography)
6. [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)
7. [Technical background of Bitcoin addresses
   æ¯”ç‰¹å¸åœ°å€çš„æŠ€æœ¯èƒŒæ™¯](https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses)
8. [Address åœ°å€](https://en.bitcoin.it/wiki/Address)
9. [Base58 åŸºåœ°58](https://en.bitcoin.it/wiki/Base58Check_encoding)
10. [A gentle introduction to elliptic curve cryptography
    æ¤­åœ†æ›²çº¿å¯†ç å­¦ç®€ä»‹](http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/)



##  Building Blockchain in Go. Part 6: Transactions 2

18 Sep 2017

> Chinese translations: [by liuchengxu](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-6/transactions-2.md), [by zhangli1](https://zhangli1.gitbooks.io/dummies-for-blockchain/content/)
> ä¸­æ–‡ç¿»è¯‘ï¼šåˆ˜æˆæ—­ã€å¼ è‰1

### Introduction å¯¼è¨€

In the very first part of this series I said that blockchain is a distributed database. Back then, we decided to skip the â€œdistributedâ€ part and focus on the â€œdatabaseâ€ part. So far, weâ€™ve implemented almost all the things that make a blockchain database. In this post, weâ€™ll cover some mechanisms that were skipped in the previous parts, and in the next part weâ€™ll start working on the distributed nature of blockchain.
åœ¨æœ¬ç³»åˆ—çš„ç¬¬ä¸€éƒ¨åˆ†ï¼Œæˆ‘è¯´åŒºå—é“¾æ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼æ•°æ®åº“ã€‚å½“æ—¶ï¼Œæˆ‘ä»¬å†³å®šè·³è¿‡ "åˆ†å¸ƒå¼ "éƒ¨åˆ†ï¼Œä¸“æ³¨äº "æ•°æ®åº“ "éƒ¨åˆ†ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»å®ç°äº†åŒºå—é“¾æ•°æ®åº“çš„å‡ ä¹æ‰€æœ‰åŠŸèƒ½ã€‚åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»å‰å‡ éƒ¨åˆ†ä¸­è·³è¿‡çš„ä¸€äº›æœºåˆ¶ï¼Œä¸‹ä¸€éƒ¨åˆ†æˆ‘ä»¬å°†å¼€å§‹ç ”ç©¶åŒºå—é“¾çš„åˆ†å¸ƒå¼ç‰¹æ€§ã€‚

Previous parts: å‰å‡ éƒ¨åˆ†

1. [Basic Prototype åŸºæœ¬åŸå‹](https://jeiwan.net/posts/building-blockchain-in-go-part-1/)
2. [Proof-of-Work å·¥ä½œè¯æ˜](https://jeiwan.net/posts/building-blockchain-in-go-part-2/)
3. [Persistence and CLI æŒä¹…æ€§å’Œ CLI](https://jeiwan.net/posts/building-blockchain-in-go-part-3/)
4. [Transactions 1 äº¤æ˜“ 1](https://jeiwan.net/posts/building-blockchain-in-go-part-4/)
5. [Addresses åœ°å€](https://jeiwan.net/posts/building-blockchain-in-go-part-5/)

> This part introduces significant code changes, so it makes no sense explaining all of them here. Please refer to [this page](https://github.com/Jeiwan/blockchain_go/compare/part_5...part_6#files_bucket) to see all the changes since the last article.
> æœ¬éƒ¨åˆ†å¼•å…¥äº†é‡è¦çš„ä»£ç æ›´æ”¹ï¼Œå› æ­¤åœ¨æ­¤æ— æ³•ä¸€ä¸€è§£é‡Šã€‚è¯·å‚é˜…æœ¬é¡µï¼ŒæŸ¥çœ‹è‡ªä¸Šä¸€ç¯‡æ–‡ç« ä»¥æ¥çš„æ‰€æœ‰æ›´æ”¹ã€‚

### Reward å¥–åŠ±

One tiny thing we skipped in a previous article is rewards for mining. And we already have everything to implement it.
æˆ‘ä»¬åœ¨å‰ä¸€ç¯‡æ–‡ç« ä¸­å¿½ç•¥äº†ä¸€ä»¶å°äº‹ï¼Œé‚£å°±æ˜¯é‡‡çŸ¿å¥–åŠ±ã€‚è€Œæˆ‘ä»¬å·²ç»å…·å¤‡äº†å®ç°å®ƒçš„ä¸€åˆ‡æ¡ä»¶ã€‚

The reward is just a coinbase transaction. When a mining node starts mining a new block, it takes transactions from the queue and prepends a coinbase transaction to them. The coinbase transactionâ€™s only output contains minerâ€™s public key hash.
å¥–åŠ±åªæ˜¯ coinbase äº¤æ˜“ã€‚å½“æŒ–çŸ¿èŠ‚ç‚¹å¼€å§‹æŒ–æ˜ä¸€ä¸ªæ–°åŒºå—æ—¶ï¼Œå®ƒä¼šä»é˜Ÿåˆ—ä¸­è·å–äº¤æ˜“ï¼Œå¹¶åœ¨å…¶ä¸­é¢„ç½®ä¸€ä¸ªå¸å®‰äº¤æ˜“ã€‚Coinbase äº¤æ˜“çš„å”¯ä¸€è¾“å‡ºåŒ…å«çŸ¿å·¥çš„å…¬é’¥å“ˆå¸Œå€¼ã€‚

Implementing rewards is as easy as updating the `send` command:
å®æ–½å¥–åŠ±å°±åƒæ›´æ–° `send` å‘½ä»¤ä¸€æ ·ç®€å•ï¼š

```go
func (cli *CLI) send(from, to string, amount int) {
    ...
    bc := NewBlockchain()
    UTXOSet := UTXOSet{bc}
    defer bc.db.Close()

    tx := NewUTXOTransaction(from, to, amount, &UTXOSet)
    cbTx := NewCoinbaseTX(from, "")
    txs := []*Transaction{cbTx, tx}

    newBlock := bc.MineBlock(txs)
    fmt.Println("Success!")
}
```

In our implementation, the one who creates a transaction mines the new block, and thus, receives a reward.
åœ¨æˆ‘ä»¬çš„å®æ–½è¿‡ç¨‹ä¸­ï¼Œåˆ›å»ºäº¤æ˜“çš„äººå¼€é‡‡æ–°åŒºå—ï¼Œä»è€Œè·å¾—å¥–åŠ±ã€‚

### The UTXO Set UTXOå¥—è£…

In [Part 3: Persistence and CLI](https://jeiwan.net/posts/building-blockchain-in-go-part-3/) we studied the way Bitcoin Core stores blocks in a database. It was said that blocks are stored in `blocks` database and transaction outputs are stored in `chainstate` database. Let me remind you what the structure of `chainstate` is:
åœ¨ç¬¬ä¸‰éƒ¨åˆ†ï¼šæŒä¹…æ€§å’Œ CLI ä¸­ï¼Œæˆ‘ä»¬ç ”ç©¶äº† Bitcoin Core åœ¨æ•°æ®åº“ä¸­å­˜å‚¨åŒºå—çš„æ–¹å¼ã€‚æ®è¯´ï¼ŒåŒºå—å­˜å‚¨åœ¨ `blocks` æ•°æ®åº“ä¸­ï¼Œäº¤æ˜“è¾“å‡ºå­˜å‚¨åœ¨ `chainstate` æ•°æ®åº“ä¸­ã€‚è®©æˆ‘æé†’ä¸€ä¸‹ `chainstate` çš„ç»“æ„ï¼š

1. `'c' + 32-byte transaction hash -> unspent transaction output record for that transaction`
2. `'B' -> 32-byte block hash: the block hash up to which the database represents the unspent transaction outputs`

Since that article, weâ€™ve already implemented transactions, but we havenâ€™t used the `chainstate` to store their outputs. So, this is what weâ€™re going to do now.
ä»é‚£ç¯‡æ–‡ç« å¼€å§‹ï¼Œæˆ‘ä»¬å·²ç»å®ç°äº†äº‹åŠ¡ï¼Œä½†è¿˜æ²¡æœ‰ä½¿ç”¨ `chainstate` æ¥å­˜å‚¨å…¶è¾“å‡ºã€‚å› æ­¤ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬ç°åœ¨è¦åšçš„ã€‚

`chainstate` doesnâ€™t store transactions. Instead, it stores what is called the UTXO set, or the set of unspent transaction outputs. Besides this, it stores â€œthe block hash up to which the database represents the unspent transaction outputsâ€, which weâ€™ll omit for now because weâ€™re not using block heights (but weâ€™ll implement them in next articles).
`chainstate` å¹¶ä¸å­˜å‚¨äº‹åŠ¡ã€‚ç›¸åï¼Œå®ƒå­˜å‚¨çš„æ˜¯æ‰€è°“çš„ UTXO é›†ï¼Œå³æœªä½¿ç”¨çš„äº‹åŠ¡è¾“å‡ºé›†ã€‚é™¤æ­¤ä»¥å¤–ï¼Œå®ƒè¿˜å­˜å‚¨äº† "æ•°æ®åº“è¡¨ç¤ºæœªç”¨äº‹åŠ¡è¾“å‡ºçš„å—å“ˆå¸Œå€¼"ï¼Œç”±äºæˆ‘ä»¬ä¸ä½¿ç”¨å—é«˜åº¦ï¼ˆä½†æˆ‘ä»¬ä¼šåœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­å®ç°ï¼‰ï¼Œæ‰€ä»¥æš‚æ—¶çœç•¥äº†è¿™ä¸ªå€¼ã€‚

So, why do we want to have the UTXO set?
é‚£ä¹ˆï¼Œæˆ‘ä»¬ä¸ºä»€ä¹ˆéœ€è¦UTXOè®¾å¤‡å‘¢ï¼Ÿ

Consider the `Blockchain.FindUnspentTransactions` method weâ€™ve implemented earlier:
è¯·çœ‹æˆ‘ä»¬ä¹‹å‰å®ç°çš„ `Blockchain.FindUnspentTransactions` æ–¹æ³•ï¼š

```go
func (bc *Blockchain) FindUnspentTransactions(pubKeyHash []byte) []Transaction {
    ...
    bci := bc.Iterator()

    for {
        block := bci.Next()

        for _, tx := range block.Transactions {
            ...
        }

        if len(block.PrevBlockHash) == 0 {
            break
        }
    }
    ...
}
```

The function finds transactions with unspent outputs. Since transactions are stored in blocks, it iterates over each block in the blockchain and checks every transaction in it. As of September 18, 2017, thereâ€™re 485,860 blocks in Bitcoin and the whole database takes 140+ Gb of disk space. This means that one has to run a full node to validate transactions. Moreover, validating transactions would require iterating over many blocks.
è¯¥å‡½æ•°å¯ä»¥æ‰¾åˆ°æœ‰æœªç”¨è¾“å‡ºçš„äº¤æ˜“ã€‚ç”±äºäº¤æ˜“æ˜¯ä»¥åŒºå—ä¸ºå•ä½å­˜å‚¨çš„ï¼Œå› æ­¤å®ƒä¼šéå†åŒºå—é“¾ä¸­çš„æ¯ä¸ªåŒºå—ï¼Œå¹¶æ£€æŸ¥å…¶ä¸­çš„æ¯ç¬”äº¤æ˜“ã€‚æˆªè‡³ 2017 å¹´ 9 æœˆ 18 æ—¥ï¼Œæ¯”ç‰¹å¸å…±æœ‰ 485 860 ä¸ªåŒºå—ï¼Œæ•´ä¸ªæ•°æ®åº“éœ€è¦ 140 å¤š GB çš„ç£ç›˜ç©ºé—´ã€‚è¿™æ„å‘³ç€å¿…é¡»è¿è¡Œä¸€ä¸ªå®Œæ•´çš„èŠ‚ç‚¹æ‰èƒ½éªŒè¯äº¤æ˜“ã€‚æ­¤å¤–ï¼ŒéªŒè¯äº¤æ˜“éœ€è¦éå†è®¸å¤šåŒºå—ã€‚

The solution to the problem is to have an index that stores only unspent outputs, and this is what the UTXO set does: this is a cache that is built from all blockchain transactions (by iterating over blocks, yes, but this is done only once), and is later used to calculate balance and validate new transactions. The UTXO set is about 2.7 Gb as of September 2017.
è§£å†³é—®é¢˜çš„åŠæ³•æ˜¯å»ºç«‹ä¸€ä¸ªåªå­˜å‚¨æœªç”¨è¾“å‡ºçš„ç´¢å¼•ï¼Œè¿™å°±æ˜¯UTXOé›†çš„ä½œç”¨ï¼šè¿™æ˜¯ä¸€ä¸ªä»æ‰€æœ‰åŒºå—é“¾äº¤æ˜“ä¸­å»ºç«‹èµ·æ¥çš„ç¼“å­˜ï¼ˆé€šè¿‡å¯¹åŒºå—çš„è¿­ä»£ï¼Œæ²¡é”™ï¼Œä½†è¿™åªåšä¸€æ¬¡ï¼‰ï¼Œéšåç”¨äºè®¡ç®—ä½™é¢å’ŒéªŒè¯æ–°çš„äº¤æ˜“ã€‚æˆªè‡³ 2017 å¹´ 9 æœˆï¼ŒUTXO é›†çº¦ä¸º 2.7 Gbã€‚

Alright, letâ€™s think what we need to change to implement the UTXO set. Currently, the following methods are used to find transactions:
å¥½äº†ï¼Œè®©æˆ‘ä»¬æƒ³æƒ³è¦å®ç°UTXO è®¾ç½®éœ€è¦åšäº›ä»€ä¹ˆæ”¹å˜ã€‚ç›®å‰ï¼Œæˆ‘ä»¬ä½¿ç”¨ä»¥ä¸‹æ–¹æ³•æŸ¥æ‰¾äº‹åŠ¡ï¼š

1. `Blockchain.FindUnspentTransactions` â€“ the main function that finds transactions with unspent outputs. Itâ€™s this function where the iteration of all blocks happens.
   `Blockchain.FindUnspentTransactions` - çš„ä¸»å‡½æ•°ï¼Œç”¨äºæŸ¥æ‰¾æœ‰æœªç”¨è¾“å‡ºçš„äº¤æ˜“ã€‚æ‰€æœ‰åŒºå—çš„è¿­ä»£å°±æ˜¯åœ¨è¿™ä¸ªå‡½æ•°ä¸­è¿›è¡Œçš„ã€‚
2. `Blockchain.FindSpendableOutputs` â€“ this function is used when a new transaction is created. If finds the enough number of outputs holding required amount. Uses `Blockchain.FindUnspentTransactions`.
   `Blockchain.FindSpendableOutputs` - åˆ›å»ºæ–°äº¤æ˜“æ—¶ä½¿ç”¨è¯¥å‡½æ•°ã€‚å¦‚æœæ‰¾åˆ°è¶³å¤Ÿæ•°é‡çš„è¾“å‡ºï¼Œåˆ™å¯ä»¥æŒæœ‰æ‰€éœ€çš„é‡‘é¢ã€‚ä½¿ç”¨ ã€‚ `Blockchain.FindUnspentTransactions`
3. `Blockchain.FindUTXO` â€“ finds unspent outputs for a public key hash, used to get balance. Uses `Blockchain.FindUnspentTransactions`.
   `Blockchain.FindUTXO` - æŸ¥æ‰¾å…¬é’¥å“ˆå¸Œå€¼çš„æœªç”¨è¾“å‡ºï¼Œç”¨äºè·å–å¹³è¡¡ã€‚ä½¿ç”¨ ã€‚ `Blockchain.FindUnspentTransactions`
4. `Blockchain.FindTransaction` â€“ finds a transaction in the blockchain by its ID. It iterates over all blocks until finds it.
   `Blockchain.FindTransaction` - æ ¹æ® ID åœ¨åŒºå—é“¾ä¸­æŸ¥æ‰¾äº¤æ˜“ã€‚å®ƒä¼šéå†æ‰€æœ‰åŒºå—ï¼Œç›´åˆ°æ‰¾åˆ°ä¸ºæ­¢ã€‚

As you can see, all the methods iterate over blocks in the database. But we cannot improve all of them for now, because the UTXO set doesnâ€™t store all transactions, but only those that have unspent outputs. Thus, it cannot be used in `Blockchain.FindTransaction`.
å¦‚æ‚¨æ‰€è§ï¼Œæ‰€æœ‰æ–¹æ³•éƒ½ä¼šéå†æ•°æ®åº“ä¸­çš„åŒºå—ã€‚ä½†æˆ‘ä»¬ç°åœ¨è¿˜ä¸èƒ½å¯¹æ‰€æœ‰æ–¹æ³•è¿›è¡Œæ”¹è¿›ï¼Œå› ä¸º UTXO é›†å¹¶ä¸å­˜å‚¨æ‰€æœ‰äº‹åŠ¡ï¼Œè€Œåªå­˜å‚¨æœ‰æœªç”¨è¾“å‡ºçš„äº‹åŠ¡ã€‚å› æ­¤ï¼Œå®ƒä¸èƒ½åœ¨ `Blockchain.FindTransaction` ä¸­ä½¿ç”¨ã€‚

So, we want the following methods:
å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä»¥ä¸‹æ–¹æ³•ï¼š

1. `Blockchain.FindUTXO` â€“ finds all unspent outputs by iterating over blocks.
   `Blockchain.FindUTXO` - é€šè¿‡å¯¹åŒºå—è¿›è¡Œè¿­ä»£ï¼Œæ‰¾åˆ°æ‰€æœ‰æœªä½¿ç”¨çš„è¾“å‡ºã€‚
2. `UTXOSet.Reindex` â€” uses `FindUTXO` to find unspent outputs, and stores them in a database. This is where caching happens.
   `UTXOSet.Reindex` - ä½¿ç”¨ æŸ¥æ‰¾æœªä½¿ç”¨çš„è¾“å‡ºï¼Œå¹¶å°†å…¶å­˜å‚¨åˆ°æ•°æ®åº“ä¸­ã€‚è¿™å°±æ˜¯ç¼“å­˜å‘ç”Ÿçš„åœ°æ–¹ã€‚ `FindUTXO`
3. `UTXOSet.FindSpendableOutputs` â€“ analog of `Blockchain.FindSpendableOutputs`, but uses the UTXO set.
   `UTXOSet.FindSpendableOutputs` - çš„ç±»ä¼¼ç¨‹åºï¼Œä½†ä½¿ç”¨çš„æ˜¯UTXO ç¨‹åºé›†ã€‚ `Blockchain.FindSpendableOutputs`
4. `UTXOSet.FindUTXO` â€“ analog of `Blockchain.FindUTXO`, but uses the UTXO set.
   `UTXOSet.FindUTXO` - çš„ç±»ä¼¼ç¨‹åºï¼Œä½†ä½¿ç”¨çš„æ˜¯UTXO ç¨‹åºé›†ã€‚ `Blockchain.FindUTXO`
5. `Blockchain.FindTransaction` remains the same.
   `Blockchain.FindTransaction` ä¿æŒä¸å˜ã€‚

Thus, the two most frequently used functions will use the cache from now! Letâ€™s start coding.
å› æ­¤ï¼Œæœ€å¸¸ç”¨çš„ä¸¤ä¸ªå‡½æ•°å°†ä½¿ç”¨ç¼“å­˜ï¼è®©æˆ‘ä»¬å¼€å§‹ç¼–ç å§ã€‚

```go
type UTXOSet struct {
    Blockchain *Blockchain
}
```

Weâ€™ll use a single database, but weâ€™ll store the UTXO set in a different bucket. Thus, `UTXOSet` is coupled with `Blockchain`.
æˆ‘ä»¬å°†ä½¿ç”¨å•ä¸ªæ•°æ®åº“ï¼Œä½†ä¼šå°†UTXO æ•°æ®é›†å­˜å‚¨åœ¨ä¸åŒçš„æ•°æ®æ¡¶ä¸­ã€‚å› æ­¤ï¼Œ `UTXOSet` ä¸ `Blockchain` ç›¸è€¦åˆã€‚

```go
func (u UTXOSet) Reindex() {
    db := u.Blockchain.db
    bucketName := []byte(utxoBucket)

    err := db.Update(func(tx *bolt.Tx) error {
        err := tx.DeleteBucket(bucketName)
        _, err = tx.CreateBucket(bucketName)
    })

    UTXO := u.Blockchain.FindUTXO()

    err = db.Update(func(tx *bolt.Tx) error {
        b := tx.Bucket(bucketName)

        for txID, outs := range UTXO {
            key, err := hex.DecodeString(txID)
            err = b.Put(key, outs.Serialize())
        }
    })
}
```

This method creates the UTXO set initially. First, it removes the bucket if it exists, then it gets all unspent outputs from blockchain, and finally it saves the outputs to the bucket.
è¯¥æ–¹æ³•æœ€åˆåˆ›å»º UTXO é›†ã€‚é¦–å…ˆï¼Œå®ƒä¼šåˆ é™¤å·²å­˜åœ¨çš„è¾“å‡ºæ¡¶ï¼Œç„¶åä»åŒºå—é“¾ä¸­è·å–æ‰€æœ‰æœªä½¿ç”¨çš„è¾“å‡ºï¼Œæœ€åå°†è¾“å‡ºä¿å­˜åˆ°è¾“å‡ºæ¡¶ä¸­ã€‚

```
Blockchain.FindUTXO` is almost identical to `Blockchain.FindUnspentTransactions`, but now it returns a map of `TransactionID â†’ TransactionOutputs` pairs.
`Blockchain.FindUTXO` ä¸ å‡ ä¹ç›¸åŒï¼Œä½†ç°åœ¨å®ƒè¿”å›çš„æ˜¯ å¯¹çš„æ˜ å°„ã€‚ `Blockchain.FindUnspentTransactions` `TransactionID â†’ TransactionOutputs
```

Now, the UTXO set can be used to send coins:
ç°åœ¨ï¼ŒUTXO å¥—ä»¶å¯ä»¥ç”¨æ¥å‘é€ç¡¬å¸ï¼š

```go
func (u UTXOSet) FindSpendableOutputs(pubkeyHash []byte, amount int) (int, map[string][]int) {
    unspentOutputs := make(map[string][]int)
    accumulated := 0
    db := u.Blockchain.db

    err := db.View(func(tx *bolt.Tx) error {
        b := tx.Bucket([]byte(utxoBucket))
        c := b.Cursor()

        for k, v := c.First(); k != nil; k, v = c.Next() {
            txID := hex.EncodeToString(k)
            outs := DeserializeOutputs(v)

            for outIdx, out := range outs.Outputs {
                if out.IsLockedWithKey(pubkeyHash) && accumulated < amount {
                    accumulated += out.Value
                    unspentOutputs[txID] = append(unspentOutputs[txID], outIdx)
                }
            }
        }
    })

    return accumulated, unspentOutputs
}
```

Or check balance:
æˆ–æ£€æŸ¥ä½™é¢ï¼š

```go
func (u UTXOSet) FindUTXO(pubKeyHash []byte) []TXOutput {
    var UTXOs []TXOutput
    db := u.Blockchain.db

    err := db.View(func(tx *bolt.Tx) error {
        b := tx.Bucket([]byte(utxoBucket))
        c := b.Cursor()

        for k, v := c.First(); k != nil; k, v = c.Next() {
            outs := DeserializeOutputs(v)

            for _, out := range outs.Outputs {
                if out.IsLockedWithKey(pubKeyHash) {
                    UTXOs = append(UTXOs, out)
                }
            }
        }

        return nil
    })

    return UTXOs
}
```

These are slightly modified versions of corresponding `Blockchain` methods. Those `Blockchain` methods are not needed anymore.
è¿™äº›æ˜¯ç›¸åº”çš„ `Blockchain` æ–¹æ³•çš„ç•¥å¾®ä¿®æ”¹ç‰ˆæœ¬ã€‚ `Blockchain` æ–¹æ³•å·²ä¸å†éœ€è¦ã€‚

Having the UTXO set means that our data (transactions) are now split into to storages: actual transactions are stored in the blockchain, and unspent outputs are stored in the UTXO set. Such separation requires solid synchronization mechanism because we want the UTXO set to always be updated and store outputs of most recent transactions. But we donâ€™t want to reindex every time a new block is mined because itâ€™s these frequent blockchain scans that we want to avoid. Thus, we need a mechanism of updating the UTXO set:
æ‹¥æœ‰UTXOé›†æ„å‘³ç€æˆ‘ä»¬çš„æ•°æ®ï¼ˆäº¤æ˜“ï¼‰ç°åœ¨è¢«åˆ†æˆä¸¤ä¸ªå­˜å‚¨ç©ºé—´ï¼šå®é™…äº¤æ˜“å­˜å‚¨åœ¨åŒºå—é“¾ä¸­ï¼Œæœªä½¿ç”¨çš„è¾“å‡ºå­˜å‚¨åœ¨UTXOé›†ä¸­ã€‚è¿™ç§åˆ†ç¦»éœ€è¦ç¨³å›ºçš„åŒæ­¥æœºåˆ¶ï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ› UTXO é›†å§‹ç»ˆä¿æŒæ›´æ–°ï¼Œå¹¶å­˜å‚¨æœ€æ–°äº¤æ˜“çš„è¾“å‡ºã€‚ä½†æˆ‘ä»¬ä¸æƒ³åœ¨æ¯æ¬¡æŒ–æ˜æ–°åŒºå—æ—¶éƒ½é‡æ–°ç´¢å¼•ï¼Œå› ä¸ºæˆ‘ä»¬è¦é¿å…çš„æ­£æ˜¯è¿™ç§é¢‘ç¹çš„åŒºå—é“¾æ‰«æã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§æ›´æ–° UTXO é›†çš„æœºåˆ¶ï¼š

```go
func (u UTXOSet) Update(block *Block) {
    db := u.Blockchain.db

    err := db.Update(func(tx *bolt.Tx) error {
        b := tx.Bucket([]byte(utxoBucket))

        for _, tx := range block.Transactions {
            if tx.IsCoinbase() == false {
                for _, vin := range tx.Vin {
                    updatedOuts := TXOutputs{}
                    outsBytes := b.Get(vin.Txid)
                    outs := DeserializeOutputs(outsBytes)

                    for outIdx, out := range outs.Outputs {
                        if outIdx != vin.Vout {
                            updatedOuts.Outputs = append(updatedOuts.Outputs, out)
                        }
                    }

                    if len(updatedOuts.Outputs) == 0 {
                        err := b.Delete(vin.Txid)
                    } else {
                        err := b.Put(vin.Txid, updatedOuts.Serialize())
                    }

                }
            }

            newOutputs := TXOutputs{}
            for _, out := range tx.Vout {
                newOutputs.Outputs = append(newOutputs.Outputs, out)
            }

            err := b.Put(tx.ID, newOutputs.Serialize())
        }
    })
}
```

The method looks big, but what it does is quite straightforward. When a new block is mined, the UTXO set should be updated. Updating means removing spent outputs and adding unspent outputs from newly mined transactions. If a transaction which outputs were removed, contains no more outputs, itâ€™s removed as well. Quite simple!
è¿™ä¸ªæ–¹æ³•çœ‹èµ·æ¥å¾ˆå¤§ï¼Œä½†åšèµ·æ¥å´å¾ˆç®€å•ã€‚å½“å¼€é‡‡å‡ºä¸€ä¸ªæ–°åŒºå—æ—¶ï¼ŒUTXO é›†å°±åº”è¯¥æ›´æ–°ã€‚æ›´æ–°æ„å‘³ç€ä»æ–°æŒ–å‡ºçš„äº¤æ˜“ä¸­ç§»é™¤å·²è€—å°½çš„è¾“å‡ºï¼Œå¹¶æ·»åŠ æœªè€—å°½çš„è¾“å‡ºã€‚å¦‚æœè¢«ç§»é™¤è¾“å‡ºçš„äº¤æ˜“ä¸å†åŒ…å«è¾“å‡ºï¼Œé‚£ä¹ˆå®ƒä¹Ÿä¼šè¢«ç§»é™¤ã€‚éå¸¸ç®€å•ï¼

Letâ€™s now use the UTXO set where itâ€™s necessary:
ç°åœ¨ï¼Œè®©æˆ‘ä»¬åœ¨å¿…è¦çš„åœ°æ–¹ä½¿ç”¨UTXO è®¾ç½®ï¼š

```go
func (cli *CLI) createBlockchain(address string) {
    ...
    bc := CreateBlockchain(address)
    defer bc.db.Close()

    UTXOSet := UTXOSet{bc}
    UTXOSet.Reindex()
    ...
}
```

Reindexing happens right after a new blockchain is created. For now, this is the only place where `Reindex` is used, even though it looks excessive here because in the beginning of a blockchain thereâ€™s only one block with one transaction, and `Update` couldâ€™ve been used instead. But we might need the reindexing mechanism in the future.
æ–°åŒºå—é“¾åˆ›å»ºåä¼šç«‹å³é‡æ–°ç´¢å¼•ã€‚ç›®å‰ï¼Œè¿™æ˜¯å”¯ä¸€ä½¿ç”¨ `Reindex` çš„åœ°æ–¹ï¼Œå°½ç®¡å®ƒåœ¨è¿™é‡Œæ˜¾å¾—æœ‰äº›å¤šä½™ï¼Œå› ä¸ºåœ¨åŒºå—é“¾çš„å¼€å§‹é˜¶æ®µï¼Œåªæœ‰ä¸€ä¸ªåŒºå—æœ‰ä¸€ç¬”äº¤æ˜“ï¼Œæœ¬å¯ä»¥ä½¿ç”¨ `Update` æ¥ä»£æ›¿ã€‚ä½†æˆ‘ä»¬å°†æ¥å¯èƒ½éœ€è¦é‡æ–°ç´¢å¼•æœºåˆ¶ã€‚

```go
func (cli *CLI) send(from, to string, amount int) {
    ...
    newBlock := bc.MineBlock(txs)
    UTXOSet.Update(newBlock)
}
```

And the UTXO set is updated after a new block is mined.
æ–°åŒºå—æŒ–å‡ºåï¼ŒUTXO é›†ä¼šæ›´æ–°ã€‚

Letâ€™s check that it works
è®©æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸‹å®ƒæ˜¯å¦æ­£å¸¸å·¥ä½œ

```shell
$ blockchain_go createblockchain -address 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1
00000086a725e18ed7e9e06f1051651a4fc46a315a9d298e59e57aeacbe0bf73

Done!

$ blockchain_go send -from 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1 -to 12DkLzLQ4B3gnQt62EPRJGZ38n3zF4Hzt5 -amount 6
0000001f75cb3a5033aeecbf6a8d378e15b25d026fb0a665c7721a5bb0faa21b

Success!

$ blockchain_go send -from 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1 -to 12ncZhA5mFTTnTmHq1aTPYBri4jAK8TacL -amount 4
000000cc51e665d53c78af5e65774a72fc7b864140a8224bf4e7709d8e0fa433

Success!

$ blockchain_go getbalance -address 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1
Balance of '1F4MbuqjcuJGymjcuYQMUVYB37AWKkSLif': 20

$ blockchain_go getbalance -address 12DkLzLQ4B3gnQt62EPRJGZ38n3zF4Hzt5
Balance of '1XWu6nitBWe6J6v6MXmd5rhdP7dZsExbx': 6

$ blockchain_go getbalance -address 12ncZhA5mFTTnTmHq1aTPYBri4jAK8TacL
Balance of '13UASQpCR8Nr41PojH8Bz4K6cmTCqweskL': 4
```

Nice! The `1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1` address received reward 3 times:
ä¸é”™ï¼ `1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1` åœ°å€æ”¶åˆ° 3 æ¬¡å¥–åŠ±ï¼š

1. Once for mining the genesis blocks.
   ä¸€æ¬¡ç”¨äºå¼€é‡‡åˆ›ä¸–ç§¯æœ¨ã€‚
2. Once for mining the block `0000001f75cb3a5033aeecbf6a8d378e15b25d026fb0a665c7721a5bb0faa21b`.
   ä¸€æ—¦ç”¨äºé‡‡çŸ¿å— `0000001f75cb3a5033aeecbf6a8d378e15b25d026fb0a665c7721a5bb0faa21b` .
3. And once for mining the block `000000cc51e665d53c78af5e65774a72fc7b864140a8224bf4e7709d8e0fa433 `.
   è¿˜æœ‰ä¸€æ¬¡ç”¨äºå¼€é‡‡åŒºå— `000000cc51e665d53c78af5e65774a72fc7b864140a8224bf4e7709d8e0fa433 `ã€‚

### Merkle Tree æ¢…å…‹å°”æ ‘

Thereâ€™s one more optimization mechanism Iâ€™d like to discuss in this post.
åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘è¿˜æƒ³è®¨è®ºä¸€ä¸ªä¼˜åŒ–æœºåˆ¶ã€‚

As it was said above, the full Bitcoin database (i.e., blockchain) takes more than 140 Gb of disk space. Because of the decentralized nature of Bitcoin, every node in the network must be independent and self-sufficient, i.e. every node must store a full copy of the blockchain. With many people starting using Bitcoin, this rule becomes more difficult to follow: itâ€™s not likely that everyone will run a full node. Also, since nodes are full-fledged participants of the network, they have responsibilities: they must verify transactions and blocks. Also, thereâ€™s certain internet traffic required to interact with other nodes and download new blocks.
å¦‚ä¸Šæ‰€è¿°ï¼Œå®Œæ•´çš„æ¯”ç‰¹å¸æ•°æ®åº“ï¼ˆå³åŒºå—é“¾ï¼‰éœ€è¦è¶…è¿‡ 140 Gb çš„ç£ç›˜ç©ºé—´ã€‚ç”±äºæ¯”ç‰¹å¸çš„å»ä¸­å¿ƒåŒ–ç‰¹æ€§ï¼Œç½‘ç»œä¸­çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½å¿…é¡»æ˜¯ç‹¬ç«‹å’Œè‡ªç»™è‡ªè¶³çš„ï¼Œå³æ¯ä¸ªèŠ‚ç‚¹éƒ½å¿…é¡»å­˜å‚¨ä¸€ä»½å®Œæ•´çš„åŒºå—é“¾å‰¯æœ¬ã€‚éšç€è¶Šæ¥è¶Šå¤šçš„äººå¼€å§‹ä½¿ç”¨æ¯”ç‰¹å¸ï¼Œè¿™ä¸€è§„åˆ™å˜å¾—æ›´åŠ éš¾ä»¥éµå®ˆï¼šä¸å¯èƒ½æ¯ä¸ªäººéƒ½è¿è¡Œä¸€ä¸ªå®Œæ•´çš„èŠ‚ç‚¹ã€‚å¦å¤–ï¼Œç”±äºèŠ‚ç‚¹æ˜¯ç½‘ç»œçš„æ­£å¼å‚ä¸è€…ï¼Œå®ƒä»¬ä¹Ÿæœ‰è´£ä»»ï¼šå®ƒä»¬å¿…é¡»éªŒè¯äº¤æ˜“å’ŒåŒºå—ã€‚æ­¤å¤–ï¼Œä¸å…¶ä»–èŠ‚ç‚¹äº¤äº’å’Œä¸‹è½½æ–°åŒºå—ä¹Ÿéœ€è¦ä¸€å®šçš„ç½‘ç»œæµé‡ã€‚

In [the original Bitcoin paper](https://bitcoin.org/bitcoin.pdf) published by Satoshi Nakamoto, there was a solution for this problem: Simplified Payment Verification (SPV). SPV is a light Bitcoin node that doesnâ€™t download the whole blockchain and **doesnâ€™t verify blocks and transactions**. Instead, it finds transactions in blocks (to verify payments) and is linked to a full node to retrieve just necessary data. This mechanism allows having multiple light wallet nodes with running just one full node.
åœ¨ä¸­æœ¬èªæœ€åˆå‘è¡¨çš„æ¯”ç‰¹å¸è®ºæ–‡ä¸­ï¼Œæœ‰ä¸€ä¸ªè§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹æ¡ˆï¼šç®€åŒ–æ”¯ä»˜éªŒè¯ï¼ˆSPVï¼‰ã€‚SPV æ˜¯ä¸€ä¸ªè½»å‹æ¯”ç‰¹å¸èŠ‚ç‚¹ï¼Œå®ƒä¸ä¸‹è½½æ•´ä¸ªåŒºå—é“¾ï¼Œä¹Ÿä¸éªŒè¯åŒºå—å’Œäº¤æ˜“ã€‚å–è€Œä»£ä¹‹çš„æ˜¯ï¼Œå®ƒåœ¨åŒºå—ä¸­æŸ¥æ‰¾äº¤æ˜“ï¼ˆä»¥éªŒè¯æ”¯ä»˜ï¼‰ï¼Œå¹¶é“¾æ¥åˆ°ä¸€ä¸ªå®Œæ•´èŠ‚ç‚¹ï¼Œä»¥æ£€ç´¢å¿…è¦çš„æ•°æ®ã€‚è¿™ç§æœºåˆ¶å…è®¸åœ¨è¿è¡Œä¸€ä¸ªå®Œæ•´èŠ‚ç‚¹çš„æƒ…å†µä¸‹æ‹¥æœ‰å¤šä¸ªè½»é’±åŒ…èŠ‚ç‚¹ã€‚

For SPV to be possible, there should be a way to check if a block contains certain transaction without downloading the whole block. And this is where Merkle tree comes into play.
è¦ä½¿ SPV æˆä¸ºå¯èƒ½ï¼Œåº”è¯¥æœ‰ä¸€ç§æ–¹æ³•å¯ä»¥åœ¨ä¸ä¸‹è½½æ•´ä¸ªåŒºå—çš„æƒ…å†µä¸‹æ£€æŸ¥ä¸€ä¸ªåŒºå—æ˜¯å¦åŒ…å«æŸäº›äº¤æ˜“ã€‚è¿™å°±æ˜¯ Merkle æ ‘å‘æŒ¥ä½œç”¨çš„åœ°æ–¹ã€‚

Merkle trees are used by Bitcoin to obtain transactions hash, which is then saved in block headers and is considered by the proof-of-work system. Until now, we just concatenated hashes of each transaction in a block and applied `SHA-256` to them. This is also a good way of getting a unique representation of block transactions, but it doesnâ€™t have benefits of Merkle trees.
æ¢…å…‹å°”æ ‘è¢«æ¯”ç‰¹å¸ç”¨æ¥è·å–äº¤æ˜“å“ˆå¸Œå€¼ï¼Œç„¶åå°†å…¶ä¿å­˜åœ¨åŒºå—å¤´ä¸­ï¼Œå¹¶è¢«å·¥ä½œè¯æ˜ç³»ç»Ÿæ‰€è€ƒè™‘ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªæ˜¯å°†åŒºå—ä¸­æ¯ç¬”äº¤æ˜“çš„å“ˆå¸Œå€¼è¿æ¥èµ·æ¥ï¼Œç„¶ååº”ç”¨ `SHA-256` ã€‚è¿™ä¹Ÿæ˜¯è·å¾—åŒºå—äº¤æ˜“å”¯ä¸€è¡¨ç¤ºçš„å¥½æ–¹æ³•ï¼Œä½†å®ƒæ²¡æœ‰æ¢…å…‹å°”æ ‘çš„å¥½å¤„ã€‚

Letâ€™s look at a Merkle tree:
è®©æˆ‘ä»¬æ¥çœ‹çœ‹æ¢…å…‹å°”æ ‘ï¼š

![Merkle tree diagram](https://jeiwan.net/images/merkle-tree-diagram.png)

A Merkle tree is built for each block, and it starts with leaves (the bottom of the tree), where a leaf is a transaction hash (Bitcoins uses double `SHA256` hashing). The number of leaves must be even, but not every block contains an even number of transactions. In case there is an odd number of transactions, the last transaction is duplicated (in the Merkle tree, not in the block!).
æ¯ä¸ªåŒºå—éƒ½ä¼šå»ºç«‹ä¸€æ£µé»˜å…‹å°”æ ‘ï¼Œå®ƒä»¥å¶å­ï¼ˆæ ‘çš„åº•éƒ¨ï¼‰å¼€å§‹ï¼Œå¶å­æ˜¯äº¤æ˜“å“ˆå¸Œå€¼ï¼ˆæ¯”ç‰¹å¸ä½¿ç”¨åŒ `SHA256` å“ˆå¸Œå€¼ï¼‰ã€‚å¶å­çš„æ•°é‡å¿…é¡»æ˜¯å¶æ•°ï¼Œä½†å¹¶ä¸æ˜¯æ¯ä¸ªåŒºå—éƒ½åŒ…å«å¶æ•°ä¸ªäº¤æ˜“ã€‚å¦‚æœäº¤æ˜“æ¬¡æ•°ä¸ºå¥‡æ•°ï¼Œæœ€åä¸€ç¬”äº¤æ˜“å°†è¢«é‡å¤ï¼ˆåœ¨æ¢…å…‹å°”æ ‘ä¸­ï¼Œè€Œä¸æ˜¯åœ¨åŒºå—ä¸­ï¼ï¼‰ã€‚

Moving from the bottom up, leaves are grouped in pairs, their hashes are concatenated, and a new hash is obtained from the concatenated hashes. The new hashes form new tree nodes. This process is repeated until thereâ€™s just one node, which is called the root of the tree. The root hash is then used as the unique representation of the transactions, is saved in block headers, and is used in the proof-of-work system.
è‡ªä¸‹è€Œä¸Šï¼Œæ ‘å¶æˆå¯¹åˆ†ç»„ï¼Œå®ƒä»¬çš„å“ˆå¸Œå€¼è¢«ä¸²è”èµ·æ¥ï¼Œç„¶åä»ä¸²è”çš„å“ˆå¸Œå€¼ä¸­å¾—åˆ°ä¸€ä¸ªæ–°çš„å“ˆå¸Œå€¼ã€‚æ–°çš„å“ˆå¸Œå€¼ç»„æˆæ–°çš„æ ‘èŠ‚ç‚¹ã€‚è¿™ä¸ªè¿‡ç¨‹ä¸æ–­é‡å¤ï¼Œç›´åˆ°åªå‰©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå³æ ‘æ ¹ã€‚æ ¹æ•£åˆ—è¢«ç”¨ä½œäº¤æ˜“çš„å”¯ä¸€è¡¨ç¤ºï¼Œä¿å­˜åœ¨åŒºå—å¤´ä¸­ï¼Œå¹¶ç”¨äºå·¥ä½œé‡è¯æ˜ç³»ç»Ÿã€‚

The benefit of Merkle trees is that a node can verify membership of certain transaction without downloading the whole block. Just a transaction hash, a Merkle tree root hash, and a Merkle path are required for this.
é»˜å…‹å°”æ ‘çš„å¥½å¤„æ˜¯ï¼ŒèŠ‚ç‚¹æ— éœ€ä¸‹è½½æ•´ä¸ªåŒºå—å°±èƒ½éªŒè¯æŸäº›äº¤æ˜“çš„æˆå‘˜èº«ä»½ã€‚è¿™åªéœ€è¦äº¤æ˜“å“ˆå¸Œå€¼ã€æ¢…å…‹å°”æ ‘æ ¹å“ˆå¸Œå€¼å’Œæ¢…å…‹å°”è·¯å¾„ã€‚

Finally, letâ€™s write code:
æœ€åï¼Œè®©æˆ‘ä»¬æ¥ç¼–å†™ä»£ç ï¼š

```go
type MerkleTree struct {
    RootNode *MerkleNode
}

type MerkleNode struct {
    Left  *MerkleNode
    Right *MerkleNode
    Data  []byte
}
```

We start with structs. Every `MerkleNode` keeps data and links to its branches. `MerkleTree` is actually the root node linked to the next nodes, which are in their turn linked to further nodes, etc.
æˆ‘ä»¬ä»ç»“æ„ä½“å¼€å§‹ã€‚æ¯ä¸ª `MerkleNode` éƒ½ä¿å­˜æ•°æ®å¹¶é“¾æ¥åˆ°å…¶åˆ†æ”¯ã€‚ `MerkleTree` å®é™…ä¸Šæ˜¯é“¾æ¥åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æ ¹èŠ‚ç‚¹ï¼Œè€Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹åˆé“¾æ¥åˆ°æ›´å¤šèŠ‚ç‚¹ï¼Œç­‰ç­‰ã€‚

Letâ€™s create a new node first:
è®©æˆ‘ä»¬å…ˆåˆ›å»ºä¸€ä¸ªæ–°èŠ‚ç‚¹ï¼š

```go
func NewMerkleNode(left, right *MerkleNode, data []byte) *MerkleNode {
    mNode := MerkleNode{}

    if left == nil && right == nil {
        hash := sha256.Sum256(data)
        mNode.Data = hash[:]
    } else {
        prevHashes := append(left.Data, right.Data...)
        hash := sha256.Sum256(prevHashes)
        mNode.Data = hash[:]
    }

    mNode.Left = left
    mNode.Right = right

    return &mNode
}
```

Every node contains some data. When a node is a leaf, the data is passed from the outside (a serialized transaction in our case). When a node is linked to other nodes, it takes their data and concatenates and hashes it.
æ¯ä¸ªèŠ‚ç‚¹éƒ½åŒ…å«ä¸€äº›æ•°æ®ã€‚å½“èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹æ—¶ï¼Œæ•°æ®ä»å¤–éƒ¨ä¼ é€’ï¼ˆåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­æ˜¯åºåˆ—åŒ–äº‹åŠ¡ï¼‰ã€‚å½“ä¸€ä¸ªèŠ‚ç‚¹ä¸å…¶ä»–èŠ‚ç‚¹é“¾æ¥æ—¶ï¼Œå®ƒä¼šè·å–å®ƒä»¬çš„æ•°æ®ï¼Œå¹¶å¯¹å…¶è¿›è¡Œè¿æ¥å’Œæ•£åˆ—ã€‚

```go
func NewMerkleTree(data [][]byte) *MerkleTree {
    var nodes []MerkleNode

    if len(data)%2 != 0 {
        data = append(data, data[len(data)-1])
    }

    for _, datum := range data {
        node := NewMerkleNode(nil, nil, datum)
        nodes = append(nodes, *node)
    }

    for i := 0; i < len(data)/2; i++ {
        var newLevel []MerkleNode

        for j := 0; j < len(nodes); j += 2 {
            node := NewMerkleNode(&nodes[j], &nodes[j+1], nil)
            newLevel = append(newLevel, *node)
        }

        nodes = newLevel
    }

    mTree := MerkleTree{&nodes[0]}

    return &mTree
}
```

When a new tree is created, the first thing to ensure is that there is an even number of leaves. After that, `data` (which is an array of serialized transactions) is converted into tree leaves, and a tree is grown from these leaves.
åˆ›å»ºä¸€æ£µæ–°æ ‘æ—¶ï¼Œé¦–å…ˆè¦ç¡®ä¿æœ‰å¶æ•°ä¸ªæ ‘å¶ã€‚ä¹‹åï¼Œ `data` ï¼ˆè¿™æ˜¯ä¸€ä¸ªåºåˆ—åŒ–äº‹åŠ¡çš„æ•°ç»„ï¼‰ä¼šè¢«è½¬æ¢æˆæ ‘å¶ï¼Œç„¶åä»è¿™äº›æ ‘å¶ä¸­ç”Ÿé•¿å‡ºä¸€æ£µæ ‘ã€‚

Now, letâ€™s modify `Block.HashTransactions`, which is used in the proof-of-work system to obtain transactions hash:
ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä¿®æ”¹ `Block.HashTransactions` ï¼Œå®ƒåœ¨å·¥ä½œè¯æ˜ç³»ç»Ÿä¸­ç”¨äºè·å–äº¤æ˜“å“ˆå¸Œå€¼ï¼š

```go
func (b *Block) HashTransactions() []byte {
    var transactions [][]byte

    for _, tx := range b.Transactions {
        transactions = append(transactions, tx.Serialize())
    }
    mTree := NewMerkleTree(transactions)

    return mTree.RootNode.Data
}
```

First, transactions are serialized (using `encoding/gob`), and then they are used to build a Merkle tree. The root of the tree will serve as the unique identifier of blockâ€™s transactions.
é¦–å…ˆï¼Œå¯¹äº¤æ˜“è¿›è¡Œåºåˆ—åŒ–ï¼ˆä½¿ç”¨ `encoding/gob` ï¼‰ï¼Œç„¶åç”¨å®ƒä»¬æ„å»ºä¸€æ£µæ¢…å…‹å°”æ ‘ã€‚æ ‘æ ¹å°†ä½œä¸ºåŒºå—äº¤æ˜“çš„å”¯ä¸€æ ‡è¯†ç¬¦ã€‚

### P2PKH

Thereâ€™s one more thing Iâ€™d like to discuss in more detail.
è¿˜æœ‰ä¸€ä»¶äº‹æˆ‘æƒ³è¯¦ç»†è°ˆè°ˆã€‚

As you remember, in Bitcoin there is the *Script* programming language, which is used to lock transaction outputs; and transaction inputs provide data to unlock outputs. The language is simple, and code in this language is just a sequence of data and operators. Consider this example:
å¤§å®¶éƒ½è¿˜è®°å¾—ï¼Œæ¯”ç‰¹å¸ä¸­æœ‰ä¸€ç§è„šæœ¬ç¼–ç¨‹è¯­è¨€ï¼Œç”¨äºé”å®šäº¤æ˜“è¾“å‡ºï¼›è€Œäº¤æ˜“è¾“å…¥åˆ™ä¸ºè§£é”è¾“å‡ºæä¾›æ•°æ®ã€‚è¿™ç§è¯­è¨€éå¸¸ç®€å•ï¼Œä»£ç åªæ˜¯æ•°æ®å’Œè¿ç®—ç¬¦çš„åºåˆ—ã€‚è¯·çœ‹è¿™ä¸ªä¾‹å­

```shell
5 2 OP_ADD 7 OP_EQUAL
5`, `2`, and `7` are data. `OP_ADD` and `OP_EQUAL` are operators. *Script* code is executed from left to right: every piece of data is put into the stack and the next operator is applied to the top stack elements. *Script*â€™s stack is just a simple FILO (First Input Last Output) memory storage: the first element in the stack is the last to be taken, with every further element being put on the previous one.
`5` `2` `7` `OP_ADD` å’Œ æ˜¯è¿ç®—ç¬¦ã€‚è„šæœ¬ä»£ç ä»å·¦åˆ°å³æ‰§è¡Œï¼šæ¯ä¸€ä¸ªæ•°æ®éƒ½è¢«æ”¾å…¥å †æ ˆï¼Œä¸‹ä¸€ä¸ªè¿ç®—ç¬¦åº”ç”¨äºå †æ ˆé¡¶éƒ¨çš„å…ƒç´ ã€‚è„šæœ¬çš„å †æ ˆåªæ˜¯ä¸€ä¸ªç®€å•çš„ FILOï¼ˆFirst Input Last Outputï¼‰å†…å­˜å­˜å‚¨ï¼šå †æ ˆä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æœ€åä¸€ä¸ªè¢«å–èµ°çš„å…ƒç´ ï¼Œæ¥ä¸‹æ¥çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ”¾åœ¨å‰ä¸€ä¸ªå…ƒç´ ä¸Šã€‚ `OP_EQUAL
```

Letâ€™s break the execution of the above script into steps:
è®©æˆ‘ä»¬æŠŠä¸Šè¿°è„šæœ¬çš„æ‰§è¡Œåˆ†æˆå‡ ä¸ªæ­¥éª¤ï¼š

1. Stack: empty. Script: `5 2 OP_ADD 7 OP_EQUAL`.
   å †æ ˆï¼šç©ºã€‚è„šæœ¬ï¼š `5 2 OP_ADD 7 OP_EQUAL` ã€‚
2. Stack: `5`. Script: `2 OP_ADD 7 OP_EQUAL`.
   å †æ ˆï¼š `5` .è„šæœ¬ï¼š `2 OP_ADD 7 OP_EQUAL` .
3. Stack: `5 2`. Script: `OP_ADD 7 OP_EQUAL`.
   å †æ ˆï¼š `5 2` .è„šæœ¬ï¼š `OP_ADD 7 OP_EQUAL` .
4. Stack: `7`. Script: `7 OP_EQUAL`.
   å †æ ˆï¼š `7` .è„šæœ¬ï¼š `7 OP_EQUAL` .
5. Stack: `7 7`. Script: `OP_EQUAL`.
   å †æ ˆï¼š `7 7` .è„šæœ¬ï¼š `OP_EQUAL` .
6. Stack: `true`. Script: empty.
   å †æ ˆï¼š `true` ã€‚è„šæœ¬ï¼š ç©ºã€‚

```
OP_ADD` takes two elements from the stack, summarizes them, and push the sum into the stack. `OP_EQUAL` takes two elements from the stack and compares them: if theyâ€™re equal it pushes `true` to the stack; otherwise it pushes `false`. A result of a script execution is the value of the top stack element: in our case, itâ€™s `true`, which means that the script finished successfully.
`OP_ADD` `OP_EQUAL` ä»å †æ ˆä¸­æå–ä¸¤ä¸ªå…ƒç´ å¹¶è¿›è¡Œæ¯”è¾ƒï¼šå¦‚æœä¸¤ä¸ªå…ƒç´ ç›¸ç­‰ï¼Œåˆ™å°† æ¨å…¥å †æ ˆï¼›å¦åˆ™å°† æ¨å…¥å †æ ˆã€‚è„šæœ¬æ‰§è¡Œçš„ç»“æœå°±æ˜¯æ ˆé¡¶å…ƒç´ çš„å€¼ï¼šåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œå®ƒæ˜¯ ï¼Œè¿™æ„å‘³ç€è„šæœ¬æˆåŠŸå®Œæˆã€‚ `true` `false` `true
```

Now letâ€™s look at the script that is used in Bitcoin to perform payments:
ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥çœ‹çœ‹æ¯”ç‰¹å¸ä¸­ç”¨äºæ‰§è¡Œæ”¯ä»˜çš„è„šæœ¬ï¼š

```shell
<signature> <pubKey> OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
```

This script is called *Pay to Public Key Hash* (P2PKH), and this is the most commonly used script in Bitcoin. It literally pays to a public key hash, i.e. locks coins with a certain public key. This is **the heart of Bitcoin payments**: there are no accounts, no funds transferring between them; thereâ€™s just a script that checks that provided signature and public key are correct.
è¿™ç§è„šæœ¬è¢«ç§°ä¸º "æ”¯ä»˜å…¬é’¥æ•£åˆ—"ï¼ˆP2PKHï¼‰ï¼Œæ˜¯æ¯”ç‰¹å¸ä¸­æœ€å¸¸ç”¨çš„è„šæœ¬ã€‚å®ƒçš„å­—é¢æ„æ€æ˜¯æ”¯ä»˜ç»™å…¬é’¥æ•£åˆ—ï¼Œå³ç”¨æŸä¸ªå…¬é’¥é”å®šå¸ã€‚è¿™å°±æ˜¯æ¯”ç‰¹å¸æ”¯ä»˜çš„æ ¸å¿ƒï¼šæ²¡æœ‰è´¦æˆ·ï¼Œæ²¡æœ‰è´¦æˆ·ä¹‹é—´çš„èµ„é‡‘è½¬ç§»ï¼›åªæœ‰ä¸€ä¸ªè„šæœ¬ï¼Œæ£€æŸ¥æ‰€æä¾›çš„ç­¾åå’Œå…¬é’¥æ˜¯å¦æ­£ç¡®ã€‚

The script is actually stored in two parts:
è„šæœ¬å®é™…ä¸Šåˆ†ä¸ºä¸¤éƒ¨åˆ†å­˜å‚¨ï¼š

1. The first piece, `<signature> <pubKey>`, is stored in inputâ€™s `ScriptSig` field.
   ç¬¬ä¸€éƒ¨åˆ† `<signature> <pubKey>` ä¿å­˜åœ¨è¾“å…¥çš„ `ScriptSig` å­—æ®µä¸­ã€‚
2. The second piece, `OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` is stored in outputâ€™s `ScriptPubKey`.
   ç¬¬äºŒéƒ¨åˆ† `OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` ä¿å­˜åœ¨è¾“å‡ºçš„ `ScriptPubKey` ä¸­ã€‚

Thus, itâ€™s outputs that define unlocking logic, and itâ€™s inputs that provide data to unlock outputs. Letâ€™s execute the script:
å› æ­¤ï¼Œå®šä¹‰è§£é”é€»è¾‘çš„æ˜¯è¾“å‡ºï¼Œä¸ºè§£é”è¾“å‡ºæä¾›æ•°æ®çš„æ˜¯è¾“å…¥ã€‚è®©æˆ‘ä»¬æ‰§è¡Œè„šæœ¬ï¼š

1. Stack: empty å †æ ˆï¼šç©º
   Script: `<signature> <pubKey> OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` è„šæœ¬ `<signature> <pubKey> OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`
2. Stack: `<signature>` å †æ ˆ `<signature>`
   Script: `<pubKey> OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` è„šæœ¬ `<pubKey> OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`
3. Stack: `<signature> <pubKey>` å †æ ˆ `<signature> <pubKey>`
   Script: `OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` è„šæœ¬ `OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`
4. Stack: `<signature> <pubKey> <pubKey>` å †æ ˆ `<signature> <pubKey> <pubKey>`
   Script: `OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` è„šæœ¬ `OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`
5. Stack: `<signature> <pubKey> <pubKeyHash>` å †æ ˆ `<signature> <pubKey> <pubKeyHash>`
   Script: `<pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` è„šæœ¬ `<pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`
6. Stack: `<signature> <pubKey> <pubKeyHash> <pubKeyHash>` å †æ ˆ `<signature> <pubKey> <pubKeyHash> <pubKeyHash>`
   Script: `OP_EQUALVERIFY OP_CHECKSIG` è„šæœ¬ `OP_EQUALVERIFY OP_CHECKSIG`
7. Stack: `<signature> <pubKey>` å †æ ˆ `<signature> <pubKey>`
   Script: `OP_CHECKSIG` è„šæœ¬ `OP_CHECKSIG`
8. Stack: `true` or `false`. Script: empty.
   å †æ ˆï¼š `true` æˆ– `false` ã€‚è„šæœ¬ï¼šç©ºã€‚

```
OP_DUP` duplicates the top stack element. `OP_HASH160` takes the top stack element and hashes it with `RIPEMD160`; the result is pushed back to the stack. `OP_EQUALVERIFY` compares two top stack elements, and if theyâ€™re not equal, interrupts the script. `OP_CHECKSIG` validates the signature of a transaction by hashing the transaction and using `<signature>` and `<pubKey>`. The latter operator is quite complex: it makes a trimmed copy of the transaction, hashes it (because itâ€™s a hash of a transaction thatâ€™s signed), and checks that the signature is correct using provided `<signature>` and `<pubKey>`.
`OP_DUP` `OP_HASH160` `RIPEMD160` `OP_EQUALVERIFY` æ¯”è¾ƒå †æ ˆé¡¶éƒ¨çš„ä¸¤ä¸ªå…ƒç´ ï¼Œå¦‚æœä¸ç›¸ç­‰ï¼Œåˆ™ä¸­æ–­è„šæœ¬ã€‚ é€šè¿‡å¯¹äº‹åŠ¡è¿›è¡Œæ•£åˆ—å¹¶ä½¿ç”¨ å’Œ éªŒè¯äº‹åŠ¡çš„ç­¾åã€‚åä¸€ä¸ªè¿ç®—ç¬¦ç›¸å½“å¤æ‚ï¼šå®ƒåˆ¶ä½œä¸€ä¸ªç»è¿‡ä¿®å‰ªçš„äº‹åŠ¡å‰¯æœ¬ï¼Œå¯¹å…¶è¿›è¡Œæ•£åˆ—ï¼ˆå› ä¸ºå®ƒæ˜¯å·²ç­¾åäº‹åŠ¡çš„æ•£åˆ—ï¼‰ï¼Œç„¶åä½¿ç”¨æä¾›çš„ å’Œ æ£€æŸ¥ç­¾åæ˜¯å¦æ­£ç¡®ã€‚ `OP_CHECKSIG` `<signature>` `<pubKey>` `<signature>` `<pubKey>
```

Having such scripting language allows Bitcoin to be also a smart-contract platform: the language makes possible other payment schemes besides transferring to a single key. For example,
æœ‰äº†è¿™ç§è„šæœ¬è¯­è¨€ï¼Œæ¯”ç‰¹å¸ä¹Ÿå¯ä»¥æˆä¸ºä¸€ä¸ªæ™ºèƒ½åˆçº¦å¹³å°ï¼šé™¤äº†å‘å•ä¸ªå¯†é’¥è½¬è´¦å¤–ï¼Œè¿™ç§è¯­è¨€è¿˜å¯ä»¥å®ç°å…¶ä»–æ”¯ä»˜æ–¹æ¡ˆã€‚ä¾‹å¦‚

### Conclusion ç»“è®º

And thatâ€™s it! Weâ€™ve implemented almost all key feature of a blockchain-based cryptocurrency. We have blockchain, addresses, mining, and transactions. But thereâ€™s one more thing that gives life to all these mechanisms and makes Bitcoin a global system: consensus. In the next article, weâ€™ll start implementing the â€œdecentralizedâ€ part of the blockchain. Stay tuned!
å°±æ˜¯è¿™æ ·ï¼æˆ‘ä»¬å‡ ä¹å®ç°äº†åŸºäºåŒºå—é“¾çš„åŠ å¯†è´§å¸çš„æ‰€æœ‰å…³é”®åŠŸèƒ½ã€‚æˆ‘ä»¬æœ‰äº†åŒºå—é“¾ã€åœ°å€ã€æŒ–çŸ¿å’Œäº¤æ˜“ã€‚ä½†è¿˜æœ‰ä¸€æ ·ä¸œè¥¿èµ‹äºˆäº†æ‰€æœ‰è¿™äº›æœºåˆ¶ç”Ÿå‘½åŠ›ï¼Œå¹¶ä½¿æ¯”ç‰¹å¸æˆä¸ºä¸€ä¸ªå…¨çƒæ€§ç³»ç»Ÿï¼šå…±è¯†ã€‚åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†å¼€å§‹å®ç°åŒºå—é“¾çš„ "å»ä¸­å¿ƒåŒ– "éƒ¨åˆ†ã€‚æ•¬è¯·æœŸå¾…ï¼

Links: é“¾æ¥

1. [Full source codes å®Œæ•´æºä»£ç ](https://github.com/Jeiwan/blockchain_go/tree/part_6)
2. [The UTXO Set UTXOå¥—è£…](https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2):_Data_Storage#The_UTXO_set_.28chainstate_leveldb.29)
3. [Merkle Tree æ¢…å…‹å°”æ ‘](https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees)
4. [Script è„šæœ¬](https://en.bitcoin.it/wiki/Script)
5. [â€œUltrapruneâ€ Bitcoin Core commit
   "Ultraprune "æ¯”ç‰¹å¸æ ¸å¿ƒæäº¤](https://github.com/sipa/bitcoin/commit/450cbb0944cd20a06ce806e6679a1f4c83c50db2)
6. [UTXO set statistics UTXOæ•°æ®é›†ç»Ÿè®¡](https://statoshi.info/dashboard/db/unspent-transaction-output-set)
7. [Smart contracts and Bitcoin
   æ™ºèƒ½åˆçº¦å’Œæ¯”ç‰¹å¸](https://medium.com/@maraoz/smart-contracts-and-bitcoin-a5d61011d9b1)
8. [Why every Bitcoin user should understand â€œSPV securityâ€
   ä¸ºä»€ä¹ˆæ¯ä¸ªæ¯”ç‰¹å¸ç”¨æˆ·éƒ½åº”è¯¥äº†è§£ "SPV å®‰å…¨æ€§"ï¼Ÿ](https://medium.com/@jonaldfyookball/why-every-bitcoin-user-should-understand-spv-security-520d1d45e0b9)

## Building Blockchain in Go. Part 7: Network

06 Oct 2017

> Chinese translations: [by liuchengxu](https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-7/network.md), [by zhangli1](https://zhangli1.gitbooks.io/dummies-for-blockchain/content/)
> ä¸­æ–‡ç¿»è¯‘ï¼šåˆ˜æˆæ—­ã€å¼ è‰1

### Introduction å¯¼è¨€

So far, weâ€™ve build a blockchain that has all key features: anonymous, secure, and randomly generated addresses; blockchain data storage; Proof-of-Work system; reliable way to store transactions. While these features are crucial, itâ€™s not enough. What makes these features really shine, and what make cryptocurrencies possible, is network. Whatâ€™s the use of having such blockchain implementation running just on a single computer? Whatâ€™s the use of those cryptography based features, when thereâ€™s just one user? Itâ€™s network that make all these mechanism work and be useful.
åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»æ„å»ºäº†ä¸€ä¸ªå…·å¤‡æ‰€æœ‰å…³é”®åŠŸèƒ½çš„åŒºå—é“¾ï¼šåŒ¿åã€å®‰å…¨ã€éšæœºç”Ÿæˆçš„åœ°å€ï¼›åŒºå—é“¾æ•°æ®å­˜å‚¨ï¼›å·¥ä½œè¯æ˜ç³»ç»Ÿï¼›å¯é çš„äº¤æ˜“å­˜å‚¨æ–¹å¼ã€‚è™½ç„¶è¿™äº›åŠŸèƒ½è‡³å…³é‡è¦ï¼Œä½†è¿˜è¿œè¿œä¸å¤Ÿã€‚çœŸæ­£è®©è¿™äº›åŠŸèƒ½å¤§æ”¾å¼‚å½©ï¼Œè®©åŠ å¯†è´§å¸æˆä¸ºå¯èƒ½çš„æ˜¯ç½‘ç»œã€‚ä»…ä»…åœ¨ä¸€å°è®¡ç®—æœºä¸Šè¿è¡Œè¿™æ ·çš„åŒºå—é“¾å®æ–½æ–¹æ¡ˆæœ‰ä»€ä¹ˆç”¨ï¼Ÿå¦‚æœåªæœ‰ä¸€ä¸ªç”¨æˆ·ï¼Œè¿™äº›åŸºäºå¯†ç å­¦çš„åŠŸèƒ½åˆæœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿæ˜¯ç½‘ç»œè®©æ‰€æœ‰è¿™äº›æœºåˆ¶å¾—ä»¥è¿è¡Œå¹¶å‘æŒ¥ä½œç”¨ã€‚

You can think of those blockchain features as rules, similar to the rules that people establish when they want to live and thrive together. A kind of social arrangements. Blockchain network is a community of programs that follow the same rules, and itâ€™s this following the rules that makes the network alive. Similarly, when people share identical ideas, they become stronger and can together build a better life. If there are people that follow a different set of rules, theyâ€™ll live in a separate society (state, commune, etc.). Identically, if thereâ€™re blockchain nodes that follow different rules, theyâ€™ll form a separate network.
ä½ å¯ä»¥æŠŠåŒºå—é“¾çš„è¿™äº›åŠŸèƒ½çœ‹ä½œæ˜¯è§„åˆ™ï¼Œç±»ä¼¼äºäººä»¬æƒ³è¦å…±åŒç”Ÿæ´»å’Œå‘å±•æ—¶å»ºç«‹çš„è§„åˆ™ã€‚ä¸€ç§ç¤¾ä¼šå®‰æ’ã€‚åŒºå—é“¾ç½‘ç»œæ˜¯ä¸€ä¸ªç”±éµå¾ªç›¸åŒè§„åˆ™çš„ç¨‹åºç»„æˆçš„ç¤¾åŒºï¼Œæ­£æ˜¯è¿™ç§å¯¹è§„åˆ™çš„éµå¾ªè®©ç½‘ç»œå……æ»¡æ´»åŠ›ã€‚åŒæ ·ï¼Œå½“äººä»¬åˆ†äº«ç›¸åŒçš„æƒ³æ³•æ—¶ï¼Œä»–ä»¬ä¼šå˜å¾—æ›´åŠ å¼ºå¤§ï¼Œå¯ä»¥å…±åŒå»ºè®¾ç¾å¥½çš„ç”Ÿæ´»ã€‚å¦‚æœæœ‰äººéµå¾ªä¸åŒçš„è§„åˆ™ï¼Œä»–ä»¬å°±ä¼šç”Ÿæ´»åœ¨ä¸€ä¸ªç‹¬ç«‹çš„ç¤¾ä¼šï¼ˆå›½å®¶ã€å…¬ç¤¾ç­‰ï¼‰ä¸­ã€‚åŒæ ·ï¼Œå¦‚æœæœ‰éµå¾ªä¸åŒè§„åˆ™çš„åŒºå—é“¾èŠ‚ç‚¹ï¼Œå®ƒä»¬ä¹Ÿä¼šå½¢æˆä¸€ä¸ªç‹¬ç«‹çš„ç½‘ç»œã€‚

**This is very important:** without a network and without a majority of nodes sharing identical rules, these rules are useless!
è¿™ä¸€ç‚¹éå¸¸é‡è¦ï¼šæ²¡æœ‰ç½‘ç»œï¼Œæ²¡æœ‰å¤§å¤šæ•°èŠ‚ç‚¹å…±äº«ç›¸åŒçš„è§„åˆ™ï¼Œè¿™äº›è§„åˆ™å°±æ¯«æ— ç”¨å¤„ï¼

> DISCLAIMER: Unfortunately, I didnâ€™t have enough time to implement a real P2P network prototype. In this article Iâ€™ll demonstrate a most common scenario, that involves nodes of different types. Improving this scenario and making this a P2P network can be a good challenge and practice for you! Also I cannot guarantee that other scenarios besides the one implemented in this article, will work. Sorry!
> å…è´£å£°æ˜ï¼šå¾ˆé—æ†¾ï¼Œæˆ‘æ²¡æœ‰è¶³å¤Ÿçš„æ—¶é—´æ¥å®ç°ä¸€ä¸ªçœŸæ­£çš„ P2P ç½‘ç»œåŸå‹ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘å°†æ¼”ç¤ºä¸€ä¸ªæœ€å¸¸è§çš„åœºæ™¯ï¼Œå…¶ä¸­æ¶‰åŠä¸åŒç±»å‹çš„èŠ‚ç‚¹ã€‚æ”¹è¿›è¿™ä¸ªåœºæ™¯å¹¶ä½¿å…¶æˆä¸ºä¸€ä¸ª P2P ç½‘ç»œå¯¹ä½ æ¥è¯´æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æŒ‘æˆ˜å’Œç»ƒä¹ ï¼æ­¤å¤–ï¼Œæˆ‘ä¸èƒ½ä¿è¯é™¤äº†æœ¬æ–‡ä¸­å®ç°çš„æ–¹æ¡ˆå¤–ï¼Œå…¶ä»–æ–¹æ¡ˆä¹Ÿèƒ½æ­£å¸¸è¿è¡Œã€‚å¯¹ä¸èµ·ï¼

> This part introduces significant code changes, so it makes no sense explaining all of them here. Please refer to [this page](https://github.com/Jeiwan/blockchain_go/compare/part_6...part_7#files_bucket) to see all the changes since the last article.
> æœ¬éƒ¨åˆ†å¼•å…¥äº†é‡è¦çš„ä»£ç æ›´æ”¹ï¼Œå› æ­¤åœ¨æ­¤æ— æ³•ä¸€ä¸€è§£é‡Šã€‚è¯·å‚é˜…æœ¬é¡µï¼ŒæŸ¥çœ‹è‡ªä¸Šä¸€ç¯‡æ–‡ç« ä»¥æ¥çš„æ‰€æœ‰æ›´æ”¹ã€‚

### Blockchain Network åŒºå—é“¾ç½‘ç»œ

Blockchain network is decentralized, which means thereâ€™re no servers that do stuff and clients that use servers to get or process data. In blockchain network there are nodes, and each node is a full-fledged member of the network. A node is everything: itâ€™s both a client and a server. This is very important to keep in mind, because itâ€™s very different from usual web applications.
åŒºå—é“¾ç½‘ç»œæ˜¯å»ä¸­å¿ƒåŒ–çš„ï¼Œè¿™æ„å‘³ç€æ²¡æœ‰æœåŠ¡å™¨æ¥åšäº‹æƒ…ï¼Œä¹Ÿæ²¡æœ‰å®¢æˆ·ç«¯ä½¿ç”¨æœåŠ¡å™¨æ¥è·å–æˆ–å¤„ç†æ•°æ®ã€‚åŒºå—é“¾ç½‘ç»œä¸­æœ‰èŠ‚ç‚¹ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æ˜¯ç½‘ç»œçš„æ­£å¼æˆå‘˜ã€‚èŠ‚ç‚¹æ— æ‰€ä¸èƒ½ï¼šå®ƒæ—¢æ˜¯å®¢æˆ·ç«¯ï¼Œä¹Ÿæ˜¯æœåŠ¡å™¨ã€‚è¿™ä¸€ç‚¹éå¸¸é‡è¦ï¼Œå› ä¸ºå®ƒä¸æ™®é€šçš„ç½‘ç»œåº”ç”¨ç¨‹åºæˆªç„¶ä¸åŒã€‚

Blockchain network is a P2P (Peer-to-Peer) network, which means that nodes are connected directly to each other. Itâ€™s topology is flat, since there are no hierarchy in node roles. Here its schematic representation:
åŒºå—é“¾ç½‘ç»œæ˜¯ä¸€ç§ P2Pï¼ˆç‚¹å¯¹ç‚¹ï¼‰ç½‘ç»œï¼Œå³èŠ‚ç‚¹ä¹‹é—´ç›´æ¥ç›¸è¿ã€‚å®ƒçš„æ‹“æ‰‘ç»“æ„æ˜¯æ‰å¹³çš„ï¼Œå› ä¸ºèŠ‚ç‚¹è§’è‰²æ²¡æœ‰ç­‰çº§ä¹‹åˆ†ã€‚ä¸‹é¢æ˜¯å®ƒçš„ç¤ºæ„å›¾ï¼š

![P2P Network Scheme](https://jeiwan.net/images/p2p-network.png) ([Business vector created by Dooder - Freepik.com](https://www.freepik.com/dooder))
( å•†ä¸šçŸ¢é‡ç”± Dooder åˆ›å»º - Freepik.com)

Nodes in such network are more difficult to implement, because they have to perform a lot of operations. Each node must interact with multiple other nodes, it must request other nodeâ€™s state, compare it with itâ€™s own state, and update its state when itâ€™s outdated.
è¿™ç§ç½‘ç»œä¸­çš„èŠ‚ç‚¹æ›´éš¾å®ç°ï¼Œå› ä¸ºå®ƒä»¬å¿…é¡»æ‰§è¡Œå¤§é‡æ“ä½œã€‚æ¯ä¸ªèŠ‚ç‚¹å¿…é¡»ä¸å¤šä¸ªå…¶ä»–èŠ‚ç‚¹äº¤äº’ï¼Œå¿…é¡»è¯·æ±‚å…¶ä»–èŠ‚ç‚¹çš„çŠ¶æ€ï¼Œå°†å…¶ä¸è‡ªå·±çš„çŠ¶æ€è¿›è¡Œæ¯”è¾ƒï¼Œå¹¶åœ¨çŠ¶æ€è¿‡æ—¶æ—¶æ›´æ–°è‡ªå·±çš„çŠ¶æ€ã€‚

### Node Roles èŠ‚ç‚¹è§’è‰²

Despite being full-fledged, blockchain nodes can play different roles in the network. Here they are:
å°½ç®¡åŒºå—é“¾èŠ‚ç‚¹æ˜¯å®Œæ•´çš„ï¼Œä½†å®ƒä»¬åœ¨ç½‘ç»œä¸­å¯ä»¥æ‰®æ¼”ä¸åŒçš„è§’è‰²ã€‚å®ƒä»¬æ˜¯

1. Miner. çŸ¿å·¥
   Such nodes are run on powerful or specialized hardware (like ASIC), and their only goal is to mine new blocks as fast as possible. Miners are only possible in blockchains that use Proof-of-Work, because mining actually means solving PoW puzzles. In Proof-of-Stake blockchains, for example, thereâ€™s no mining.
   è¿™äº›èŠ‚ç‚¹åœ¨åŠŸèƒ½å¼ºå¤§æˆ–ä¸“ç”¨çš„ç¡¬ä»¶ï¼ˆå¦‚ ASICï¼‰ä¸Šè¿è¡Œï¼Œå®ƒä»¬çš„å”¯ä¸€ç›®æ ‡å°±æ˜¯å°½å¯èƒ½å¿«åœ°æŒ–æ˜æ–°åŒºå—ã€‚åªæœ‰åœ¨ä½¿ç”¨ "å·¥ä½œè¯æ˜ "çš„åŒºå—é“¾ä¸­æ‰å¯èƒ½å‡ºç°çŸ¿å·¥ï¼Œå› ä¸ºæŒ–çŸ¿å®é™…ä¸Šæ„å‘³ç€è§£å†³ "å·¥ä½œè¯æ˜ "éš¾é¢˜ã€‚ä¾‹å¦‚ï¼Œåœ¨ "è·åˆ©è¯æ˜"ï¼ˆProof-of-Stakeï¼‰åŒºå—é“¾ä¸­ï¼Œå°±ä¸å­˜åœ¨çŸ¿å·¥ã€‚
2. Full node. å…¨èŠ‚ç‚¹ã€‚
   These nodes validate blocks mined by miners and verify transactions. To do this, they must have the whole copy of blockchain. Also, such nodes perform such routing operations, like helping other nodes to discover each other.
   è¿™äº›èŠ‚ç‚¹éªŒè¯çŸ¿å·¥æŒ–å‡ºçš„åŒºå—å¹¶éªŒè¯äº¤æ˜“ã€‚ä¸ºæ­¤ï¼Œå®ƒä»¬å¿…é¡»æ‹¥æœ‰æ•´ä¸ªåŒºå—é“¾å‰¯æœ¬ã€‚æ­¤å¤–ï¼Œè¿™äº›èŠ‚ç‚¹è¿˜æ‰§è¡Œè·¯ç”±æ“ä½œï¼Œå¦‚å¸®åŠ©å…¶ä»–èŠ‚ç‚¹å‘ç°å½¼æ­¤ã€‚
   Itâ€™s very crucial for network to have many full nodes, because itâ€™s these nodes that make decisions: they decide if a block or transaction is valid.
   å¯¹äºç½‘ç»œæ¥è¯´ï¼Œæ‹¥æœ‰è®¸å¤šå®Œæ•´çš„èŠ‚ç‚¹éå¸¸é‡è¦ï¼Œå› ä¸ºæ­£æ˜¯è¿™äº›èŠ‚ç‚¹åœ¨åšå†³å®šï¼šå®ƒä»¬å†³å®šä¸€ä¸ªåŒºå—æˆ–äº¤æ˜“æ˜¯å¦æœ‰æ•ˆã€‚
3. SPV.
   SPV stands for Simplified Payment Verification. These nodes donâ€™t store a full copy of blockchain, but they still able to verify transactions (not all of them, but a subset, for example, those that were sent to specific address). An SPV node depends on a full node to get data from, and there could be many SPV nodes connected to one full node. SPV makes wallet applications possible: one donâ€™t need to download full blockchain, but still can verify their transactions.
   SPV ä»£è¡¨ç®€åŒ–æ”¯ä»˜éªŒè¯ã€‚è¿™äº›èŠ‚ç‚¹ä¸å­˜å‚¨åŒºå—é“¾çš„å®Œæ•´å‰¯æœ¬ï¼Œä½†ä»èƒ½éªŒè¯äº¤æ˜“ï¼ˆä¸æ˜¯å…¨éƒ¨äº¤æ˜“ï¼Œè€Œæ˜¯å­é›†ï¼Œä¾‹å¦‚å‘é€åˆ°ç‰¹å®šåœ°å€çš„äº¤æ˜“ï¼‰ã€‚SPV èŠ‚ç‚¹ä¾èµ–å®Œæ•´èŠ‚ç‚¹è·å–æ•°æ®ï¼Œä¸€ä¸ªå®Œæ•´èŠ‚ç‚¹å¯èƒ½è¿æ¥å¤šä¸ª SPV èŠ‚ç‚¹ã€‚SPV ä½¿é’±åŒ…åº”ç”¨æˆä¸ºå¯èƒ½ï¼šäººä»¬ä¸éœ€è¦ä¸‹è½½å®Œæ•´çš„åŒºå—é“¾ï¼Œä½†ä»ç„¶å¯ä»¥éªŒè¯ä»–ä»¬çš„äº¤æ˜“ã€‚

### Network simplification ç½‘ç»œç®€åŒ–

To implement network in our blockchain, we have to simplify some things. The problem is that we donâ€™t have many computers to simulate a network with multiple nodes. We couldâ€™ve used virtual machines or Docker to solve this problem, but it could make everything more difficult: you would have to solve possible virtual machine or Docker issues, while my goal is to concentrate on blockchain implementation only. So, we want to run multiple blockchain nodes on a single machine and at the same time we want them to have different addresses. To achieve this weâ€™ll use **ports as node identifiers**, instead of IP addresses. E.g., there will be nodes with addresses: `127.0.0.1:3000`, `127.0.0.1:3001`, `127.0.0.1:3002`, etc. Weâ€™ll call the port node ID and use `NODE_ID` environment variable to set them. Thus, you can open multiple terminal windows, set different `NODE_ID`s and have different nodes running.
ä¸ºäº†åœ¨åŒºå—é“¾ä¸­å®ç°ç½‘ç»œï¼Œæˆ‘ä»¬å¿…é¡»ç®€åŒ–ä¸€äº›äº‹æƒ…ã€‚é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬æ²¡æœ‰è¶³å¤Ÿçš„è®¡ç®—æœºæ¥æ¨¡æ‹Ÿå¤šèŠ‚ç‚¹ç½‘ç»œã€‚æˆ‘ä»¬æœ¬å¯ä»¥ä½¿ç”¨è™šæ‹Ÿæœºæˆ– Docker æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†è¿™ä¼šè®©ä¸€åˆ‡å˜å¾—æ›´åŠ å›°éš¾ï¼šä½ å¿…é¡»è§£å†³è™šæ‹Ÿæœºæˆ– Docker å¯èƒ½å­˜åœ¨çš„é—®é¢˜ï¼Œè€Œæˆ‘çš„ç›®æ ‡åªæ˜¯ä¸“æ³¨äºåŒºå—é“¾çš„å®ç°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨ä¸€å°æœºå™¨ä¸Šè¿è¡Œå¤šä¸ªåŒºå—é“¾èŠ‚ç‚¹ï¼ŒåŒæ—¶å¸Œæœ›å®ƒä»¬æ‹¥æœ‰ä¸åŒçš„åœ°å€ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ç«¯å£ä½œä¸ºèŠ‚ç‚¹æ ‡è¯†ç¬¦ï¼Œè€Œä¸æ˜¯ IP åœ°å€ã€‚ä¾‹å¦‚ï¼ŒèŠ‚ç‚¹çš„åœ°å€ä¸º `127.0.0.1:3000` , `127.0.0.1:3001` , `127.0.0.1:3002` ç­‰ã€‚æˆ‘ä»¬å°†æŠŠç«¯å£ç§°ä¸ºèŠ‚ç‚¹ IDï¼Œå¹¶ä½¿ç”¨ `NODE_ID` ç¯å¢ƒå˜é‡æ¥è®¾ç½®å®ƒä»¬ã€‚è¿™æ ·ï¼Œä½ å°±å¯ä»¥æ‰“å¼€å¤šä¸ªç»ˆç«¯çª—å£ï¼Œè®¾ç½®ä¸åŒçš„ `NODE_ID` s å¹¶è¿è¡Œä¸åŒçš„èŠ‚ç‚¹ã€‚

This approach also requires having different blockchains and wallet files. They now must depend on the node ID and be named like `blockchain_3000.db`, `blockchain_30001.db` and `wallet_3000.db`, `wallet_30001.db`, etc.
è¿™ç§æ–¹æ³•è¿˜éœ€è¦æœ‰ä¸åŒçš„åŒºå—é“¾å’Œé’±åŒ…æ–‡ä»¶ã€‚å®ƒä»¬ç°åœ¨å¿…é¡»å–å†³äºèŠ‚ç‚¹ IDï¼Œå¹¶å‘½åä¸º `blockchain_3000.db` , `blockchain_30001.db` å’Œ `wallet_3000.db` , `wallet_30001.db` ç­‰ã€‚

### Implementation å®æ–½æƒ…å†µ

So, what happens when you download, say, Bitcoin Core and run it for the first time? It has to connect to some node to downloaded the latest state of the blockchain. Considering that your computer is not aware of all, or some, Bitcoin nodes, whatâ€™s this node?
é‚£ä¹ˆï¼Œå½“ä½ ç¬¬ä¸€æ¬¡ä¸‹è½½å¹¶è¿è¡Œ Bitcoin Core æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿå®ƒå¿…é¡»è¿æ¥åˆ°æŸä¸ªèŠ‚ç‚¹ï¼Œä¸‹è½½åŒºå—é“¾çš„æœ€æ–°çŠ¶æ€ã€‚è€ƒè™‘åˆ°ä½ çš„ç”µè„‘å¹¶ä¸çŸ¥é“æ‰€æœ‰æˆ–æŸäº›æ¯”ç‰¹å¸èŠ‚ç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªèŠ‚ç‚¹æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ

Hardcoding a node address in Bitcoin Core wouldâ€™ve been a mistake: the node could be attacked or shut down, which could result in new nodes not being able to join the network. Instead, in Bitcoin Core, there are [DNS seeds](https://bitcoin.org/en/glossary/dns-seed) hardcoded. These are not nodes, but DNS servers that know addresses of some nodes. When you start a clean Bitcoin Core, itâ€™ll connect to one of the seeds and get a list of full nodes, which itâ€™ll then download the blockchain from.
åœ¨ Bitcoin Core ä¸­ç¡¬ç¼–ç èŠ‚ç‚¹åœ°å€æ˜¯ä¸€ä¸ªé”™è¯¯ï¼šèŠ‚ç‚¹å¯èƒ½ä¼šè¢«æ”»å‡»æˆ–å…³é—­ï¼Œä»è€Œå¯¼è‡´æ–°èŠ‚ç‚¹æ— æ³•åŠ å…¥ç½‘ç»œã€‚ç›¸åï¼Œåœ¨ Bitcoin Core ä¸­ï¼Œæœ‰ DNS ç§å­ç¡¬ç¼–ç ã€‚è¿™äº›ç§å­ä¸æ˜¯èŠ‚ç‚¹ï¼Œè€Œæ˜¯çŸ¥é“æŸäº›èŠ‚ç‚¹åœ°å€çš„ DNS æœåŠ¡å™¨ã€‚å½“ä½ å¯åŠ¨ä¸€ä¸ªå¹²å‡€çš„ Bitcoin Core æ—¶ï¼Œå®ƒä¼šè¿æ¥åˆ°å…¶ä¸­ä¸€ä¸ªç§å­ï¼Œå¹¶è·å¾—å®Œæ•´èŠ‚ç‚¹çš„åˆ—è¡¨ï¼Œç„¶åä»åˆ—è¡¨ä¸­ä¸‹è½½åŒºå—é“¾ã€‚

In our implementation, there will be centralization though. Weâ€™ll have three nodes:
ä¸è¿‡ï¼Œåœ¨æˆ‘ä»¬çš„å®æ–½è¿‡ç¨‹ä¸­ï¼Œå°†å®è¡Œé›†ä¸­ç®¡ç†ã€‚æˆ‘ä»¬å°†æœ‰ä¸‰ä¸ªèŠ‚ç‚¹ï¼š

1. The central node. This is the node all other nodes will connect to, and this is the node thatâ€™ll sends data between other nodes.
   ä¸­å¿ƒèŠ‚ç‚¹ã€‚è¿™æ˜¯æ‰€æœ‰å…¶ä»–èŠ‚ç‚¹éƒ½è¦è¿æ¥çš„èŠ‚ç‚¹ï¼Œä¹Ÿæ˜¯åœ¨å…¶ä»–èŠ‚ç‚¹ä¹‹é—´å‘é€æ•°æ®çš„èŠ‚ç‚¹ã€‚
2. A miner node. This node will store new transactions in mempool and when thereâ€™re enough of transactions, itâ€™ll mine a new block.
   çŸ¿å·¥èŠ‚ç‚¹ã€‚è¯¥èŠ‚ç‚¹ä¼šå°†æ–°çš„äº¤æ˜“å­˜å‚¨åˆ° mempool ä¸­ï¼Œå½“æœ‰è¶³å¤Ÿå¤šçš„äº¤æ˜“æ—¶ï¼Œå®ƒå°±ä¼šæŒ–å‡ºä¸€ä¸ªæ–°åŒºå—ã€‚
3. A wallet node. This node will be used to send coins between wallets. Unlike SPV nodes though, itâ€™ll store a full copy of blockchain.
   é’±åŒ…èŠ‚ç‚¹ã€‚è¯¥èŠ‚ç‚¹å°†ç”¨äºåœ¨é’±åŒ…ä¹‹é—´å‘é€ç¡¬å¸ã€‚ä¸ SPV èŠ‚ç‚¹ä¸åŒçš„æ˜¯ï¼Œå®ƒå°†å­˜å‚¨ä¸€ä»½å®Œæ•´çš„åŒºå—é“¾å‰¯æœ¬ã€‚

#### The Scenario åœºæ™¯

The goal of this article is to implement the following scenario:
æœ¬æ–‡çš„ç›®çš„æ˜¯å®ç°ä»¥ä¸‹æ–¹æ¡ˆï¼š

1. The central node creates a blockchain.
   ä¸­å¿ƒèŠ‚ç‚¹åˆ›å»ºåŒºå—é“¾ã€‚
2. Other (wallet) node connects to it and downloads the blockchain.
   å…¶ä»–ï¼ˆé’±åŒ…ï¼‰èŠ‚ç‚¹è¿æ¥åˆ°å®ƒå¹¶ä¸‹è½½åŒºå—é“¾ã€‚
3. One more (miner) node connects to the central node and downloads the blockchain.
   è¿˜æœ‰ä¸€ä¸ªï¼ˆçŸ¿å·¥ï¼‰èŠ‚ç‚¹è¿æ¥åˆ°ä¸­å¿ƒèŠ‚ç‚¹å¹¶ä¸‹è½½åŒºå—é“¾ã€‚
4. The wallet node creates a transaction.
   é’±åŒ…èŠ‚ç‚¹åˆ›å»ºäº¤æ˜“ã€‚
5. The miner nodes receives the transaction and keeps it in its memory pool.
   çŸ¿å·¥èŠ‚ç‚¹æ¥æ”¶äº¤æ˜“å¹¶å°†å…¶ä¿å­˜åœ¨å†…å­˜æ± ä¸­ã€‚
6. When there are enough transactions in the memory pool, the miner starts mining a new block.
   å½“å†…å­˜æ± ä¸­æœ‰è¶³å¤Ÿå¤šçš„äº¤æ˜“æ—¶ï¼ŒçŸ¿å·¥å°±ä¼šå¼€å§‹æŒ–æ˜ä¸€ä¸ªæ–°åŒºå—ã€‚
7. When a new block is mined, itâ€™s send to the central node.
   æ–°åŒºå—æŒ–å‡ºåï¼Œä¼šå‘é€åˆ°ä¸­å¿ƒèŠ‚ç‚¹ã€‚
8. The wallet node synchronizes with the central node.
   é’±åŒ…èŠ‚ç‚¹ä¸ä¸­å¤®èŠ‚ç‚¹åŒæ­¥ã€‚
9. User of the wallet node checks that their payment was successful.
   é’±åŒ…èŠ‚ç‚¹ç”¨æˆ·æ£€æŸ¥ä»˜æ¬¾æ˜¯å¦æˆåŠŸã€‚

This is what it looks like in Bitcoin. Even though weâ€™re not going to build a real P2P network, weâ€™re going to implement a real, and the main and most important, use case of Bitcoin.
è¿™å°±æ˜¯æ¯”ç‰¹å¸çš„æ ·å­ã€‚å°½ç®¡æˆ‘ä»¬ä¸ä¼šå»ºç«‹ä¸€ä¸ªçœŸæ­£çš„ P2P ç½‘ç»œï¼Œä½†æˆ‘ä»¬è¦å®ç°ä¸€ä¸ªçœŸæ­£çš„ï¼Œä¹Ÿæ˜¯æ¯”ç‰¹å¸æœ€ä¸»è¦ã€æœ€é‡è¦çš„ä½¿ç”¨æ¡ˆä¾‹ã€‚

#### version ç‰ˆæœ¬

Nodes communicate by the means of messages. When a new node is run, it gets several nodes from a DNS seed, and sends them `version` message, which in our implementation will look like this:
èŠ‚ç‚¹é€šè¿‡æ¶ˆæ¯è¿›è¡Œé€šä¿¡ã€‚å½“ä¸€ä¸ªæ–°èŠ‚ç‚¹è¿è¡Œæ—¶ï¼Œå®ƒä¼šä» DNS ç§å­ä¸­è·å–å‡ ä¸ªèŠ‚ç‚¹ï¼Œå¹¶å‘å®ƒä»¬å‘é€ `version` æ¶ˆæ¯ï¼Œåœ¨æˆ‘ä»¬çš„å®ç°ä¸­ï¼Œæ¶ˆæ¯çš„å†…å®¹å¦‚ä¸‹ï¼š

```go
type version struct {
    Version    int
    BestHeight int
    AddrFrom   string
}
```

We have only one blockchain version, so the `Version` field wonâ€™t keep any important information. `BestHeight` stores the length of the nodeâ€™s blockchain. `AddFrom` stores the address of the sender.
æˆ‘ä»¬åªæœ‰ä¸€ä¸ªåŒºå—é“¾ç‰ˆæœ¬ï¼Œå› æ­¤ `Version` å­—æ®µä¸ä¼šä¿ç•™ä»»ä½•é‡è¦ä¿¡æ¯ã€‚ `BestHeight` å­˜å‚¨èŠ‚ç‚¹åŒºå—é“¾çš„é•¿åº¦ã€‚ `AddFrom` å­˜å‚¨å‘é€è€…çš„åœ°å€ã€‚

What should a node that receives a `version` message do? Itâ€™ll respond with its own `version` message. This is a kind of a handshake: no other interaction is possible without prior greeting of each other. But itâ€™s not just politeness: `version` is used to find a longer blockchain. When a node receives a `version` message it checks if the nodeâ€™s blockchain is longer than the value of `BestHeight`. If itâ€™s not, the node will request and download missing blocks.
æ”¶åˆ° `version` æ¶ˆæ¯çš„èŠ‚ç‚¹åº”è¯¥åšä»€ä¹ˆï¼Ÿå®ƒå°†ä»¥è‡ªå·±çš„ `version` æ¶ˆæ¯ä½œä¸ºå›åº”ã€‚è¿™æ˜¯ä¸€ç§æ¡æ‰‹ï¼šå¦‚æœä¸äº‹å…ˆäº’ç›¸é—®å€™ï¼Œå°±æ— æ³•è¿›è¡Œå…¶ä»–äº¤äº’ã€‚ä½†è¿™ä¸ä»…ä»…æ˜¯ç¤¼è²Œé—®é¢˜ï¼š `version` ç”¨äºå¯»æ‰¾æ›´é•¿çš„åŒºå—é“¾ã€‚å½“èŠ‚ç‚¹æ”¶åˆ° `version` æ¶ˆæ¯æ—¶ï¼Œå®ƒä¼šæ£€æŸ¥èŠ‚ç‚¹çš„åŒºå—é“¾æ˜¯å¦é•¿äº `BestHeight` çš„å€¼ã€‚å¦‚æœæ²¡æœ‰ï¼ŒèŠ‚ç‚¹å°†è¯·æ±‚å¹¶ä¸‹è½½ç¼ºå¤±çš„åŒºå—ã€‚

In order to receive message, we need a server:
ä¸ºäº†æ¥æ”¶ä¿¡æ¯ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæœåŠ¡å™¨ï¼š

```go
var nodeAddress string
var knownNodes = []string{"localhost:3000"}

func StartServer(nodeID, minerAddress string) {
    nodeAddress = fmt.Sprintf("localhost:%s", nodeID)
    miningAddress = minerAddress
    ln, err := net.Listen(protocol, nodeAddress)
    defer ln.Close()

    bc := NewBlockchain(nodeID)

    if nodeAddress != knownNodes[0] {
        sendVersion(knownNodes[0], bc)
    }

    for {
        conn, err := ln.Accept()
        go handleConnection(conn, bc)
    }
}
```

First, we hardcode the address of the central node: every node must know where to connect to initially. `minerAddress` argument specifies the address to receive mining rewards to. This piece:
é¦–å…ˆï¼Œæˆ‘ä»¬å¯¹ä¸­å¿ƒèŠ‚ç‚¹çš„åœ°å€è¿›è¡Œäº†ç¡¬ç¼–ç ï¼šæ¯ä¸ªèŠ‚ç‚¹éƒ½å¿…é¡»çŸ¥é“åˆå§‹è¿æ¥åˆ°å“ªé‡Œã€‚ `minerAddress` å‚æ•°æŒ‡å®šäº†æ¥æ”¶æŒ–çŸ¿å¥–åŠ±çš„åœ°å€ã€‚è¿™ä¸€å—ï¼š

```go
if nodeAddress != knownNodes[0] {
    sendVersion(knownNodes[0], bc)
}
```

Means that if current node is not the central one, it must send `version` message to the central node to find out if its blockchain is outdated.
ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœå½“å‰èŠ‚ç‚¹ä¸æ˜¯ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå®ƒå¿…é¡»å‘ä¸­å¿ƒèŠ‚ç‚¹å‘é€ `version` æ¶ˆæ¯ï¼Œä»¥äº†è§£å…¶åŒºå—é“¾æ˜¯å¦è¿‡æ—¶ã€‚

```go
func sendVersion(addr string, bc *Blockchain) {
    bestHeight := bc.GetBestHeight()
    payload := gobEncode(version{nodeVersion, bestHeight, nodeAddress})

    request := append(commandToBytes("version"), payload...)

    sendData(addr, request)
}
```

Our messages, on the lower level, are sequences of bytes. First 12 bytes specify command name (â€œversionâ€ in this case), and the latter bytes will contain `gob`-encoded message structure. `commandToBytes` looks like this:
æˆ‘ä»¬çš„ä¿¡æ¯åœ¨ä¸‹å±‚æ˜¯å­—èŠ‚åºåˆ—ã€‚å‰ 12 ä¸ªå­—èŠ‚æŒ‡å®šå‘½ä»¤åç§°ï¼ˆæœ¬ä¾‹ä¸­ä¸º "ç‰ˆæœ¬"ï¼‰ï¼Œå 12 ä¸ªå­—èŠ‚åŒ…å« `gob` ç¼–ç çš„æŠ¥æ–‡ç»“æ„ã€‚ `commandToBytes` çœ‹èµ·æ¥åƒè¿™æ ·ï¼š

```go
func commandToBytes(command string) []byte {
    var bytes [commandLength]byte

    for i, c := range command {
        bytes[i] = byte(c)
    }

    return bytes[:]
}
```

It creates a 12-byte buffer and fills it with the command name, leaving rest bytes empty. Thereâ€™s an opposite function:
å®ƒä¼šåˆ›å»ºä¸€ä¸ª 12 å­—èŠ‚çš„ç¼“å†²åŒºï¼Œå¹¶å°†å‘½ä»¤åç§°å¡«å…¥å…¶ä¸­ï¼Œå…¶ä½™å­—èŠ‚ç•™ç©ºã€‚è¿˜æœ‰ä¸€ä¸ªç›¸åçš„å‡½æ•°ï¼š

```go
func bytesToCommand(bytes []byte) string {
    var command []byte

    for _, b := range bytes {
        if b != 0x0 {
            command = append(command, b)
        }
    }

    return fmt.Sprintf("%s", command)
}
```

When a node receives a command, it runs `bytesToCommand` to extract command name and processes command body with correct handler:
èŠ‚ç‚¹æ”¶åˆ°å‘½ä»¤åï¼Œä¼šè¿è¡Œ `bytesToCommand` æå–å‘½ä»¤åï¼Œå¹¶ä½¿ç”¨æ­£ç¡®çš„å¤„ç†ç¨‹åºå¤„ç†å‘½ä»¤ä½“ï¼š

```go
func handleConnection(conn net.Conn, bc *Blockchain) {
    request, err := ioutil.ReadAll(conn)
    command := bytesToCommand(request[:commandLength])
    fmt.Printf("Received %s command\n", command)

    switch command {
    ...
    case "version":
        handleVersion(request, bc)
    default:
        fmt.Println("Unknown command!")
    }

    conn.Close()
}
```

Ok, this is what the `version` command handler looks like:
å¥½äº†ï¼Œè¿™å°±æ˜¯ `version` å‘½ä»¤å¤„ç†ç¨‹åºçš„æ ·å­ï¼š

```go
func handleVersion(request []byte, bc *Blockchain) {
    var buff bytes.Buffer
    var payload verzion

    buff.Write(request[commandLength:])
    dec := gob.NewDecoder(&buff)
    err := dec.Decode(&payload)

    myBestHeight := bc.GetBestHeight()
    foreignerBestHeight := payload.BestHeight

    if myBestHeight < foreignerBestHeight {
        sendGetBlocks(payload.AddrFrom)
    } else if myBestHeight > foreignerBestHeight {
        sendVersion(payload.AddrFrom, bc)
    }

    if !nodeIsKnown(payload.AddrFrom) {
        knownNodes = append(knownNodes, payload.AddrFrom)
    }
}
```

First, we need to decode the request and extract the payload. This is similar to all the handlers, so Iâ€™ll omit this piece in the future code snippets.
é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦è§£ç è¯·æ±‚å¹¶æå–æœ‰æ•ˆè´Ÿè½½ã€‚è¿™ä¸€ç‚¹ä¸æ‰€æœ‰å¤„ç†ç¨‹åºç±»ä¼¼ï¼Œå› æ­¤æˆ‘å°†åœ¨ä»¥åçš„ä»£ç ç‰‡æ®µä¸­çœç•¥è¿™ä¸€éƒ¨åˆ†ã€‚

Then a node compares its `BestHeight` with the one from the message. If the nodeâ€™s blockchain is longer, itâ€™ll reply with `version` message; otherwise, itâ€™ll send `getblocks` message.
ç„¶åï¼ŒèŠ‚ç‚¹å°†è‡ªå·±çš„ `BestHeight` ä¸æ¶ˆæ¯ä¸­çš„ è¿›è¡Œæ¯”è¾ƒã€‚å¦‚æœèŠ‚ç‚¹çš„åŒºå—é“¾æ›´é•¿ï¼Œå®ƒå°†å›å¤ `version` æ¶ˆæ¯ï¼›å¦åˆ™ï¼Œå®ƒå°†å‘é€ `getblocks` æ¶ˆæ¯ã€‚

#### getblocks è·å–å—

```go
type getblocks struct {
    AddrFrom string
}
```

`getblocks` means â€œshow me what blocks you haveâ€ (in Bitcoin, itâ€™s more complex). Pay attention, it doesnâ€™t say â€œgive me all your blocksâ€, instead it requests a list of block hashes. This is done to reduce network load, because blocks can be downloaded from different nodes, and we donâ€™t want to download dozens of gigabytes from one node.
`getblocks` çš„æ„æ€æ˜¯ "å‘Šè¯‰æˆ‘ä½ æœ‰å“ªäº›åŒºå—"ï¼ˆåœ¨æ¯”ç‰¹å¸ä¸­ï¼Œè¿™ä¸ªæ„æ€æ›´å¤æ‚ï¼‰ã€‚æ³¨æ„ï¼Œå®ƒå¹¶ä¸æ˜¯è¯´ "ç»™æˆ‘ä½ æ‰€æœ‰çš„åŒºå—"ï¼Œè€Œæ˜¯è¯·æ±‚ä¸€ä¸ªåŒºå—å“ˆå¸Œå€¼åˆ—è¡¨ã€‚è¿™æ ·åšæ˜¯ä¸ºäº†å‡å°‘ç½‘ç»œè´Ÿè·ï¼Œå› ä¸ºåŒºå—å¯ä»¥ä»ä¸åŒçš„èŠ‚ç‚¹ä¸‹è½½ï¼Œæˆ‘ä»¬ä¸æƒ³ä»ä¸€ä¸ªèŠ‚ç‚¹ä¸‹è½½å‡ åä¸ªåƒå…†å­—èŠ‚ã€‚

Handling the command as easy as:
å¤„ç†å‘½ä»¤å°±åƒ

```go
func handleGetBlocks(request []byte, bc *Blockchain) {
    ...
    blocks := bc.GetBlockHashes()
    sendInv(payload.AddrFrom, "block", blocks)
}
```

In our simplified implementation, itâ€™ll return **all block hashes**.
åœ¨æˆ‘ä»¬çš„ç®€åŒ–å®ç°ä¸­ï¼Œå®ƒå°†è¿”å›æ‰€æœ‰å—çš„å“ˆå¸Œå€¼ã€‚

#### inv

```go
type inv struct {
    AddrFrom string
    Type     string
    Items    [][]byte
}
```

Bitcoin uses `inv` to show other nodes what blocks or transactions current node has. Again, it doesnâ€™t contain whole blocks and transactions, just their hashes. The `Type` field says whether these are blocks or transactions.
æ¯”ç‰¹å¸ä½¿ç”¨ `inv` å‘å…¶ä»–èŠ‚ç‚¹æ˜¾ç¤ºå½“å‰èŠ‚ç‚¹æ‹¥æœ‰å“ªäº›åŒºå—æˆ–äº¤æ˜“ã€‚åŒæ ·ï¼Œå®ƒä¸åŒ…å«æ•´ä¸ªåŒºå—å’Œäº¤æ˜“ï¼ŒåªåŒ…å«å®ƒä»¬çš„å“ˆå¸Œå€¼ã€‚ `Type` å­—æ®µè¯´æ˜äº†è¿™äº›æ˜¯åŒºå—è¿˜æ˜¯äº¤æ˜“ã€‚

Handling `inv` is more difficult:
å¤„ç† `inv` åˆ™æ›´ä¸ºå›°éš¾ï¼š

```go
func handleInv(request []byte, bc *Blockchain) {
    ...
    fmt.Printf("Recevied inventory with %d %s\n", len(payload.Items), payload.Type)

    if payload.Type == "block" {
        blocksInTransit = payload.Items

        blockHash := payload.Items[0]
        sendGetData(payload.AddrFrom, "block", blockHash)

        newInTransit := [][]byte{}
        for _, b := range blocksInTransit {
            if bytes.Compare(b, blockHash) != 0 {
                newInTransit = append(newInTransit, b)
            }
        }
        blocksInTransit = newInTransit
    }

    if payload.Type == "tx" {
        txID := payload.Items[0]

        if mempool[hex.EncodeToString(txID)].ID == nil {
            sendGetData(payload.AddrFrom, "tx", txID)
        }
    }
}
```

If blocks hashes are transferred, we want to save them in `blocksInTransit` variable to track downloaded blocks. This allows us to download blocks from different nodes. Right after putting blocks into the transit state, we send `getdata` command to the sender of the `inv` message and update `blocksInTransit`. In a real P2P network, we would want to transfer blocks from different nodes.
å¦‚æœä¼ è¾“äº†åŒºå—å“ˆå¸Œå€¼ï¼Œæˆ‘ä»¬å¸Œæœ›å°†å…¶ä¿å­˜åœ¨ `blocksInTransit` å˜é‡ä¸­ï¼Œä»¥è·Ÿè¸ªä¸‹è½½çš„åŒºå—ã€‚è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ä»ä¸åŒèŠ‚ç‚¹ä¸‹è½½åŒºå—ã€‚å°†åŒºå—è½¬å…¥ä¼ è¾“çŠ¶æ€åï¼Œæˆ‘ä»¬ä¼šç«‹å³å‘ `inv` æ¶ˆæ¯çš„å‘é€è€…å‘é€ `getdata` å‘½ä»¤ï¼Œå¹¶æ›´æ–° `blocksInTransit` ã€‚åœ¨çœŸæ­£çš„ P2P ç½‘ç»œä¸­ï¼Œæˆ‘ä»¬å¸Œæœ›ä»ä¸åŒçš„èŠ‚ç‚¹ä¼ è¾“åŒºå—ã€‚

In our implementation, weâ€™ll never send `inv` with multiple hashes. Thatâ€™s why when `payload.Type == "tx"` only the first hash is taken. Then we check if we already have the hash in our mempool, and if not, `getdata` message is sent.
åœ¨æˆ‘ä»¬çš„å®æ–½è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬æ°¸è¿œä¸ä¼šå‘é€å¸¦æœ‰å¤šä¸ªå“ˆå¸Œå€¼çš„ `inv` ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåœ¨ `payload.Type == "tx"` æ—¶åªæå–ç¬¬ä¸€ä¸ªå“ˆå¸Œå€¼ã€‚ç„¶åï¼Œæˆ‘ä»¬ä¼šæ£€æŸ¥å†…å­˜æ± ä¸­æ˜¯å¦å·²æœ‰å“ˆå¸Œå€¼ï¼Œå¦‚æœæ²¡æœ‰ï¼Œå°±ä¼šå‘é€ `getdata` æ¶ˆæ¯ã€‚

#### getdata è·å–æ•°æ®

```go
type getdata struct {
    AddrFrom string
    Type     string
    ID       []byte
}
```

`getdata` is a request for certain block or transaction, and it can contain only one block/transaction ID.
`getdata` æ˜¯å¯¹æŸä¸ªåŒºå—æˆ–äº¤æ˜“çš„è¯·æ±‚ï¼Œåªèƒ½åŒ…å«ä¸€ä¸ªåŒºå—/äº¤æ˜“ IDã€‚

```go
func handleGetData(request []byte, bc *Blockchain) {
    ...
    if payload.Type == "block" {
        block, err := bc.GetBlock([]byte(payload.ID))

        sendBlock(payload.AddrFrom, &block)
    }

    if payload.Type == "tx" {
        txID := hex.EncodeToString(payload.ID)
        tx := mempool[txID]

        sendTx(payload.AddrFrom, &tx)
    }
}
```

The handler is straightforward: if they request a block, return the block; if they request a transaction, return the transaction. Notice, that we donâ€™t check if we actually have this block or transaction. This is a flaw :)
å¤„ç†ç¨‹åºå¾ˆç®€å•ï¼šå¦‚æœä»–ä»¬è¯·æ±‚ä¸€ä¸ªåŒºå—ï¼Œåˆ™è¿”å›è¯¥åŒºå—ï¼›å¦‚æœä»–ä»¬è¯·æ±‚ä¸€ä¸ªäº‹åŠ¡ï¼Œåˆ™è¿”å›è¯¥äº‹åŠ¡ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰æ£€æŸ¥æ˜¯å¦çœŸçš„æœ‰è¿™ä¸ªåŒºå—æˆ–äº‹åŠ¡ã€‚è¿™æ˜¯ä¸€ä¸ªç¼ºé™·ï¼‰

#### block and tx å—å’Œ tx

```go
type block struct {
    AddrFrom string
    Block    []byte
}

type tx struct {
    AddFrom     string
    Transaction []byte
}
```

Itâ€™s these messages that actually transfer the data.
æ­£æ˜¯è¿™äº›ä¿¡æ¯åœ¨å®é™…ä¼ è¾“æ•°æ®ã€‚

Handling the `block` message is easy:
å¤„ç† `block` æ¶ˆæ¯éå¸¸ç®€å•ï¼š

```go
func handleBlock(request []byte, bc *Blockchain) {
    ...

    blockData := payload.Block
    block := DeserializeBlock(blockData)

    fmt.Println("Recevied a new block!")
    bc.AddBlock(block)

    fmt.Printf("Added block %x\n", block.Hash)

    if len(blocksInTransit) > 0 {
        blockHash := blocksInTransit[0]
        sendGetData(payload.AddrFrom, "block", blockHash)

        blocksInTransit = blocksInTransit[1:]
    } else {
        UTXOSet := UTXOSet{bc}
        UTXOSet.Reindex()
    }
}
```

When we received a new block, we put it into our blockchain. If thereâ€™re more blocks to download, we request them from the same node we downloaded the previous block. When we finally downloaded all the blocks, the UTXO set is reindexed.
å½“æˆ‘ä»¬æ”¶åˆ°ä¸€ä¸ªæ–°åŒºå—æ—¶ï¼Œå°±ä¼šå°†å…¶æ”¾å…¥æˆ‘ä»¬çš„åŒºå—é“¾ä¸­ã€‚å¦‚æœè¿˜æœ‰æ›´å¤šçš„åŒºå—éœ€è¦ä¸‹è½½ï¼Œæˆ‘ä»¬å°±ä¼šå‘ä¸‹è½½å‰ä¸€ä¸ªåŒºå—çš„èŠ‚ç‚¹è¯·æ±‚ä¸‹è½½ã€‚å½“æˆ‘ä»¬æœ€ç»ˆä¸‹è½½å®Œæ‰€æœ‰åŒºå—åï¼ŒUTXO é›†å°†è¢«é‡æ–°ç´¢å¼•ã€‚

> TODO: Instead of trusting unconditionally, we should validate every incoming block before adding it to the blockchain.
> å¾…åŠäº‹é¡¹ï¼šæˆ‘ä»¬ä¸åº”è¯¥æ— æ¡ä»¶ä¿¡ä»»ï¼Œè€Œåº”è¯¥åœ¨å°†æ¯ä¸ªä¼ å…¥çš„åŒºå—æ·»åŠ åˆ°åŒºå—é“¾ä¹‹å‰å¯¹å…¶è¿›è¡ŒéªŒè¯ã€‚

> TODO: Instead of running UTXOSet.Reindex(), UTXOSet.Update(block) should be used, because if blockchain is big, itâ€™ll take a lot of time to reindex the whole UTXO set.
> TODO: ä¸å…¶è¿è¡Œ UTXOSet.Reindex()ï¼Œä¸å¦‚ä½¿ç”¨ UTXOSet.Update(block)ï¼Œå› ä¸ºå¦‚æœåŒºå—é“¾å¾ˆå¤§ï¼Œé‡æ–°ç´¢å¼•æ•´ä¸ª UTXO é›†å°†è€—è´¹å¤§é‡æ—¶é—´ã€‚

Handling `tx` messages is the most difficult part:
å¤„ç† `tx` ä¿¡æ¯æ˜¯æœ€å›°éš¾çš„éƒ¨åˆ†ï¼š

```go
func handleTx(request []byte, bc *Blockchain) {
    ...
    txData := payload.Transaction
    tx := DeserializeTransaction(txData)
    mempool[hex.EncodeToString(tx.ID)] = tx

    if nodeAddress == knownNodes[0] {
        for _, node := range knownNodes {
            if node != nodeAddress && node != payload.AddFrom {
                sendInv(node, "tx", [][]byte{tx.ID})
            }
        }
    } else {
        if len(mempool) >= 2 && len(miningAddress) > 0 {
        MineTransactions:
            var txs []*Transaction

            for id := range mempool {
                tx := mempool[id]
                if bc.VerifyTransaction(&tx) {
                    txs = append(txs, &tx)
                }
            }

            if len(txs) == 0 {
                fmt.Println("All transactions are invalid! Waiting for new ones...")
                return
            }

            cbTx := NewCoinbaseTX(miningAddress, "")
            txs = append(txs, cbTx)

            newBlock := bc.MineBlock(txs)
            UTXOSet := UTXOSet{bc}
            UTXOSet.Reindex()

            fmt.Println("New block is mined!")

            for _, tx := range txs {
                txID := hex.EncodeToString(tx.ID)
                delete(mempool, txID)
            }

            for _, node := range knownNodes {
                if node != nodeAddress {
                    sendInv(node, "block", [][]byte{newBlock.Hash})
                }
            }

            if len(mempool) > 0 {
                goto MineTransactions
            }
        }
    }
}
```

First thing to do is to put new transaction in the mempool (again, transactions must be verified before being placed into the mempool). Next piece:
é¦–å…ˆè¦åšçš„æ˜¯å°†æ–°äº‹åŠ¡æ”¾å…¥å†…å­˜æ± ï¼ˆåŒæ ·ï¼Œäº‹åŠ¡åœ¨æ”¾å…¥å†…å­˜æ± ä¹‹å‰å¿…é¡»ç»è¿‡éªŒè¯ï¼‰ã€‚ä¸‹ä¸€å—

```go
if nodeAddress == knownNodes[0] {
    for _, node := range knownNodes {
        if node != nodeAddress && node != payload.AddFrom {
            sendInv(node, "tx", [][]byte{tx.ID})
        }
    }
}
```

Checks whether the current node is the central one. In our implementation, the central node wonâ€™t mine blocks. Instead, itâ€™ll forward the new transactions to other nodes in the network.
æ£€æŸ¥å½“å‰èŠ‚ç‚¹æ˜¯å¦ä¸ºä¸­å¿ƒèŠ‚ç‚¹ã€‚åœ¨æˆ‘ä»¬çš„å®ç°ä¸­ï¼Œä¸­å¿ƒèŠ‚ç‚¹ä¸ä¼šæŒ–æ˜åŒºå—ã€‚ç›¸åï¼Œå®ƒä¼šå°†æ–°äº¤æ˜“è½¬å‘ç»™ç½‘ç»œä¸­çš„å…¶ä»–èŠ‚ç‚¹ã€‚

The next big piece is only for miner nodes. Letâ€™s split it into smaller pieces:
ä¸‹ä¸€å¤§å—åªé’ˆå¯¹çŸ¿å·¥èŠ‚ç‚¹ã€‚è®©æˆ‘ä»¬æŠŠå®ƒåˆ†æˆå°å—ï¼š

```go
if len(mempool) >= 2 && len(miningAddress) > 0 {
```

`miningAddress` is only set on miner nodes. When there are 2 or more transactions in the mempool of the current (miner) node, mining begins.
`miningAddress` åªåœ¨çŸ¿å·¥èŠ‚ç‚¹ä¸Šè®¾ç½®ã€‚å½“å½“å‰ï¼ˆçŸ¿å·¥ï¼‰èŠ‚ç‚¹çš„å†…å­˜æ± ä¸­æœ‰ 2 ä¸ªæˆ–æ›´å¤šäº¤æ˜“æ—¶ï¼ŒæŒ–çŸ¿å°±å¼€å§‹äº†ã€‚

```go
for id := range mempool {
    tx := mempool[id]
    if bc.VerifyTransaction(&tx) {
        txs = append(txs, &tx)
    }
}

if len(txs) == 0 {
    fmt.Println("All transactions are invalid! Waiting for new ones...")
    return
}
```

First, all transactions in the mempool are verified. Invalid transactions are ignored, and if there are no valid transactions, mining is interrupted.
é¦–å…ˆï¼Œå¯¹ mempool ä¸­çš„æ‰€æœ‰äº¤æ˜“è¿›è¡ŒéªŒè¯ã€‚æ— æ•ˆäº¤æ˜“å°†è¢«å¿½ç•¥ï¼Œå¦‚æœæ²¡æœ‰æœ‰æ•ˆäº¤æ˜“ï¼ŒæŒ–çŸ¿å°†è¢«ä¸­æ–­ã€‚

```go
cbTx := NewCoinbaseTX(miningAddress, "")
txs = append(txs, cbTx)

newBlock := bc.MineBlock(txs)
UTXOSet := UTXOSet{bc}
UTXOSet.Reindex()

fmt.Println("New block is mined!")
```

Verified transactions are being put into a block, as well as a coinbase transaction with the reward. After mining the block, the UTXO set is reindexed.
ç»è¿‡éªŒè¯çš„äº¤æ˜“å°†è¢«æ”¾å…¥ä¸€ä¸ªåŒºå—ï¼ŒåŒæ—¶å¸å®‰äº¤æ˜“ä¹Ÿå°†è·å¾—å¥–åŠ±ã€‚æŒ–å‡ºåŒºå—åï¼ŒUTXO é›†å°†é‡æ–°ç´¢å¼•ã€‚

> TODO: Again, UTXOSet.Update should be used instead of UTXOSet.Reindex
> æç¤ºï¼šåŒæ ·ï¼Œåº”ä½¿ç”¨ UTXOSet.Update ä»£æ›¿ UTXOSet.Reindex

```go
for _, tx := range txs {
    txID := hex.EncodeToString(tx.ID)
    delete(mempool, txID)
}

for _, node := range knownNodes {
    if node != nodeAddress {
        sendInv(node, "block", [][]byte{newBlock.Hash})
    }
}

if len(mempool) > 0 {
    goto MineTransactions
}
```

After a transaction is mined, itâ€™s removed from the mempool. Every other nodes the current node is aware of, receive `inv` message with the new blockâ€™s hash. They can request the block after handling the message.
äº¤æ˜“æŒ–å®Œåï¼Œä¼šä»å†…å­˜æ± ä¸­åˆ é™¤ã€‚å½“å‰èŠ‚ç‚¹çŸ¥é“çš„æ‰€æœ‰å…¶ä»–èŠ‚ç‚¹éƒ½ä¼šæ”¶åˆ° `inv` æ¶ˆæ¯ï¼Œå…¶ä¸­åŒ…å«æ–°åŒºå—çš„å“ˆå¸Œå€¼ã€‚å¤„ç†å®Œæ¶ˆæ¯åï¼Œå®ƒä»¬å°±å¯ä»¥ç”³è¯·è¯¥åŒºå—ã€‚

### Result ç»“æœ

Letâ€™s play the scenario we defined earlier.
è®©æˆ‘ä»¬æ¥æ¨¡æ‹Ÿä¸€ä¸‹æˆ‘ä»¬ä¹‹å‰å®šä¹‰çš„æƒ…æ™¯ã€‚

First, set `NODE_ID` to 3000 (`export NODE_ID=3000`) in the first terminal window. Iâ€™ll use badges like `NODE 3000` or `NODE 3001` before next paragraphs, for you to know what node to perform actions on.
é¦–å…ˆï¼Œåœ¨ç¬¬ä¸€ä¸ªç»ˆç«¯çª—å£ä¸­å°† `NODE_ID` è®¾ç½®ä¸º 3000 ( `export NODE_ID=3000` )ã€‚æˆ‘ä¼šåœ¨æ¥ä¸‹æ¥çš„æ®µè½å‰ä½¿ç”¨ `NODE 3000` æˆ– `NODE 3001` è¿™æ ·çš„å¾½ç« ï¼Œä»¥ä¾¿ä½ çŸ¥é“è¦åœ¨å“ªä¸ªèŠ‚ç‚¹ä¸Šæ‰§è¡Œæ“ä½œã€‚

`NODE 3000`
Create a wallet and a new blockchain:
åˆ›å»ºé’±åŒ…å’Œæ–°åŒºå—é“¾ï¼š

```shell
$ blockchain_go createblockchain -address CENTREAL_NODE
```

(Iâ€™ll use fake addresses for clarity and brevity)
(ä¸ºç®€æ´æ˜äº†èµ·è§ï¼Œæˆ‘ä½¿ç”¨å‡åœ°å€ï¼‰

After that, the blockchain will contain single genesis block. We need to save the block and use it in other nodes. Genesis blocks serve as identifiers of blockchains (in Bitcoin Core, the genesis block is hardcoded).
ä¹‹åï¼ŒåŒºå—é“¾å°†åŒ…å«å•ä¸ªåˆ›ä¸–åŒºå—ã€‚æˆ‘ä»¬éœ€è¦ä¿å­˜è¿™ä¸ªåŒºå—ï¼Œå¹¶å°†å…¶ç”¨äºå…¶ä»–èŠ‚ç‚¹ã€‚åˆ›ä¸–åŒºå—æ˜¯åŒºå—é“¾çš„æ ‡è¯†ç¬¦ï¼ˆåœ¨ Bitcoin Core ä¸­ï¼Œåˆ›ä¸–åŒºå—æ˜¯ç¡¬ç¼–ç çš„ï¼‰ã€‚

```shell
$ cp blockchain_3000.db blockchain_genesis.db 
```

`NODE 3001`
Next, open a new terminal window and set node ID to 3001. This will be a wallet node. Generate some addresses with `blockchain_go createwallet`, weâ€™ll call these addresses `WALLET_1`, `WALLET_2`, `WALLET_3`.
æ¥ä¸‹æ¥ï¼Œæ‰“å¼€ä¸€ä¸ªæ–°çš„ç»ˆç«¯çª—å£ï¼Œå°†èŠ‚ç‚¹ ID è®¾ç½®ä¸º 3001ã€‚è¿™å°†æ˜¯ä¸€ä¸ªé’±åŒ…èŠ‚ç‚¹ã€‚ç”¨ `blockchain_go createwallet` ç”Ÿæˆä¸€äº›åœ°å€ï¼Œæˆ‘ä»¬å°†è¿™äº›åœ°å€ç§°ä¸º `WALLET_1` , `WALLET_2` , `WALLET_3` ã€‚

`NODE 3000`
Send some coins to the wallet addresses:
å‘é’±åŒ…åœ°å€å‘é€ä¸€äº›ç¡¬å¸ï¼š

```shell
$ blockchain_go send -from CENTREAL_NODE -to WALLET_1 -amount 10 -mine
$ blockchain_go send -from CENTREAL_NODE -to WALLET_2 -amount 10 -mine
```

`-mine` flag means that the block will be immediately mined by the same node. We have to have this flag because initially there are no miner nodes in the network.
`-mine` æ ‡è®°è¡¨ç¤ºè¯¥åŒºå—å°†ç«‹å³ç”±åŒä¸€èŠ‚ç‚¹è¿›è¡ŒæŒ–çŸ¿ã€‚æˆ‘ä»¬å¿…é¡»æœ‰è¿™ä¸ªæ ‡å¿—ï¼Œå› ä¸ºæœ€åˆç½‘ç»œä¸­æ²¡æœ‰çŸ¿å·¥èŠ‚ç‚¹ã€‚
Start the node: å¯åŠ¨èŠ‚ç‚¹ï¼š

```shell
$ blockchain_go startnode
```

The node must be running until the end of the scenario.
èŠ‚ç‚¹å¿…é¡»è¿è¡Œåˆ°æƒ…æ™¯ç»“æŸã€‚

`NODE 3001`
Start the nodeâ€™s blockchain with the genesis block saved above:
ç”¨ä¸Šé¢ä¿å­˜çš„åˆ›ä¸–åŒºå—å¯åŠ¨èŠ‚ç‚¹çš„åŒºå—é“¾ï¼š

```shell
$ cp blockchain_genesis.db blockchain_3001.db
```

Run the node:
è¿è¡ŒèŠ‚ç‚¹ï¼š

```shell
$ blockchain_go startnode
```

Itâ€™ll download all the blocks from the central node. To check that everythingâ€™s ok, stop the node and check the balances:
å®ƒä¼šä»ä¸­å¤®èŠ‚ç‚¹ä¸‹è½½æ‰€æœ‰åŒºå—ã€‚è¦æ£€æŸ¥æ˜¯å¦ä¸€åˆ‡æ­£å¸¸ï¼Œè¯·åœæ­¢èŠ‚ç‚¹å¹¶æ£€æŸ¥ä½™é¢ï¼š

```shell
$ blockchain_go getbalance -address WALLET_1
Balance of 'WALLET_1': 10

$ blockchain_go getbalance -address WALLET_2
Balance of 'WALLET_2': 10
```

Also, you can check the balance of the `CENTRAL_NODE` address, because the node 3001 now has its blockchain:
æ­¤å¤–ï¼Œæ‚¨è¿˜å¯ä»¥æŸ¥çœ‹ `CENTRAL_NODE` åœ°å€çš„ä½™é¢ï¼Œå› ä¸ºèŠ‚ç‚¹ 3001 ç°åœ¨æœ‰äº†è‡ªå·±çš„åŒºå—é“¾ï¼š

```shell
$ blockchain_go getbalance -address CENTRAL_NODE
Balance of 'CENTRAL_NODE': 10
```

`NODE 3002`
Open a new terminal window and set its ID to 3002, and generate a wallet. This will be a miner node. Initialize the blockchain:
æ‰“å¼€ä¸€ä¸ªæ–°çš„ç»ˆç«¯çª—å£ï¼Œå°†å…¶ ID è®¾ç½®ä¸º 3002ï¼Œç„¶åç”Ÿæˆä¸€ä¸ªé’±åŒ…ã€‚è¿™å°†æ˜¯ä¸€ä¸ªçŸ¿å·¥èŠ‚ç‚¹ã€‚åˆå§‹åŒ–åŒºå—é“¾ï¼š

```shell
$ cp blockchain_genesis.db blockchain_3002.db
```

And start the node:
ç„¶åå¯åŠ¨èŠ‚ç‚¹ï¼š

```shell
$ blockchain_go startnode -miner MINER_WALLET
```

`NODE 3001`
Send some coins: å¯„äº›ç¡¬å¸æ¥

```shell
$ blockchain_go send -from WALLET_1 -to WALLET_3 -amount 1
$ blockchain_go send -from WALLET_2 -to WALLET_4 -amount 1
```

`NODE 3002`
Quickly! Switch to the miner node and see it mining a new block! Also, check the output of the central node.
å¿«ï¼åˆ‡æ¢åˆ°çŸ¿å·¥èŠ‚ç‚¹ï¼ŒæŸ¥çœ‹å®ƒæ­£åœ¨æŒ–æ˜æ–°åŒºå—ï¼åŒæ—¶ï¼Œæ£€æŸ¥ä¸­å¤®èŠ‚ç‚¹çš„è¾“å‡ºã€‚

`NODE 3001`
Switch to the wallet node and start it:
åˆ‡æ¢åˆ°é’±åŒ…èŠ‚ç‚¹å¹¶å¯åŠ¨å®ƒï¼š

```shell
$ blockchain_go startnode
```

Itâ€™ll download the newly mined block!
å®ƒä¼šä¸‹è½½æ–°æŒ–å‡ºçš„åŒºå—ï¼

Stop it and check balances:
åœä¸‹æ¥ï¼Œæ£€æŸ¥ä½™é¢ï¼š

```shell
$ blockchain_go getbalance -address WALLET_1
Balance of 'WALLET_1': 9

$ blockchain_go getbalance -address WALLET_2
Balance of 'WALLET_2': 9

$ blockchain_go getbalance -address WALLET_3
Balance of 'WALLET_3': 1

$ blockchain_go getbalance -address WALLET_4
Balance of 'WALLET_4': 1

$ blockchain_go getbalance -address MINER_WALLET
Balance of 'MINER_WALLET': 10
```

Thatâ€™s it! å°±æ˜¯è¿™æ ·ï¼

### Conclusion ç»“è®º

This was the final part of the series. I couldâ€™ve publish some more posts implementing a real prototype of a P2P network, but I just donâ€™t have time for this. I hope this article answers some of your questions about the Bitcoin technology and raises new ones, for which you can find answers yourself. There are more interesting things hidden in the Bitcoin technology! Good luck!
è¿™æ˜¯è¿™ä¸ªç³»åˆ—çš„æœ€åä¸€éƒ¨åˆ†ã€‚æˆ‘æœ¬å¯ä»¥å†å‘è¡¨ä¸€äº›æ–‡ç« æ¥å®ç°ä¸€ä¸ªçœŸæ­£çš„ P2P ç½‘ç»œåŸå‹ï¼Œä½†æˆ‘å®åœ¨æ²¡æœ‰æ—¶é—´äº†ã€‚æˆ‘å¸Œæœ›è¿™ç¯‡æ–‡ç« èƒ½å›ç­”ä½ å…³äºæ¯”ç‰¹å¸æŠ€æœ¯çš„ä¸€äº›é—®é¢˜ï¼Œå¹¶æå‡ºæ–°çš„é—®é¢˜ï¼Œä½ å¯ä»¥è‡ªå·±å»å¯»æ‰¾ç­”æ¡ˆã€‚æ¯”ç‰¹å¸æŠ€æœ¯ä¸­è¿˜éšè—ç€æ›´å¤šæœ‰è¶£çš„ä¸œè¥¿ï¼ç¥ä½ å¥½è¿

P.S. You can start improving the network with implementing the `addr` message, as described in the Bitcoin network protocol (link is below). This is a very important message, because it allows nodes to discover each other. I started implementing it, but havenâ€™t finished!
é™„æ³¨ï¼šæ‚¨å¯ä»¥æ ¹æ®æ¯”ç‰¹å¸ç½‘ç»œåè®®ï¼ˆé“¾æ¥å¦‚ä¸‹ï¼‰ä¸­çš„æè¿°ï¼Œé€šè¿‡å®æ–½ `addr` æ¶ˆæ¯æ¥æ”¹è¿›ç½‘ç»œã€‚è¿™æ˜¯ä¸€æ¡éå¸¸é‡è¦çš„ä¿¡æ¯ï¼Œå› ä¸ºå®ƒå…è®¸èŠ‚ç‚¹ä¹‹é—´ç›¸äº’å‘ç°ã€‚æˆ‘å·²ç»å¼€å§‹æ‰§è¡Œäº†ï¼Œä½†è¿˜æ²¡æœ‰å®Œæˆï¼

Links: é“¾æ¥

1. [Source codes æºä»£ç ](https://github.com/Jeiwan/blockchain_go/tree/part_7)
2. [Bitcoin protocol documentation
   æ¯”ç‰¹å¸åè®®æ–‡æ¡£](https://en.bitcoin.it/wiki/Protocol_documentation)
3. [Bitcoin network æ¯”ç‰¹å¸ç½‘ç»œ](https://en.bitcoin.it/wiki/Network)

